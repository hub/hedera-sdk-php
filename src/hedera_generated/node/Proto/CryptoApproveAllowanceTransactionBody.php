<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: crypto_approve_allowance.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Create ("Approve") allowances for one account to transfer tokens owned
 * by a different account.<br/>
 * An allowance permits a "spender" account to independently transfer tokens
 * owned by a separate "owner" account. Each such allowance permits spending
 * any amount, up to a specified limit, for fungible/common tokens; a single
 * specified non-fungible/unique token, or all non-fungible/unique tokens
 * of a particular token type held by the "owner" account.
 * If the "owner" account is not specified for any allowance in this
 * transaction (the `owner` field is not set), the `payer` account for this
 * transaction SHALL be owner for that allowance.<br/>
 * Each `owner` account specified in any allowance approved in this
 * transaction MUST sign this transaction.<br/>
 * If the `amount` field for any fungible/common allowance in this
 * transaction is `0`, then that allowance SHOULD match an existing,
 * previously approved, allowance which SHALL be removed.<br/>
 * There are three lists in this message. Each list MAY be empty, but
 * _at least one_ list MUST contain _at least one_ entry.
 * Example for the `payer` rule.<br/>
 *  - Given an account `0.0.X` that pays for this transaction, and owner
 *    is not specified in an allowance of `200` HBAR to spender account
 *    `0.0.Y`. At consensus the spender account `0.0.Y` will have a new
 *    allowance to spend `200` HBAR from the balance of account `0.0.X`.
 * ### Block Stream Effects
 * None
 *
 * Generated from protobuf message <code>proto.CryptoApproveAllowanceTransactionBody</code>
 */
class CryptoApproveAllowanceTransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * List of hbar allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.CryptoAllowance cryptoAllowances = 1;</code>
     */
    private $cryptoAllowances;
    /**
     **
     * List of non-fungible token allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.NftAllowance nftAllowances = 2;</code>
     */
    private $nftAllowances;
    /**
     **
     * List of fungible token allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.TokenAllowance tokenAllowances = 3;</code>
     */
    private $tokenAllowances;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\CryptoAllowance[] $cryptoAllowances
     *          *
     *           List of hbar allowances approved by the account owner.
     *           <p>
     *           This list MAY be empty, provided at least one other list is
     *           not empty.
     *     @type \Proto\NftAllowance[] $nftAllowances
     *          *
     *           List of non-fungible token allowances approved by the account owner.
     *           <p>
     *           This list MAY be empty, provided at least one other list is
     *           not empty.
     *     @type \Proto\TokenAllowance[] $tokenAllowances
     *          *
     *           List of fungible token allowances approved by the account owner.
     *           <p>
     *           This list MAY be empty, provided at least one other list is
     *           not empty.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\CryptoApproveAllowance::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * List of hbar allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.CryptoAllowance cryptoAllowances = 1;</code>
     * @return RepeatedField<\Proto\CryptoAllowance>
     */
    public function getCryptoAllowances()
    {
        return $this->cryptoAllowances;
    }

    /**
     **
     * List of hbar allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.CryptoAllowance cryptoAllowances = 1;</code>
     * @param \Proto\CryptoAllowance[] $var
     * @return $this
     */
    public function setCryptoAllowances($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\CryptoAllowance::class);
        $this->cryptoAllowances = $arr;

        return $this;
    }

    /**
     **
     * List of non-fungible token allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.NftAllowance nftAllowances = 2;</code>
     * @return RepeatedField<\Proto\NftAllowance>
     */
    public function getNftAllowances()
    {
        return $this->nftAllowances;
    }

    /**
     **
     * List of non-fungible token allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.NftAllowance nftAllowances = 2;</code>
     * @param \Proto\NftAllowance[] $var
     * @return $this
     */
    public function setNftAllowances($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\NftAllowance::class);
        $this->nftAllowances = $arr;

        return $this;
    }

    /**
     **
     * List of fungible token allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.TokenAllowance tokenAllowances = 3;</code>
     * @return RepeatedField<\Proto\TokenAllowance>
     */
    public function getTokenAllowances()
    {
        return $this->tokenAllowances;
    }

    /**
     **
     * List of fungible token allowances approved by the account owner.
     * <p>
     * This list MAY be empty, provided at least one other list is
     * not empty.
     *
     * Generated from protobuf field <code>repeated .proto.TokenAllowance tokenAllowances = 3;</code>
     * @param \Proto\TokenAllowance[] $var
     * @return $this
     */
    public function setTokenAllowances($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\TokenAllowance::class);
        $this->tokenAllowances = $arr;

        return $this;
    }

}

