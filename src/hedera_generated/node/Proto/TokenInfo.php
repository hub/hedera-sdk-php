<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: token_get_info.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * An Hedera Token Service(HTS) token.
 * A token SHALL represent a fungible or non-fungible unit of exchange.<br/>
 * The specified Treasury Account SHALL receive the initial supply of tokens and
 * SHALL determine distribution of all tokens once minted.
 *
 * Generated from protobuf message <code>proto.TokenInfo</code>
 */
class TokenInfo extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A unique identifier for this token.
     *
     * Generated from protobuf field <code>.proto.TokenID tokenId = 1;</code>
     */
    protected $tokenId = null;
    /**
     **
     * A human-readable name for this token.
     * <p>
     * This value MAY NOT be unique.<br/>
     * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string name = 2;</code>
     */
    protected $name = '';
    /**
     **
     * A human-readable symbol for the token.
     * <p>
     * This value SHALL NOT be unique.<br/>
     * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string symbol = 3;</code>
     */
    protected $symbol = '';
    /**
     **
     * A number of decimal places for this token.
     * <p>
     * If decimals are 8 or 11, then the number of whole tokens can be at most
     * billions or millions, respectively. More decimals allows for a more
     * finely-divided token, but also limits the maximum total supply.
     * <p>
     * Examples
     * <ul>
     *   <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
     *   <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
     *   <li>Bitcoin milli-satoshis (21 million whole tokens with 11
     *       decimals).</li>
     *   <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
     *       92.2 million with 11 decimals.</li>
     * </ul>
     * All token amounts in the network are stored as integer amounts, with
     * each unit representing 10<sup>-decimals</sup> whole tokens.
     * <p>
     * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
     *
     * Generated from protobuf field <code>uint32 decimals = 4;</code>
     */
    protected $decimals = 0;
    /**
     **
     * A _current_ total supply of this token, expressed in the smallest unit
     * of the token.
     * <p>
     * The number of _whole_ tokens this represents is (total_supply /
     * 10<sup>decimals</sup>). The value of total supply, MUST be within the
     * positive range of a twos-compliment signed 64-bit integer.
     * The `total_supply`, therefore MUST be between 1, and
     * 9,223,372,036,854,775,807, inclusive.
     * <p>
     * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
     * operation is executed, and SHALL be increased when a `token_mint`
     * operation is executed.
     *
     * Generated from protobuf field <code>uint64 totalSupply = 5;</code>
     */
    protected $totalSupply = 0;
    /**
     **
     * A treasury account identifier for this token.
     * <p>
     * When the token is created, the initial supply given in the token create
     * transaction SHALL be minted and deposited in the treasury account.<br/>
     * All token mint transactions for this token SHALL deposit the new minted
     * tokens in the treasury account.<br/>
     * All token burn transactions for this token SHALL remove the tokens to be
     * burned from the treasury account.
     *
     * Generated from protobuf field <code>.proto.AccountID treasury = 6;</code>
     */
    protected $treasury = null;
    /**
     **
     * Access control for general modification of this token.
     * <p>
     * This key MUST sign any `token_update` transaction that
     * changes any attribute of the token other than expiration_time.
     * Other attributes of this token MAY be changed by transactions other than
     * `token_update`, and MUST be signed by one of the other purpose-specific
     * keys assigned to the token.<br/>
     * This value can be set during token creation, and SHALL NOT be
     * modified thereafter, unless the update transaction is signed by both
     * the existing `admin_key` and the new `admin_key`.<br/>
     * If the `admin_key` is not set for a token, that token SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 7;</code>
     */
    protected $adminKey = null;
    /**
     **
     * Access control for KYC for this token.
     * <p>
     * Know Your Customer (KYC) status may be granted for an account by a token
     * grant kyc transaction signed by this key.<br/>
     * If this key is not set, then KYC status cannot be granted to an account
     * for this token, and any `TokenGrantKyc` transaction attempting to grant
     * kyc to an account for this token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key kycKey = 8;</code>
     */
    protected $kycKey = null;
    /**
     **
     * Access control to freeze this token.
     * <p>
     * A token may be frozen for an account, preventing any transaction from
     * transferring that token for that specified account, by a token freeze
     * account transaction signed by this key.<br/>
     * If this key is not set, the token cannot be frozen, and any transaction
     * attempting to freeze the token for an account SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key freezeKey = 9;</code>
     */
    protected $freezeKey = null;
    /**
     **
     * Access control of account wipe for this token.
     * <p>
     * A token may be wiped, removing and burning tokens from a specific
     * account, by a token wipe transaction, which MUST be signed by this key.
     * The `treasury_account` cannot be subjected to a token wipe. A token burn
     * transaction, signed by the `supply_key`, serves to burn tokens held by
     * the `treasury_account` instead.<br/>
     * If this key is not set, the token cannot be wiped, and any transaction
     * attempting to wipe the token from an account SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key wipeKey = 10;</code>
     */
    protected $wipeKey = null;
    /**
     **
     * Access control of token mint/burn for this token.
     * <p>
     * A token mint transaction MUST be signed by this key, and any token mint
     * transaction not signed by the current `supply_key` for that token
     * SHALL NOT succeed.<br/>
     * A token burn transaction MUST be signed by this key, and any token burn
     * transaction not signed by the current `supply_key` for that token
     * SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key supplyKey = 11;</code>
     */
    protected $supplyKey = null;
    /**
     **
     * A flag indicating if accounts associated to this token are frozen by
     * default, not frozen, or freeze is not applicable.
     * <p>
     * Accounts frozen by default and newly associated with this token CANNOT
     * transact in the token until unfrozen.<br/>
     * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
     * from an account to the treasury account.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeStatus defaultFreezeStatus = 12;</code>
     */
    protected $defaultFreezeStatus = 0;
    /**
     **
     * A flag indicating if accounts associated with this token are granted
     * KYC by default, revoked by default, or KYC is not applicable.
     *
     * Generated from protobuf field <code>.proto.TokenKycStatus defaultKycStatus = 13;</code>
     */
    protected $defaultKycStatus = 0;
    /**
     **
     * A flag indicating that this token is deleted.
     * <p>
     * A transaction involving a deleted token MUST NOT succeed.
     *
     * Generated from protobuf field <code>bool deleted = 14;</code>
     */
    protected $deleted = false;
    /**
     **
     * An identifier for the account (if any) that the network will attempt
     * to charge for this token's auto-renewal upon expiration.
     * <p>
     * This field is OPTIONAL. If it is not set then renewal fees SHALL be
     * charged to the account identified by `treasury`.
     *
     * Generated from protobuf field <code>.proto.AccountID autoRenewAccount = 15;</code>
     */
    protected $autoRenewAccount = null;
    /**
     **
     * A duration by which the network should automatically extend
     * this token's expiration.
     * <p>
     * If the token has a valid auto-renew account, and is not deleted upon
     * expiration, the network SHALL attempt to automatically renew this
     * token.<br/>
     * The default values for the minimum period and maximum period are 30 days
     * and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 16;</code>
     */
    protected $autoRenewPeriod = null;
    /**
     **
     * An expiration time for this token, in seconds since the epoch.
     * <p>
     * For this purpose, `epoch` SHALL be the
     * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expiry = 17;</code>
     */
    protected $expiry = null;
    /**
     **
     * A short description of this token.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 18;</code>
     */
    protected $memo = '';
    /**
     **
     * A type for this token.
     * <p>
     * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
     * If this value was omitted during token creation, `FUNGIBLE_COMMON`
     * SHALL be used.<br/>
     * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
     * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
     * non-fungible/unique token.
     *
     * Generated from protobuf field <code>.proto.TokenType tokenType = 19;</code>
     */
    protected $tokenType = 0;
    /**
     **
     * A supply type for this token.
     * <p>
     * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
     * If this value was omitted during token creation, the value `INFINITE`
     * SHALL be used.
     *
     * Generated from protobuf field <code>.proto.TokenSupplyType supplyType = 20;</code>
     */
    protected $supplyType = 0;
    /**
     **
     * A maximum supply of this token.<br/>
     * This is the maximum number of tokens of this type that may be issued.
     * <p>
     * This limit SHALL apply regardless of `token_type`.<br/>
     * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
     * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
     *
     * Generated from protobuf field <code>int64 maxSupply = 21;</code>
     */
    protected $maxSupply = 0;
    /**
     **
     * Access control of the `custom_fees` field for this token.
     * <p>
     * The token custom fee schedule may be changed, modifying the fees charged
     * for transferring that token, by a token update transaction, which MUST
     * be signed by this key.<br/>
     * If this key is not set, the token custom fee schedule cannot be changed,
     * and any transaction attempting to change the custom fee schedule for
     * this token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key fee_schedule_key = 22;</code>
     */
    protected $fee_schedule_key = null;
    /**
     **
     * A custom fee schedule for this token.
     *
     * Generated from protobuf field <code>repeated .proto.CustomFee custom_fees = 23;</code>
     */
    private $custom_fees;
    /**
     **
     * Access control of pause/unpause for this token.
     * <p>
     * A token may be paused, preventing any transaction from transferring that
     * token, by a token update transaction signed by this key.<br/>
     * If this key is not set, the token cannot be paused, and any transaction
     * attempting to pause the token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key pause_key = 24;</code>
     */
    protected $pause_key = null;
    /**
     **
     * A flag indicating that this token is paused.<br/>
     * A token may be paused, unpaused, or pause not applicable.
     * <p>
     * A transaction involving a paused token, other than token_unpause,
     * MUST NOT succeed.
     *
     * Generated from protobuf field <code>.proto.TokenPauseStatus pause_status = 25;</code>
     */
    protected $pause_status = 0;
    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 26;</code>
     */
    protected $ledger_id = '';
    /**
     **
     * A Token "Metadata".
     * <p>
     * This value, if set, SHALL NOT exceed 100 bytes.
     *
     * Generated from protobuf field <code>bytes metadata = 27;</code>
     */
    protected $metadata = '';
    /**
     **
     * Access Control of metadata update for this token.
     * <p>
     * A transaction to update the `metadata` field of this token MUST be
     * signed by this key.<br/>
     * If this token is a non-fungible/unique token type, a transaction to
     * update the `metadata` field of any individual serialized unique token
     * of this type MUST be signed by this key.<br/>
     * If this key is not set, the token metadata SHALL NOT be changed after it
     * is created.<br/>
     * If this key is not set, the metadata for any individual serialized token
     * of this type SHALL NOT be changed after it is created.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key metadata_key = 28;</code>
     */
    protected $metadata_key = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\TokenID $tokenId
     *          *
     *           A unique identifier for this token.
     *     @type string $name
     *          *
     *           A human-readable name for this token.
     *           <p>
     *           This value MAY NOT be unique.<br/>
     *           This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *     @type string $symbol
     *          *
     *           A human-readable symbol for the token.
     *           <p>
     *           This value SHALL NOT be unique.<br/>
     *           This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *     @type int $decimals
     *          *
     *           A number of decimal places for this token.
     *           <p>
     *           If decimals are 8 or 11, then the number of whole tokens can be at most
     *           billions or millions, respectively. More decimals allows for a more
     *           finely-divided token, but also limits the maximum total supply.
     *           <p>
     *           Examples
     *           <ul>
     *             <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
     *             <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
     *             <li>Bitcoin milli-satoshis (21 million whole tokens with 11
     *                 decimals).</li>
     *             <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
     *                 92.2 million with 11 decimals.</li>
     *           </ul>
     *           All token amounts in the network are stored as integer amounts, with
     *           each unit representing 10<sup>-decimals</sup> whole tokens.
     *           <p>
     *           For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
     *     @type int|string $totalSupply
     *          *
     *           A _current_ total supply of this token, expressed in the smallest unit
     *           of the token.
     *           <p>
     *           The number of _whole_ tokens this represents is (total_supply /
     *           10<sup>decimals</sup>). The value of total supply, MUST be within the
     *           positive range of a twos-compliment signed 64-bit integer.
     *           The `total_supply`, therefore MUST be between 1, and
     *           9,223,372,036,854,775,807, inclusive.
     *           <p>
     *           This value SHALL be reduced when a `token_burn` or `token_wipe_account`
     *           operation is executed, and SHALL be increased when a `token_mint`
     *           operation is executed.
     *     @type \Proto\AccountID $treasury
     *          *
     *           A treasury account identifier for this token.
     *           <p>
     *           When the token is created, the initial supply given in the token create
     *           transaction SHALL be minted and deposited in the treasury account.<br/>
     *           All token mint transactions for this token SHALL deposit the new minted
     *           tokens in the treasury account.<br/>
     *           All token burn transactions for this token SHALL remove the tokens to be
     *           burned from the treasury account.
     *     @type \Proto\Key $adminKey
     *          *
     *           Access control for general modification of this token.
     *           <p>
     *           This key MUST sign any `token_update` transaction that
     *           changes any attribute of the token other than expiration_time.
     *           Other attributes of this token MAY be changed by transactions other than
     *           `token_update`, and MUST be signed by one of the other purpose-specific
     *           keys assigned to the token.<br/>
     *           This value can be set during token creation, and SHALL NOT be
     *           modified thereafter, unless the update transaction is signed by both
     *           the existing `admin_key` and the new `admin_key`.<br/>
     *           If the `admin_key` is not set for a token, that token SHALL be immutable.
     *     @type \Proto\Key $kycKey
     *          *
     *           Access control for KYC for this token.
     *           <p>
     *           Know Your Customer (KYC) status may be granted for an account by a token
     *           grant kyc transaction signed by this key.<br/>
     *           If this key is not set, then KYC status cannot be granted to an account
     *           for this token, and any `TokenGrantKyc` transaction attempting to grant
     *           kyc to an account for this token SHALL NOT succeed.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     *     @type \Proto\Key $freezeKey
     *          *
     *           Access control to freeze this token.
     *           <p>
     *           A token may be frozen for an account, preventing any transaction from
     *           transferring that token for that specified account, by a token freeze
     *           account transaction signed by this key.<br/>
     *           If this key is not set, the token cannot be frozen, and any transaction
     *           attempting to freeze the token for an account SHALL NOT succeed.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     *     @type \Proto\Key $wipeKey
     *          *
     *           Access control of account wipe for this token.
     *           <p>
     *           A token may be wiped, removing and burning tokens from a specific
     *           account, by a token wipe transaction, which MUST be signed by this key.
     *           The `treasury_account` cannot be subjected to a token wipe. A token burn
     *           transaction, signed by the `supply_key`, serves to burn tokens held by
     *           the `treasury_account` instead.<br/>
     *           If this key is not set, the token cannot be wiped, and any transaction
     *           attempting to wipe the token from an account SHALL NOT succeed.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     *     @type \Proto\Key $supplyKey
     *          *
     *           Access control of token mint/burn for this token.
     *           <p>
     *           A token mint transaction MUST be signed by this key, and any token mint
     *           transaction not signed by the current `supply_key` for that token
     *           SHALL NOT succeed.<br/>
     *           A token burn transaction MUST be signed by this key, and any token burn
     *           transaction not signed by the current `supply_key` for that token
     *           SHALL NOT succeed.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     *     @type int $defaultFreezeStatus
     *          *
     *           A flag indicating if accounts associated to this token are frozen by
     *           default, not frozen, or freeze is not applicable.
     *           <p>
     *           Accounts frozen by default and newly associated with this token CANNOT
     *           transact in the token until unfrozen.<br/>
     *           This SHALL NOT prevent a `tokenReject` transaction to return the tokens
     *           from an account to the treasury account.
     *     @type int $defaultKycStatus
     *          *
     *           A flag indicating if accounts associated with this token are granted
     *           KYC by default, revoked by default, or KYC is not applicable.
     *     @type bool $deleted
     *          *
     *           A flag indicating that this token is deleted.
     *           <p>
     *           A transaction involving a deleted token MUST NOT succeed.
     *     @type \Proto\AccountID $autoRenewAccount
     *          *
     *           An identifier for the account (if any) that the network will attempt
     *           to charge for this token's auto-renewal upon expiration.
     *           <p>
     *           This field is OPTIONAL. If it is not set then renewal fees SHALL be
     *           charged to the account identified by `treasury`.
     *     @type \Proto\Duration $autoRenewPeriod
     *          *
     *           A duration by which the network should automatically extend
     *           this token's expiration.
     *           <p>
     *           If the token has a valid auto-renew account, and is not deleted upon
     *           expiration, the network SHALL attempt to automatically renew this
     *           token.<br/>
     *           The default values for the minimum period and maximum period are 30 days
     *           and 90 days, respectively.
     *     @type \Proto\Timestamp $expiry
     *          *
     *           An expiration time for this token, in seconds since the epoch.
     *           <p>
     *           For this purpose, `epoch` SHALL be the
     *           UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
     *     @type string $memo
     *          *
     *           A short description of this token.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type int $tokenType
     *          *
     *           A type for this token.
     *           <p>
     *           A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
     *           If this value was omitted during token creation, `FUNGIBLE_COMMON`
     *           SHALL be used.<br/>
     *           The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
     *           The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
     *           non-fungible/unique token.
     *     @type int $supplyType
     *          *
     *           A supply type for this token.
     *           <p>
     *           A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
     *           If this value was omitted during token creation, the value `INFINITE`
     *           SHALL be used.
     *     @type int|string $maxSupply
     *          *
     *           A maximum supply of this token.<br/>
     *           This is the maximum number of tokens of this type that may be issued.
     *           <p>
     *           This limit SHALL apply regardless of `token_type`.<br/>
     *           If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
     *           If `supply_type` is `FINITE`, then this value MUST be greater than 0.
     *     @type \Proto\Key $fee_schedule_key
     *          *
     *           Access control of the `custom_fees` field for this token.
     *           <p>
     *           The token custom fee schedule may be changed, modifying the fees charged
     *           for transferring that token, by a token update transaction, which MUST
     *           be signed by this key.<br/>
     *           If this key is not set, the token custom fee schedule cannot be changed,
     *           and any transaction attempting to change the custom fee schedule for
     *           this token SHALL NOT succeed.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     *     @type \Proto\CustomFee[] $custom_fees
     *          *
     *           A custom fee schedule for this token.
     *     @type \Proto\Key $pause_key
     *          *
     *           Access control of pause/unpause for this token.
     *           <p>
     *           A token may be paused, preventing any transaction from transferring that
     *           token, by a token update transaction signed by this key.<br/>
     *           If this key is not set, the token cannot be paused, and any transaction
     *           attempting to pause the token SHALL NOT succeed.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     *     @type int $pause_status
     *          *
     *           A flag indicating that this token is paused.<br/>
     *           A token may be paused, unpaused, or pause not applicable.
     *           <p>
     *           A transaction involving a paused token, other than token_unpause,
     *           MUST NOT succeed.
     *     @type string $ledger_id
     *          *
     *           The ledger ID of the network that generated this response.
     *           <p>
     *           This value SHALL identify the distributed ledger that responded to
     *           this query.
     *     @type string $metadata
     *          *
     *           A Token "Metadata".
     *           <p>
     *           This value, if set, SHALL NOT exceed 100 bytes.
     *     @type \Proto\Key $metadata_key
     *          *
     *           Access Control of metadata update for this token.
     *           <p>
     *           A transaction to update the `metadata` field of this token MUST be
     *           signed by this key.<br/>
     *           If this token is a non-fungible/unique token type, a transaction to
     *           update the `metadata` field of any individual serialized unique token
     *           of this type MUST be signed by this key.<br/>
     *           If this key is not set, the token metadata SHALL NOT be changed after it
     *           is created.<br/>
     *           If this key is not set, the metadata for any individual serialized token
     *           of this type SHALL NOT be changed after it is created.<br/>
     *           This key MAY be set when the token is created, and MAY be set or modified
     *           via a token update transaction signed by the `admin_key`.<br/>
     *           If `admin_key` is not set, this value, whether set or unset,
     *           SHALL be immutable.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\TokenGetInfo::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A unique identifier for this token.
     *
     * Generated from protobuf field <code>.proto.TokenID tokenId = 1;</code>
     * @return \Proto\TokenID|null
     */
    public function getTokenId()
    {
        return $this->tokenId;
    }

    public function hasTokenId()
    {
        return isset($this->tokenId);
    }

    public function clearTokenId()
    {
        unset($this->tokenId);
    }

    /**
     **
     * A unique identifier for this token.
     *
     * Generated from protobuf field <code>.proto.TokenID tokenId = 1;</code>
     * @param \Proto\TokenID $var
     * @return $this
     */
    public function setTokenId($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenID::class);
        $this->tokenId = $var;

        return $this;
    }

    /**
     **
     * A human-readable name for this token.
     * <p>
     * This value MAY NOT be unique.<br/>
     * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string name = 2;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     **
     * A human-readable name for this token.
     * <p>
     * This value MAY NOT be unique.<br/>
     * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string name = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     **
     * A human-readable symbol for the token.
     * <p>
     * This value SHALL NOT be unique.<br/>
     * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string symbol = 3;</code>
     * @return string
     */
    public function getSymbol()
    {
        return $this->symbol;
    }

    /**
     **
     * A human-readable symbol for the token.
     * <p>
     * This value SHALL NOT be unique.<br/>
     * This value SHALL NOT exceed 100 bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string symbol = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setSymbol($var)
    {
        GPBUtil::checkString($var, True);
        $this->symbol = $var;

        return $this;
    }

    /**
     **
     * A number of decimal places for this token.
     * <p>
     * If decimals are 8 or 11, then the number of whole tokens can be at most
     * billions or millions, respectively. More decimals allows for a more
     * finely-divided token, but also limits the maximum total supply.
     * <p>
     * Examples
     * <ul>
     *   <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
     *   <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
     *   <li>Bitcoin milli-satoshis (21 million whole tokens with 11
     *       decimals).</li>
     *   <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
     *       92.2 million with 11 decimals.</li>
     * </ul>
     * All token amounts in the network are stored as integer amounts, with
     * each unit representing 10<sup>-decimals</sup> whole tokens.
     * <p>
     * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
     *
     * Generated from protobuf field <code>uint32 decimals = 4;</code>
     * @return int
     */
    public function getDecimals()
    {
        return $this->decimals;
    }

    /**
     **
     * A number of decimal places for this token.
     * <p>
     * If decimals are 8 or 11, then the number of whole tokens can be at most
     * billions or millions, respectively. More decimals allows for a more
     * finely-divided token, but also limits the maximum total supply.
     * <p>
     * Examples
     * <ul>
     *   <li>Bitcoin satoshis (21 million whole tokens with 8 decimals).</li>
     *   <li>Hedera tinybar (50 billion whole tokens with 8 decimals).</li>
     *   <li>Bitcoin milli-satoshis (21 million whole tokens with 11
     *       decimals).</li>
     *   <li>Theoretical limit is roughly 92.2 billion with 8 decimals, or
     *       92.2 million with 11 decimals.</li>
     * </ul>
     * All token amounts in the network are stored as integer amounts, with
     * each unit representing 10<sup>-decimals</sup> whole tokens.
     * <p>
     * For tokens with `token_type` set to `NON_FUNGIBLE_UNIQUE` this MUST be 0.
     *
     * Generated from protobuf field <code>uint32 decimals = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setDecimals($var)
    {
        GPBUtil::checkUint32($var);
        $this->decimals = $var;

        return $this;
    }

    /**
     **
     * A _current_ total supply of this token, expressed in the smallest unit
     * of the token.
     * <p>
     * The number of _whole_ tokens this represents is (total_supply /
     * 10<sup>decimals</sup>). The value of total supply, MUST be within the
     * positive range of a twos-compliment signed 64-bit integer.
     * The `total_supply`, therefore MUST be between 1, and
     * 9,223,372,036,854,775,807, inclusive.
     * <p>
     * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
     * operation is executed, and SHALL be increased when a `token_mint`
     * operation is executed.
     *
     * Generated from protobuf field <code>uint64 totalSupply = 5;</code>
     * @return int|string
     */
    public function getTotalSupply()
    {
        return $this->totalSupply;
    }

    /**
     **
     * A _current_ total supply of this token, expressed in the smallest unit
     * of the token.
     * <p>
     * The number of _whole_ tokens this represents is (total_supply /
     * 10<sup>decimals</sup>). The value of total supply, MUST be within the
     * positive range of a twos-compliment signed 64-bit integer.
     * The `total_supply`, therefore MUST be between 1, and
     * 9,223,372,036,854,775,807, inclusive.
     * <p>
     * This value SHALL be reduced when a `token_burn` or `token_wipe_account`
     * operation is executed, and SHALL be increased when a `token_mint`
     * operation is executed.
     *
     * Generated from protobuf field <code>uint64 totalSupply = 5;</code>
     * @param int|string $var
     * @return $this
     */
    public function setTotalSupply($var)
    {
        GPBUtil::checkUint64($var);
        $this->totalSupply = $var;

        return $this;
    }

    /**
     **
     * A treasury account identifier for this token.
     * <p>
     * When the token is created, the initial supply given in the token create
     * transaction SHALL be minted and deposited in the treasury account.<br/>
     * All token mint transactions for this token SHALL deposit the new minted
     * tokens in the treasury account.<br/>
     * All token burn transactions for this token SHALL remove the tokens to be
     * burned from the treasury account.
     *
     * Generated from protobuf field <code>.proto.AccountID treasury = 6;</code>
     * @return \Proto\AccountID|null
     */
    public function getTreasury()
    {
        return $this->treasury;
    }

    public function hasTreasury()
    {
        return isset($this->treasury);
    }

    public function clearTreasury()
    {
        unset($this->treasury);
    }

    /**
     **
     * A treasury account identifier for this token.
     * <p>
     * When the token is created, the initial supply given in the token create
     * transaction SHALL be minted and deposited in the treasury account.<br/>
     * All token mint transactions for this token SHALL deposit the new minted
     * tokens in the treasury account.<br/>
     * All token burn transactions for this token SHALL remove the tokens to be
     * burned from the treasury account.
     *
     * Generated from protobuf field <code>.proto.AccountID treasury = 6;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setTreasury($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->treasury = $var;

        return $this;
    }

    /**
     **
     * Access control for general modification of this token.
     * <p>
     * This key MUST sign any `token_update` transaction that
     * changes any attribute of the token other than expiration_time.
     * Other attributes of this token MAY be changed by transactions other than
     * `token_update`, and MUST be signed by one of the other purpose-specific
     * keys assigned to the token.<br/>
     * This value can be set during token creation, and SHALL NOT be
     * modified thereafter, unless the update transaction is signed by both
     * the existing `admin_key` and the new `admin_key`.<br/>
     * If the `admin_key` is not set for a token, that token SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 7;</code>
     * @return \Proto\Key|null
     */
    public function getAdminKey()
    {
        return $this->adminKey;
    }

    public function hasAdminKey()
    {
        return isset($this->adminKey);
    }

    public function clearAdminKey()
    {
        unset($this->adminKey);
    }

    /**
     **
     * Access control for general modification of this token.
     * <p>
     * This key MUST sign any `token_update` transaction that
     * changes any attribute of the token other than expiration_time.
     * Other attributes of this token MAY be changed by transactions other than
     * `token_update`, and MUST be signed by one of the other purpose-specific
     * keys assigned to the token.<br/>
     * This value can be set during token creation, and SHALL NOT be
     * modified thereafter, unless the update transaction is signed by both
     * the existing `admin_key` and the new `admin_key`.<br/>
     * If the `admin_key` is not set for a token, that token SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 7;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setAdminKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->adminKey = $var;

        return $this;
    }

    /**
     **
     * Access control for KYC for this token.
     * <p>
     * Know Your Customer (KYC) status may be granted for an account by a token
     * grant kyc transaction signed by this key.<br/>
     * If this key is not set, then KYC status cannot be granted to an account
     * for this token, and any `TokenGrantKyc` transaction attempting to grant
     * kyc to an account for this token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key kycKey = 8;</code>
     * @return \Proto\Key|null
     */
    public function getKycKey()
    {
        return $this->kycKey;
    }

    public function hasKycKey()
    {
        return isset($this->kycKey);
    }

    public function clearKycKey()
    {
        unset($this->kycKey);
    }

    /**
     **
     * Access control for KYC for this token.
     * <p>
     * Know Your Customer (KYC) status may be granted for an account by a token
     * grant kyc transaction signed by this key.<br/>
     * If this key is not set, then KYC status cannot be granted to an account
     * for this token, and any `TokenGrantKyc` transaction attempting to grant
     * kyc to an account for this token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key kycKey = 8;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setKycKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->kycKey = $var;

        return $this;
    }

    /**
     **
     * Access control to freeze this token.
     * <p>
     * A token may be frozen for an account, preventing any transaction from
     * transferring that token for that specified account, by a token freeze
     * account transaction signed by this key.<br/>
     * If this key is not set, the token cannot be frozen, and any transaction
     * attempting to freeze the token for an account SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key freezeKey = 9;</code>
     * @return \Proto\Key|null
     */
    public function getFreezeKey()
    {
        return $this->freezeKey;
    }

    public function hasFreezeKey()
    {
        return isset($this->freezeKey);
    }

    public function clearFreezeKey()
    {
        unset($this->freezeKey);
    }

    /**
     **
     * Access control to freeze this token.
     * <p>
     * A token may be frozen for an account, preventing any transaction from
     * transferring that token for that specified account, by a token freeze
     * account transaction signed by this key.<br/>
     * If this key is not set, the token cannot be frozen, and any transaction
     * attempting to freeze the token for an account SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key freezeKey = 9;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setFreezeKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->freezeKey = $var;

        return $this;
    }

    /**
     **
     * Access control of account wipe for this token.
     * <p>
     * A token may be wiped, removing and burning tokens from a specific
     * account, by a token wipe transaction, which MUST be signed by this key.
     * The `treasury_account` cannot be subjected to a token wipe. A token burn
     * transaction, signed by the `supply_key`, serves to burn tokens held by
     * the `treasury_account` instead.<br/>
     * If this key is not set, the token cannot be wiped, and any transaction
     * attempting to wipe the token from an account SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key wipeKey = 10;</code>
     * @return \Proto\Key|null
     */
    public function getWipeKey()
    {
        return $this->wipeKey;
    }

    public function hasWipeKey()
    {
        return isset($this->wipeKey);
    }

    public function clearWipeKey()
    {
        unset($this->wipeKey);
    }

    /**
     **
     * Access control of account wipe for this token.
     * <p>
     * A token may be wiped, removing and burning tokens from a specific
     * account, by a token wipe transaction, which MUST be signed by this key.
     * The `treasury_account` cannot be subjected to a token wipe. A token burn
     * transaction, signed by the `supply_key`, serves to burn tokens held by
     * the `treasury_account` instead.<br/>
     * If this key is not set, the token cannot be wiped, and any transaction
     * attempting to wipe the token from an account SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key wipeKey = 10;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setWipeKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->wipeKey = $var;

        return $this;
    }

    /**
     **
     * Access control of token mint/burn for this token.
     * <p>
     * A token mint transaction MUST be signed by this key, and any token mint
     * transaction not signed by the current `supply_key` for that token
     * SHALL NOT succeed.<br/>
     * A token burn transaction MUST be signed by this key, and any token burn
     * transaction not signed by the current `supply_key` for that token
     * SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key supplyKey = 11;</code>
     * @return \Proto\Key|null
     */
    public function getSupplyKey()
    {
        return $this->supplyKey;
    }

    public function hasSupplyKey()
    {
        return isset($this->supplyKey);
    }

    public function clearSupplyKey()
    {
        unset($this->supplyKey);
    }

    /**
     **
     * Access control of token mint/burn for this token.
     * <p>
     * A token mint transaction MUST be signed by this key, and any token mint
     * transaction not signed by the current `supply_key` for that token
     * SHALL NOT succeed.<br/>
     * A token burn transaction MUST be signed by this key, and any token burn
     * transaction not signed by the current `supply_key` for that token
     * SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key supplyKey = 11;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setSupplyKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->supplyKey = $var;

        return $this;
    }

    /**
     **
     * A flag indicating if accounts associated to this token are frozen by
     * default, not frozen, or freeze is not applicable.
     * <p>
     * Accounts frozen by default and newly associated with this token CANNOT
     * transact in the token until unfrozen.<br/>
     * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
     * from an account to the treasury account.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeStatus defaultFreezeStatus = 12;</code>
     * @return int
     */
    public function getDefaultFreezeStatus()
    {
        return $this->defaultFreezeStatus;
    }

    /**
     **
     * A flag indicating if accounts associated to this token are frozen by
     * default, not frozen, or freeze is not applicable.
     * <p>
     * Accounts frozen by default and newly associated with this token CANNOT
     * transact in the token until unfrozen.<br/>
     * This SHALL NOT prevent a `tokenReject` transaction to return the tokens
     * from an account to the treasury account.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeStatus defaultFreezeStatus = 12;</code>
     * @param int $var
     * @return $this
     */
    public function setDefaultFreezeStatus($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenFreezeStatus::class);
        $this->defaultFreezeStatus = $var;

        return $this;
    }

    /**
     **
     * A flag indicating if accounts associated with this token are granted
     * KYC by default, revoked by default, or KYC is not applicable.
     *
     * Generated from protobuf field <code>.proto.TokenKycStatus defaultKycStatus = 13;</code>
     * @return int
     */
    public function getDefaultKycStatus()
    {
        return $this->defaultKycStatus;
    }

    /**
     **
     * A flag indicating if accounts associated with this token are granted
     * KYC by default, revoked by default, or KYC is not applicable.
     *
     * Generated from protobuf field <code>.proto.TokenKycStatus defaultKycStatus = 13;</code>
     * @param int $var
     * @return $this
     */
    public function setDefaultKycStatus($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenKycStatus::class);
        $this->defaultKycStatus = $var;

        return $this;
    }

    /**
     **
     * A flag indicating that this token is deleted.
     * <p>
     * A transaction involving a deleted token MUST NOT succeed.
     *
     * Generated from protobuf field <code>bool deleted = 14;</code>
     * @return bool
     */
    public function getDeleted()
    {
        return $this->deleted;
    }

    /**
     **
     * A flag indicating that this token is deleted.
     * <p>
     * A transaction involving a deleted token MUST NOT succeed.
     *
     * Generated from protobuf field <code>bool deleted = 14;</code>
     * @param bool $var
     * @return $this
     */
    public function setDeleted($var)
    {
        GPBUtil::checkBool($var);
        $this->deleted = $var;

        return $this;
    }

    /**
     **
     * An identifier for the account (if any) that the network will attempt
     * to charge for this token's auto-renewal upon expiration.
     * <p>
     * This field is OPTIONAL. If it is not set then renewal fees SHALL be
     * charged to the account identified by `treasury`.
     *
     * Generated from protobuf field <code>.proto.AccountID autoRenewAccount = 15;</code>
     * @return \Proto\AccountID|null
     */
    public function getAutoRenewAccount()
    {
        return $this->autoRenewAccount;
    }

    public function hasAutoRenewAccount()
    {
        return isset($this->autoRenewAccount);
    }

    public function clearAutoRenewAccount()
    {
        unset($this->autoRenewAccount);
    }

    /**
     **
     * An identifier for the account (if any) that the network will attempt
     * to charge for this token's auto-renewal upon expiration.
     * <p>
     * This field is OPTIONAL. If it is not set then renewal fees SHALL be
     * charged to the account identified by `treasury`.
     *
     * Generated from protobuf field <code>.proto.AccountID autoRenewAccount = 15;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAutoRenewAccount($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->autoRenewAccount = $var;

        return $this;
    }

    /**
     **
     * A duration by which the network should automatically extend
     * this token's expiration.
     * <p>
     * If the token has a valid auto-renew account, and is not deleted upon
     * expiration, the network SHALL attempt to automatically renew this
     * token.<br/>
     * The default values for the minimum period and maximum period are 30 days
     * and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 16;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->autoRenewPeriod;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->autoRenewPeriod);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->autoRenewPeriod);
    }

    /**
     **
     * A duration by which the network should automatically extend
     * this token's expiration.
     * <p>
     * If the token has a valid auto-renew account, and is not deleted upon
     * expiration, the network SHALL attempt to automatically renew this
     * token.<br/>
     * The default values for the minimum period and maximum period are 30 days
     * and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 16;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->autoRenewPeriod = $var;

        return $this;
    }

    /**
     **
     * An expiration time for this token, in seconds since the epoch.
     * <p>
     * For this purpose, `epoch` SHALL be the
     * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expiry = 17;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExpiry()
    {
        return $this->expiry;
    }

    public function hasExpiry()
    {
        return isset($this->expiry);
    }

    public function clearExpiry()
    {
        unset($this->expiry);
    }

    /**
     **
     * An expiration time for this token, in seconds since the epoch.
     * <p>
     * For this purpose, `epoch` SHALL be the
     * UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expiry = 17;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExpiry($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->expiry = $var;

        return $this;
    }

    /**
     **
     * A short description of this token.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 18;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description of this token.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 18;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * A type for this token.
     * <p>
     * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
     * If this value was omitted during token creation, `FUNGIBLE_COMMON`
     * SHALL be used.<br/>
     * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
     * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
     * non-fungible/unique token.
     *
     * Generated from protobuf field <code>.proto.TokenType tokenType = 19;</code>
     * @return int
     */
    public function getTokenType()
    {
        return $this->tokenType;
    }

    /**
     **
     * A type for this token.
     * <p>
     * A token SHALL be either `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE`.<br/>
     * If this value was omitted during token creation, `FUNGIBLE_COMMON`
     * SHALL be used.<br/>
     * The value `FUNGIBLE_COMMON` SHALL represent a fungible/common token.
     * The value `NON_FUNGIBLE_UNIQUE` SHALL represent a
     * non-fungible/unique token.
     *
     * Generated from protobuf field <code>.proto.TokenType tokenType = 19;</code>
     * @param int $var
     * @return $this
     */
    public function setTokenType($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenType::class);
        $this->tokenType = $var;

        return $this;
    }

    /**
     **
     * A supply type for this token.
     * <p>
     * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
     * If this value was omitted during token creation, the value `INFINITE`
     * SHALL be used.
     *
     * Generated from protobuf field <code>.proto.TokenSupplyType supplyType = 20;</code>
     * @return int
     */
    public function getSupplyType()
    {
        return $this->supplyType;
    }

    /**
     **
     * A supply type for this token.
     * <p>
     * A token SHALL have either `INFINITE` or `FINITE` supply type.<br/>
     * If this value was omitted during token creation, the value `INFINITE`
     * SHALL be used.
     *
     * Generated from protobuf field <code>.proto.TokenSupplyType supplyType = 20;</code>
     * @param int $var
     * @return $this
     */
    public function setSupplyType($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenSupplyType::class);
        $this->supplyType = $var;

        return $this;
    }

    /**
     **
     * A maximum supply of this token.<br/>
     * This is the maximum number of tokens of this type that may be issued.
     * <p>
     * This limit SHALL apply regardless of `token_type`.<br/>
     * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
     * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
     *
     * Generated from protobuf field <code>int64 maxSupply = 21;</code>
     * @return int|string
     */
    public function getMaxSupply()
    {
        return $this->maxSupply;
    }

    /**
     **
     * A maximum supply of this token.<br/>
     * This is the maximum number of tokens of this type that may be issued.
     * <p>
     * This limit SHALL apply regardless of `token_type`.<br/>
     * If `supply_type` is `INFINITE` then this value MUST be 0.<br/>
     * If `supply_type` is `FINITE`, then this value MUST be greater than 0.
     *
     * Generated from protobuf field <code>int64 maxSupply = 21;</code>
     * @param int|string $var
     * @return $this
     */
    public function setMaxSupply($var)
    {
        GPBUtil::checkInt64($var);
        $this->maxSupply = $var;

        return $this;
    }

    /**
     **
     * Access control of the `custom_fees` field for this token.
     * <p>
     * The token custom fee schedule may be changed, modifying the fees charged
     * for transferring that token, by a token update transaction, which MUST
     * be signed by this key.<br/>
     * If this key is not set, the token custom fee schedule cannot be changed,
     * and any transaction attempting to change the custom fee schedule for
     * this token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key fee_schedule_key = 22;</code>
     * @return \Proto\Key|null
     */
    public function getFeeScheduleKey()
    {
        return $this->fee_schedule_key;
    }

    public function hasFeeScheduleKey()
    {
        return isset($this->fee_schedule_key);
    }

    public function clearFeeScheduleKey()
    {
        unset($this->fee_schedule_key);
    }

    /**
     **
     * Access control of the `custom_fees` field for this token.
     * <p>
     * The token custom fee schedule may be changed, modifying the fees charged
     * for transferring that token, by a token update transaction, which MUST
     * be signed by this key.<br/>
     * If this key is not set, the token custom fee schedule cannot be changed,
     * and any transaction attempting to change the custom fee schedule for
     * this token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key fee_schedule_key = 22;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setFeeScheduleKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->fee_schedule_key = $var;

        return $this;
    }

    /**
     **
     * A custom fee schedule for this token.
     *
     * Generated from protobuf field <code>repeated .proto.CustomFee custom_fees = 23;</code>
     * @return RepeatedField<\Proto\CustomFee>
     */
    public function getCustomFees()
    {
        return $this->custom_fees;
    }

    /**
     **
     * A custom fee schedule for this token.
     *
     * Generated from protobuf field <code>repeated .proto.CustomFee custom_fees = 23;</code>
     * @param \Proto\CustomFee[] $var
     * @return $this
     */
    public function setCustomFees($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\CustomFee::class);
        $this->custom_fees = $arr;

        return $this;
    }

    /**
     **
     * Access control of pause/unpause for this token.
     * <p>
     * A token may be paused, preventing any transaction from transferring that
     * token, by a token update transaction signed by this key.<br/>
     * If this key is not set, the token cannot be paused, and any transaction
     * attempting to pause the token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key pause_key = 24;</code>
     * @return \Proto\Key|null
     */
    public function getPauseKey()
    {
        return $this->pause_key;
    }

    public function hasPauseKey()
    {
        return isset($this->pause_key);
    }

    public function clearPauseKey()
    {
        unset($this->pause_key);
    }

    /**
     **
     * Access control of pause/unpause for this token.
     * <p>
     * A token may be paused, preventing any transaction from transferring that
     * token, by a token update transaction signed by this key.<br/>
     * If this key is not set, the token cannot be paused, and any transaction
     * attempting to pause the token SHALL NOT succeed.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key pause_key = 24;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setPauseKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->pause_key = $var;

        return $this;
    }

    /**
     **
     * A flag indicating that this token is paused.<br/>
     * A token may be paused, unpaused, or pause not applicable.
     * <p>
     * A transaction involving a paused token, other than token_unpause,
     * MUST NOT succeed.
     *
     * Generated from protobuf field <code>.proto.TokenPauseStatus pause_status = 25;</code>
     * @return int
     */
    public function getPauseStatus()
    {
        return $this->pause_status;
    }

    /**
     **
     * A flag indicating that this token is paused.<br/>
     * A token may be paused, unpaused, or pause not applicable.
     * <p>
     * A transaction involving a paused token, other than token_unpause,
     * MUST NOT succeed.
     *
     * Generated from protobuf field <code>.proto.TokenPauseStatus pause_status = 25;</code>
     * @param int $var
     * @return $this
     */
    public function setPauseStatus($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenPauseStatus::class);
        $this->pause_status = $var;

        return $this;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 26;</code>
     * @return string
     */
    public function getLedgerId()
    {
        return $this->ledger_id;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 26;</code>
     * @param string $var
     * @return $this
     */
    public function setLedgerId($var)
    {
        GPBUtil::checkString($var, False);
        $this->ledger_id = $var;

        return $this;
    }

    /**
     **
     * A Token "Metadata".
     * <p>
     * This value, if set, SHALL NOT exceed 100 bytes.
     *
     * Generated from protobuf field <code>bytes metadata = 27;</code>
     * @return string
     */
    public function getMetadata()
    {
        return $this->metadata;
    }

    /**
     **
     * A Token "Metadata".
     * <p>
     * This value, if set, SHALL NOT exceed 100 bytes.
     *
     * Generated from protobuf field <code>bytes metadata = 27;</code>
     * @param string $var
     * @return $this
     */
    public function setMetadata($var)
    {
        GPBUtil::checkString($var, False);
        $this->metadata = $var;

        return $this;
    }

    /**
     **
     * Access Control of metadata update for this token.
     * <p>
     * A transaction to update the `metadata` field of this token MUST be
     * signed by this key.<br/>
     * If this token is a non-fungible/unique token type, a transaction to
     * update the `metadata` field of any individual serialized unique token
     * of this type MUST be signed by this key.<br/>
     * If this key is not set, the token metadata SHALL NOT be changed after it
     * is created.<br/>
     * If this key is not set, the metadata for any individual serialized token
     * of this type SHALL NOT be changed after it is created.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key metadata_key = 28;</code>
     * @return \Proto\Key|null
     */
    public function getMetadataKey()
    {
        return $this->metadata_key;
    }

    public function hasMetadataKey()
    {
        return isset($this->metadata_key);
    }

    public function clearMetadataKey()
    {
        unset($this->metadata_key);
    }

    /**
     **
     * Access Control of metadata update for this token.
     * <p>
     * A transaction to update the `metadata` field of this token MUST be
     * signed by this key.<br/>
     * If this token is a non-fungible/unique token type, a transaction to
     * update the `metadata` field of any individual serialized unique token
     * of this type MUST be signed by this key.<br/>
     * If this key is not set, the token metadata SHALL NOT be changed after it
     * is created.<br/>
     * If this key is not set, the metadata for any individual serialized token
     * of this type SHALL NOT be changed after it is created.<br/>
     * This key MAY be set when the token is created, and MAY be set or modified
     * via a token update transaction signed by the `admin_key`.<br/>
     * If `admin_key` is not set, this value, whether set or unset,
     * SHALL be immutable.
     *
     * Generated from protobuf field <code>.proto.Key metadata_key = 28;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setMetadataKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->metadata_key = $var;

        return $this;
    }

}

