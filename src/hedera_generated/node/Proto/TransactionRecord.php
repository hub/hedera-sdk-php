<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: transaction_record.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Response when the client sends the node TransactionGetRecordResponse
 *
 * Generated from protobuf message <code>proto.TransactionRecord</code>
 */
class TransactionRecord extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A transaction receipt.
     * <p>
     * This SHALL report consensus status (reach consensus, failed,
     * unknown) and the ID of any new entity (i.e. account, file,
     * contract, schedule, etc...) created.
     *
     * Generated from protobuf field <code>.proto.TransactionReceipt receipt = 1;</code>
     */
    protected $receipt = null;
    /**
     **
     * A transaction hash value.
     * <p>
     * This SHALL be the hash of the Transaction that executed and
     * SHALL NOT be the hash of any Transaction that failed for
     * having a duplicate TransactionID.
     *
     * Generated from protobuf field <code>bytes transactionHash = 2;</code>
     */
    protected $transactionHash = '';
    /**
     **
     * A consensus timestamp.
     * <p>
     * This SHALL be null if the transaction did not reach consensus yet.
     *
     * Generated from protobuf field <code>.proto.Timestamp consensusTimestamp = 3;</code>
     */
    protected $consensusTimestamp = null;
    /**
     **
     * A transaction identifier to the transaction associated to this record.
     *
     * Generated from protobuf field <code>.proto.TransactionID transactionID = 4;</code>
     */
    protected $transactionID = null;
    /**
     **
     * A transaction memo.<br/>
     * This is the memo that was submitted as part of the transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 5;</code>
     */
    protected $memo = '';
    /**
     **
     * A transaction fee charged.
     * <p>
     * This SHALL be the actual transaction fee charged.<br/>
     * This MAY NOT match the original `transactionFee` value
     * from the `TransactionBody`.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 6;</code>
     */
    protected $transactionFee = 0;
    /**
     **
     * A transfer list for this transaction.<br/>
     * This is a list of all HBAR transfers completed for this transaction.
     * <p>
     * This MAY include fees, transfers performed by the transaction,
     * transfers initiated by a smart contract it calls, or the creation
     * of threshold records that it triggers.
     *
     * Generated from protobuf field <code>.proto.TransferList transferList = 10;</code>
     */
    protected $transferList = null;
    /**
     **
     * A token transfer list for this transaction.<br/>
     * This is a list of all non-HBAR token transfers
     * completed for this transaction.<br/>
     *
     * Generated from protobuf field <code>repeated .proto.TokenTransferList tokenTransferLists = 11;</code>
     */
    private $tokenTransferLists;
    /**
     **
     * A schedule reference.<br/>
     * The reference to a schedule ID for the schedule that initiated this
     * transaction, if this this transaction record represents a scheduled
     * transaction.
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleRef = 12;</code>
     */
    protected $scheduleRef = null;
    /**
     **
     * A list of all custom fees that were assessed during a CryptoTransfer.
     * <p>
     * These SHALL be paid if the transaction status resolved to SUCCESS.
     *
     * Generated from protobuf field <code>repeated .proto.AssessedCustomFee assessed_custom_fees = 13;</code>
     */
    private $assessed_custom_fees;
    /**
     **
     * A list of all token associations implicitly or automatically
     * created while handling this transaction.
     *
     * Generated from protobuf field <code>repeated .proto.TokenAssociation automatic_token_associations = 14;</code>
     */
    private $automatic_token_associations;
    /**
     **
     * A consensus timestamp for a child record.
     * <p>
     * This SHALL be the consensus timestamp of a user transaction that
     * spawned an internal child transaction.
     *
     * Generated from protobuf field <code>.proto.Timestamp parent_consensus_timestamp = 15;</code>
     */
    protected $parent_consensus_timestamp = null;
    /**
     **
     * A new account alias.<br/>
     * <p>
     * This is the new alias assigned to an account created as part
     * of a CryptoCreate transaction triggered by a user transaction
     * with a (previously unused) alias.
     *
     * Generated from protobuf field <code>bytes alias = 16;</code>
     */
    protected $alias = '';
    /**
     **
     * A keccak256 hash of the ethereumData.
     * <p>
     * This field SHALL only be populated for EthereumTransaction.
     *
     * Generated from protobuf field <code>bytes ethereum_hash = 17;</code>
     */
    protected $ethereum_hash = '';
    /**
     **
     * A list of staking rewards paid.
     * <p>
     * This SHALL be a list accounts with the corresponding staking
     * rewards paid as a result of this transaction.
     *
     * Generated from protobuf field <code>repeated .proto.AccountAmount paid_staking_rewards = 18;</code>
     */
    private $paid_staking_rewards;
    /**
     **
     * A new default EVM address for an account created by
     * this transaction.
     * <p>
     * This field SHALL be populated only when the EVM address is not
     * specified in the related transaction body.
     *
     * Generated from protobuf field <code>bytes evm_address = 21;</code>
     */
    protected $evm_address = '';
    /**
     **
     * A list of pending token airdrops.
     * <p>
     * Each pending airdrop SHALL represent a single requested transfer
     * from a sending account to a recipient account.<br/>
     * These pending transfers are issued unilaterally by the sending
     * account, and MUST be claimed by the recipient account before
     * the transfer SHALL complete.<br/>
     * A sender MAY cancel a pending airdrop before it is claimed.<br/>
     * An airdrop transaction SHALL emit a pending airdrop when the
     * recipient has no available automatic association slots available
     * or when the recipient has set `receiver_sig_required`.
     *
     * Generated from protobuf field <code>repeated .proto.PendingAirdropRecord new_pending_airdrops = 22;</code>
     */
    private $new_pending_airdrops;
    protected $body;
    protected $entropy;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\TransactionReceipt $receipt
     *          *
     *           A transaction receipt.
     *           <p>
     *           This SHALL report consensus status (reach consensus, failed,
     *           unknown) and the ID of any new entity (i.e. account, file,
     *           contract, schedule, etc...) created.
     *     @type string $transactionHash
     *          *
     *           A transaction hash value.
     *           <p>
     *           This SHALL be the hash of the Transaction that executed and
     *           SHALL NOT be the hash of any Transaction that failed for
     *           having a duplicate TransactionID.
     *     @type \Proto\Timestamp $consensusTimestamp
     *          *
     *           A consensus timestamp.
     *           <p>
     *           This SHALL be null if the transaction did not reach consensus yet.
     *     @type \Proto\TransactionID $transactionID
     *          *
     *           A transaction identifier to the transaction associated to this record.
     *     @type string $memo
     *          *
     *           A transaction memo.<br/>
     *           This is the memo that was submitted as part of the transaction.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type int|string $transactionFee
     *          *
     *           A transaction fee charged.
     *           <p>
     *           This SHALL be the actual transaction fee charged.<br/>
     *           This MAY NOT match the original `transactionFee` value
     *           from the `TransactionBody`.
     *     @type \Proto\ContractFunctionResult $contractCallResult
     *          *
     *           A contract call result.<br/>
     *           A record of the value returned by the smart contract function (if
     *           it completed and didn't fail) from a `ContractCallTransaction`.
     *     @type \Proto\ContractFunctionResult $contractCreateResult
     *          *
     *           A contract creation result.<br/>
     *           A record of the value returned by the smart contract constructor (if
     *           it completed and didn't fail) from a `ContractCreateTransaction`.
     *     @type \Proto\TransferList $transferList
     *          *
     *           A transfer list for this transaction.<br/>
     *           This is a list of all HBAR transfers completed for this transaction.
     *           <p>
     *           This MAY include fees, transfers performed by the transaction,
     *           transfers initiated by a smart contract it calls, or the creation
     *           of threshold records that it triggers.
     *     @type \Proto\TokenTransferList[] $tokenTransferLists
     *          *
     *           A token transfer list for this transaction.<br/>
     *           This is a list of all non-HBAR token transfers
     *           completed for this transaction.<br/>
     *     @type \Proto\ScheduleID $scheduleRef
     *          *
     *           A schedule reference.<br/>
     *           The reference to a schedule ID for the schedule that initiated this
     *           transaction, if this this transaction record represents a scheduled
     *           transaction.
     *     @type \Proto\AssessedCustomFee[] $assessed_custom_fees
     *          *
     *           A list of all custom fees that were assessed during a CryptoTransfer.
     *           <p>
     *           These SHALL be paid if the transaction status resolved to SUCCESS.
     *     @type \Proto\TokenAssociation[] $automatic_token_associations
     *          *
     *           A list of all token associations implicitly or automatically
     *           created while handling this transaction.
     *     @type \Proto\Timestamp $parent_consensus_timestamp
     *          *
     *           A consensus timestamp for a child record.
     *           <p>
     *           This SHALL be the consensus timestamp of a user transaction that
     *           spawned an internal child transaction.
     *     @type string $alias
     *          *
     *           A new account alias.<br/>
     *           <p>
     *           This is the new alias assigned to an account created as part
     *           of a CryptoCreate transaction triggered by a user transaction
     *           with a (previously unused) alias.
     *     @type string $ethereum_hash
     *          *
     *           A keccak256 hash of the ethereumData.
     *           <p>
     *           This field SHALL only be populated for EthereumTransaction.
     *     @type \Proto\AccountAmount[] $paid_staking_rewards
     *          *
     *           A list of staking rewards paid.
     *           <p>
     *           This SHALL be a list accounts with the corresponding staking
     *           rewards paid as a result of this transaction.
     *     @type string $prng_bytes
     *          *
     *           A pseudorandom 384-bit sequence.
     *           <p>
     *           This SHALL be returned in the record of a UtilPrng transaction
     *           with no output range,
     *     @type int $prng_number
     *          *
     *           A pseudorandom 32-bit integer.<br/>
     *           <p>
     *           This SHALL be returned in the record of a PRNG transaction with
     *           an output range specified.
     *     @type string $evm_address
     *          *
     *           A new default EVM address for an account created by
     *           this transaction.
     *           <p>
     *           This field SHALL be populated only when the EVM address is not
     *           specified in the related transaction body.
     *     @type \Proto\PendingAirdropRecord[] $new_pending_airdrops
     *          *
     *           A list of pending token airdrops.
     *           <p>
     *           Each pending airdrop SHALL represent a single requested transfer
     *           from a sending account to a recipient account.<br/>
     *           These pending transfers are issued unilaterally by the sending
     *           account, and MUST be claimed by the recipient account before
     *           the transfer SHALL complete.<br/>
     *           A sender MAY cancel a pending airdrop before it is claimed.<br/>
     *           An airdrop transaction SHALL emit a pending airdrop when the
     *           recipient has no available automatic association slots available
     *           or when the recipient has set `receiver_sig_required`.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\TransactionRecord::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A transaction receipt.
     * <p>
     * This SHALL report consensus status (reach consensus, failed,
     * unknown) and the ID of any new entity (i.e. account, file,
     * contract, schedule, etc...) created.
     *
     * Generated from protobuf field <code>.proto.TransactionReceipt receipt = 1;</code>
     * @return \Proto\TransactionReceipt|null
     */
    public function getReceipt()
    {
        return $this->receipt;
    }

    public function hasReceipt()
    {
        return isset($this->receipt);
    }

    public function clearReceipt()
    {
        unset($this->receipt);
    }

    /**
     **
     * A transaction receipt.
     * <p>
     * This SHALL report consensus status (reach consensus, failed,
     * unknown) and the ID of any new entity (i.e. account, file,
     * contract, schedule, etc...) created.
     *
     * Generated from protobuf field <code>.proto.TransactionReceipt receipt = 1;</code>
     * @param \Proto\TransactionReceipt $var
     * @return $this
     */
    public function setReceipt($var)
    {
        GPBUtil::checkMessage($var, \Proto\TransactionReceipt::class);
        $this->receipt = $var;

        return $this;
    }

    /**
     **
     * A transaction hash value.
     * <p>
     * This SHALL be the hash of the Transaction that executed and
     * SHALL NOT be the hash of any Transaction that failed for
     * having a duplicate TransactionID.
     *
     * Generated from protobuf field <code>bytes transactionHash = 2;</code>
     * @return string
     */
    public function getTransactionHash()
    {
        return $this->transactionHash;
    }

    /**
     **
     * A transaction hash value.
     * <p>
     * This SHALL be the hash of the Transaction that executed and
     * SHALL NOT be the hash of any Transaction that failed for
     * having a duplicate TransactionID.
     *
     * Generated from protobuf field <code>bytes transactionHash = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setTransactionHash($var)
    {
        GPBUtil::checkString($var, False);
        $this->transactionHash = $var;

        return $this;
    }

    /**
     **
     * A consensus timestamp.
     * <p>
     * This SHALL be null if the transaction did not reach consensus yet.
     *
     * Generated from protobuf field <code>.proto.Timestamp consensusTimestamp = 3;</code>
     * @return \Proto\Timestamp|null
     */
    public function getConsensusTimestamp()
    {
        return $this->consensusTimestamp;
    }

    public function hasConsensusTimestamp()
    {
        return isset($this->consensusTimestamp);
    }

    public function clearConsensusTimestamp()
    {
        unset($this->consensusTimestamp);
    }

    /**
     **
     * A consensus timestamp.
     * <p>
     * This SHALL be null if the transaction did not reach consensus yet.
     *
     * Generated from protobuf field <code>.proto.Timestamp consensusTimestamp = 3;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setConsensusTimestamp($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->consensusTimestamp = $var;

        return $this;
    }

    /**
     **
     * A transaction identifier to the transaction associated to this record.
     *
     * Generated from protobuf field <code>.proto.TransactionID transactionID = 4;</code>
     * @return \Proto\TransactionID|null
     */
    public function getTransactionID()
    {
        return $this->transactionID;
    }

    public function hasTransactionID()
    {
        return isset($this->transactionID);
    }

    public function clearTransactionID()
    {
        unset($this->transactionID);
    }

    /**
     **
     * A transaction identifier to the transaction associated to this record.
     *
     * Generated from protobuf field <code>.proto.TransactionID transactionID = 4;</code>
     * @param \Proto\TransactionID $var
     * @return $this
     */
    public function setTransactionID($var)
    {
        GPBUtil::checkMessage($var, \Proto\TransactionID::class);
        $this->transactionID = $var;

        return $this;
    }

    /**
     **
     * A transaction memo.<br/>
     * This is the memo that was submitted as part of the transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 5;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A transaction memo.<br/>
     * This is the memo that was submitted as part of the transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 5;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * A transaction fee charged.
     * <p>
     * This SHALL be the actual transaction fee charged.<br/>
     * This MAY NOT match the original `transactionFee` value
     * from the `TransactionBody`.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 6;</code>
     * @return int|string
     */
    public function getTransactionFee()
    {
        return $this->transactionFee;
    }

    /**
     **
     * A transaction fee charged.
     * <p>
     * This SHALL be the actual transaction fee charged.<br/>
     * This MAY NOT match the original `transactionFee` value
     * from the `TransactionBody`.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 6;</code>
     * @param int|string $var
     * @return $this
     */
    public function setTransactionFee($var)
    {
        GPBUtil::checkUint64($var);
        $this->transactionFee = $var;

        return $this;
    }

    /**
     **
     * A contract call result.<br/>
     * A record of the value returned by the smart contract function (if
     * it completed and didn't fail) from a `ContractCallTransaction`.
     *
     * Generated from protobuf field <code>.proto.ContractFunctionResult contractCallResult = 7;</code>
     * @return \Proto\ContractFunctionResult|null
     */
    public function getContractCallResult()
    {
        return $this->readOneof(7);
    }

    public function hasContractCallResult()
    {
        return $this->hasOneof(7);
    }

    /**
     **
     * A contract call result.<br/>
     * A record of the value returned by the smart contract function (if
     * it completed and didn't fail) from a `ContractCallTransaction`.
     *
     * Generated from protobuf field <code>.proto.ContractFunctionResult contractCallResult = 7;</code>
     * @param \Proto\ContractFunctionResult $var
     * @return $this
     */
    public function setContractCallResult($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractFunctionResult::class);
        $this->writeOneof(7, $var);

        return $this;
    }

    /**
     **
     * A contract creation result.<br/>
     * A record of the value returned by the smart contract constructor (if
     * it completed and didn't fail) from a `ContractCreateTransaction`.
     *
     * Generated from protobuf field <code>.proto.ContractFunctionResult contractCreateResult = 8;</code>
     * @return \Proto\ContractFunctionResult|null
     */
    public function getContractCreateResult()
    {
        return $this->readOneof(8);
    }

    public function hasContractCreateResult()
    {
        return $this->hasOneof(8);
    }

    /**
     **
     * A contract creation result.<br/>
     * A record of the value returned by the smart contract constructor (if
     * it completed and didn't fail) from a `ContractCreateTransaction`.
     *
     * Generated from protobuf field <code>.proto.ContractFunctionResult contractCreateResult = 8;</code>
     * @param \Proto\ContractFunctionResult $var
     * @return $this
     */
    public function setContractCreateResult($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractFunctionResult::class);
        $this->writeOneof(8, $var);

        return $this;
    }

    /**
     **
     * A transfer list for this transaction.<br/>
     * This is a list of all HBAR transfers completed for this transaction.
     * <p>
     * This MAY include fees, transfers performed by the transaction,
     * transfers initiated by a smart contract it calls, or the creation
     * of threshold records that it triggers.
     *
     * Generated from protobuf field <code>.proto.TransferList transferList = 10;</code>
     * @return \Proto\TransferList|null
     */
    public function getTransferList()
    {
        return $this->transferList;
    }

    public function hasTransferList()
    {
        return isset($this->transferList);
    }

    public function clearTransferList()
    {
        unset($this->transferList);
    }

    /**
     **
     * A transfer list for this transaction.<br/>
     * This is a list of all HBAR transfers completed for this transaction.
     * <p>
     * This MAY include fees, transfers performed by the transaction,
     * transfers initiated by a smart contract it calls, or the creation
     * of threshold records that it triggers.
     *
     * Generated from protobuf field <code>.proto.TransferList transferList = 10;</code>
     * @param \Proto\TransferList $var
     * @return $this
     */
    public function setTransferList($var)
    {
        GPBUtil::checkMessage($var, \Proto\TransferList::class);
        $this->transferList = $var;

        return $this;
    }

    /**
     **
     * A token transfer list for this transaction.<br/>
     * This is a list of all non-HBAR token transfers
     * completed for this transaction.<br/>
     *
     * Generated from protobuf field <code>repeated .proto.TokenTransferList tokenTransferLists = 11;</code>
     * @return RepeatedField<\Proto\TokenTransferList>
     */
    public function getTokenTransferLists()
    {
        return $this->tokenTransferLists;
    }

    /**
     **
     * A token transfer list for this transaction.<br/>
     * This is a list of all non-HBAR token transfers
     * completed for this transaction.<br/>
     *
     * Generated from protobuf field <code>repeated .proto.TokenTransferList tokenTransferLists = 11;</code>
     * @param \Proto\TokenTransferList[] $var
     * @return $this
     */
    public function setTokenTransferLists($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\TokenTransferList::class);
        $this->tokenTransferLists = $arr;

        return $this;
    }

    /**
     **
     * A schedule reference.<br/>
     * The reference to a schedule ID for the schedule that initiated this
     * transaction, if this this transaction record represents a scheduled
     * transaction.
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleRef = 12;</code>
     * @return \Proto\ScheduleID|null
     */
    public function getScheduleRef()
    {
        return $this->scheduleRef;
    }

    public function hasScheduleRef()
    {
        return isset($this->scheduleRef);
    }

    public function clearScheduleRef()
    {
        unset($this->scheduleRef);
    }

    /**
     **
     * A schedule reference.<br/>
     * The reference to a schedule ID for the schedule that initiated this
     * transaction, if this this transaction record represents a scheduled
     * transaction.
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleRef = 12;</code>
     * @param \Proto\ScheduleID $var
     * @return $this
     */
    public function setScheduleRef($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleID::class);
        $this->scheduleRef = $var;

        return $this;
    }

    /**
     **
     * A list of all custom fees that were assessed during a CryptoTransfer.
     * <p>
     * These SHALL be paid if the transaction status resolved to SUCCESS.
     *
     * Generated from protobuf field <code>repeated .proto.AssessedCustomFee assessed_custom_fees = 13;</code>
     * @return RepeatedField<\Proto\AssessedCustomFee>
     */
    public function getAssessedCustomFees()
    {
        return $this->assessed_custom_fees;
    }

    /**
     **
     * A list of all custom fees that were assessed during a CryptoTransfer.
     * <p>
     * These SHALL be paid if the transaction status resolved to SUCCESS.
     *
     * Generated from protobuf field <code>repeated .proto.AssessedCustomFee assessed_custom_fees = 13;</code>
     * @param \Proto\AssessedCustomFee[] $var
     * @return $this
     */
    public function setAssessedCustomFees($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\AssessedCustomFee::class);
        $this->assessed_custom_fees = $arr;

        return $this;
    }

    /**
     **
     * A list of all token associations implicitly or automatically
     * created while handling this transaction.
     *
     * Generated from protobuf field <code>repeated .proto.TokenAssociation automatic_token_associations = 14;</code>
     * @return RepeatedField<\Proto\TokenAssociation>
     */
    public function getAutomaticTokenAssociations()
    {
        return $this->automatic_token_associations;
    }

    /**
     **
     * A list of all token associations implicitly or automatically
     * created while handling this transaction.
     *
     * Generated from protobuf field <code>repeated .proto.TokenAssociation automatic_token_associations = 14;</code>
     * @param \Proto\TokenAssociation[] $var
     * @return $this
     */
    public function setAutomaticTokenAssociations($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\TokenAssociation::class);
        $this->automatic_token_associations = $arr;

        return $this;
    }

    /**
     **
     * A consensus timestamp for a child record.
     * <p>
     * This SHALL be the consensus timestamp of a user transaction that
     * spawned an internal child transaction.
     *
     * Generated from protobuf field <code>.proto.Timestamp parent_consensus_timestamp = 15;</code>
     * @return \Proto\Timestamp|null
     */
    public function getParentConsensusTimestamp()
    {
        return $this->parent_consensus_timestamp;
    }

    public function hasParentConsensusTimestamp()
    {
        return isset($this->parent_consensus_timestamp);
    }

    public function clearParentConsensusTimestamp()
    {
        unset($this->parent_consensus_timestamp);
    }

    /**
     **
     * A consensus timestamp for a child record.
     * <p>
     * This SHALL be the consensus timestamp of a user transaction that
     * spawned an internal child transaction.
     *
     * Generated from protobuf field <code>.proto.Timestamp parent_consensus_timestamp = 15;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setParentConsensusTimestamp($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->parent_consensus_timestamp = $var;

        return $this;
    }

    /**
     **
     * A new account alias.<br/>
     * <p>
     * This is the new alias assigned to an account created as part
     * of a CryptoCreate transaction triggered by a user transaction
     * with a (previously unused) alias.
     *
     * Generated from protobuf field <code>bytes alias = 16;</code>
     * @return string
     */
    public function getAlias()
    {
        return $this->alias;
    }

    /**
     **
     * A new account alias.<br/>
     * <p>
     * This is the new alias assigned to an account created as part
     * of a CryptoCreate transaction triggered by a user transaction
     * with a (previously unused) alias.
     *
     * Generated from protobuf field <code>bytes alias = 16;</code>
     * @param string $var
     * @return $this
     */
    public function setAlias($var)
    {
        GPBUtil::checkString($var, False);
        $this->alias = $var;

        return $this;
    }

    /**
     **
     * A keccak256 hash of the ethereumData.
     * <p>
     * This field SHALL only be populated for EthereumTransaction.
     *
     * Generated from protobuf field <code>bytes ethereum_hash = 17;</code>
     * @return string
     */
    public function getEthereumHash()
    {
        return $this->ethereum_hash;
    }

    /**
     **
     * A keccak256 hash of the ethereumData.
     * <p>
     * This field SHALL only be populated for EthereumTransaction.
     *
     * Generated from protobuf field <code>bytes ethereum_hash = 17;</code>
     * @param string $var
     * @return $this
     */
    public function setEthereumHash($var)
    {
        GPBUtil::checkString($var, False);
        $this->ethereum_hash = $var;

        return $this;
    }

    /**
     **
     * A list of staking rewards paid.
     * <p>
     * This SHALL be a list accounts with the corresponding staking
     * rewards paid as a result of this transaction.
     *
     * Generated from protobuf field <code>repeated .proto.AccountAmount paid_staking_rewards = 18;</code>
     * @return RepeatedField<\Proto\AccountAmount>
     */
    public function getPaidStakingRewards()
    {
        return $this->paid_staking_rewards;
    }

    /**
     **
     * A list of staking rewards paid.
     * <p>
     * This SHALL be a list accounts with the corresponding staking
     * rewards paid as a result of this transaction.
     *
     * Generated from protobuf field <code>repeated .proto.AccountAmount paid_staking_rewards = 18;</code>
     * @param \Proto\AccountAmount[] $var
     * @return $this
     */
    public function setPaidStakingRewards($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\AccountAmount::class);
        $this->paid_staking_rewards = $arr;

        return $this;
    }

    /**
     **
     * A pseudorandom 384-bit sequence.
     * <p>
     * This SHALL be returned in the record of a UtilPrng transaction
     * with no output range,
     *
     * Generated from protobuf field <code>bytes prng_bytes = 19;</code>
     * @return string
     */
    public function getPrngBytes()
    {
        return $this->readOneof(19);
    }

    public function hasPrngBytes()
    {
        return $this->hasOneof(19);
    }

    /**
     **
     * A pseudorandom 384-bit sequence.
     * <p>
     * This SHALL be returned in the record of a UtilPrng transaction
     * with no output range,
     *
     * Generated from protobuf field <code>bytes prng_bytes = 19;</code>
     * @param string $var
     * @return $this
     */
    public function setPrngBytes($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(19, $var);

        return $this;
    }

    /**
     **
     * A pseudorandom 32-bit integer.<br/>
     * <p>
     * This SHALL be returned in the record of a PRNG transaction with
     * an output range specified.
     *
     * Generated from protobuf field <code>int32 prng_number = 20;</code>
     * @return int
     */
    public function getPrngNumber()
    {
        return $this->readOneof(20);
    }

    public function hasPrngNumber()
    {
        return $this->hasOneof(20);
    }

    /**
     **
     * A pseudorandom 32-bit integer.<br/>
     * <p>
     * This SHALL be returned in the record of a PRNG transaction with
     * an output range specified.
     *
     * Generated from protobuf field <code>int32 prng_number = 20;</code>
     * @param int $var
     * @return $this
     */
    public function setPrngNumber($var)
    {
        GPBUtil::checkInt32($var);
        $this->writeOneof(20, $var);

        return $this;
    }

    /**
     **
     * A new default EVM address for an account created by
     * this transaction.
     * <p>
     * This field SHALL be populated only when the EVM address is not
     * specified in the related transaction body.
     *
     * Generated from protobuf field <code>bytes evm_address = 21;</code>
     * @return string
     */
    public function getEvmAddress()
    {
        return $this->evm_address;
    }

    /**
     **
     * A new default EVM address for an account created by
     * this transaction.
     * <p>
     * This field SHALL be populated only when the EVM address is not
     * specified in the related transaction body.
     *
     * Generated from protobuf field <code>bytes evm_address = 21;</code>
     * @param string $var
     * @return $this
     */
    public function setEvmAddress($var)
    {
        GPBUtil::checkString($var, False);
        $this->evm_address = $var;

        return $this;
    }

    /**
     **
     * A list of pending token airdrops.
     * <p>
     * Each pending airdrop SHALL represent a single requested transfer
     * from a sending account to a recipient account.<br/>
     * These pending transfers are issued unilaterally by the sending
     * account, and MUST be claimed by the recipient account before
     * the transfer SHALL complete.<br/>
     * A sender MAY cancel a pending airdrop before it is claimed.<br/>
     * An airdrop transaction SHALL emit a pending airdrop when the
     * recipient has no available automatic association slots available
     * or when the recipient has set `receiver_sig_required`.
     *
     * Generated from protobuf field <code>repeated .proto.PendingAirdropRecord new_pending_airdrops = 22;</code>
     * @return RepeatedField<\Proto\PendingAirdropRecord>
     */
    public function getNewPendingAirdrops()
    {
        return $this->new_pending_airdrops;
    }

    /**
     **
     * A list of pending token airdrops.
     * <p>
     * Each pending airdrop SHALL represent a single requested transfer
     * from a sending account to a recipient account.<br/>
     * These pending transfers are issued unilaterally by the sending
     * account, and MUST be claimed by the recipient account before
     * the transfer SHALL complete.<br/>
     * A sender MAY cancel a pending airdrop before it is claimed.<br/>
     * An airdrop transaction SHALL emit a pending airdrop when the
     * recipient has no available automatic association slots available
     * or when the recipient has set `receiver_sig_required`.
     *
     * Generated from protobuf field <code>repeated .proto.PendingAirdropRecord new_pending_airdrops = 22;</code>
     * @param \Proto\PendingAirdropRecord[] $var
     * @return $this
     */
    public function setNewPendingAirdrops($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\PendingAirdropRecord::class);
        $this->new_pending_airdrops = $arr;

        return $this;
    }

    /**
     * @return string
     */
    public function getBody()
    {
        return $this->whichOneof("body");
    }

    /**
     * @return string
     */
    public function getEntropy()
    {
        return $this->whichOneof("entropy");
    }

}

