<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: get_account_details.proto

namespace Proto\GetAccountDetailsResponse;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Information describing a single Account in the Hedera distributed ledger.
 * #### Attributes
 * Each Account may have a unique three-part identifier, a Key, and one or
 * more token balances. Accounts also have an alias, which has multiple
 * forms, and may be set automatically. Several additional items are
 * associated with the Account to enable full functionality.
 * #### Expiration
 * Accounts, as most items in the network, have an expiration time, recorded
 * as a `Timestamp`, and must be "renewed" for a small fee at expiration.
 * This helps to reduce the amount of inactive accounts retained in state.
 * Another account may be designated to pay any renewal fees and
 * automatically renew the account for (by default) 30-90 days at a time as
 * a means to optionally ensure important accounts remain active.
 * ### Staking
 * Accounts may participate in securing the network by "staking" the account
 * balances to a particular network node, and receive a portion of network
 * fees as a reward. An account may optionally decline these rewards but
 * still stake its balances.
 * #### Transfer Restrictions
 * An account may optionally require that inbound transfer transactions be
 * signed by that account as receiver (in addition to any other signatures
 * required, including sender).
 *
 * Generated from protobuf message <code>proto.GetAccountDetailsResponse.AccountDetails</code>
 */
class AccountDetails extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * The unique ID of this account.
     * <p>
     * An account ID, when assigned to this field, SHALL be of
     * the form `shard.realm.number`.<br/>
     * Transactions MAY reference the account by alias, but the account
     * itself MUST always have a purely numeric identifier. This numeric
     * ID is the value used to reference the account in query responses,
     * transaction receipts, transaction records, and the block stream.
     *
     * Generated from protobuf field <code>.proto.AccountID account_id = 1;</code>
     */
    protected $account_id = null;
    /**
     **
     * A Solidity ID.<br/>
     * This identifies the contract instance, and the `Account` associated
     * with that contract instance.
     * <p>
     * This SHALL be populated if this account is a smart contract, and
     * SHALL NOT be populated otherwise.<br/>
     * This SHALL be formatted as a string according to Solidity ID
     * standards.
     *
     * Generated from protobuf field <code>string contract_account_id = 2;</code>
     */
    protected $contract_account_id = '';
    /**
     **
     * A boolean indicating that this account is deleted.
     *
     * Generated from protobuf field <code>bool deleted = 3;</code>
     */
    protected $deleted = false;
    /**
     **
     * Replaced by StakingInfo.<br/>
     * ID of the account to which this account is staking its balances. If
     * this account is not currently staking its balances, then this field,
     * if set, SHALL be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID proxy_account_id = 4 [deprecated = true];</code>
     * @deprecated
     */
    protected $proxy_account_id = null;
    /**
     **
     * The total amount of tinybar proxy staked to this account.
     *
     * Generated from protobuf field <code>int64 proxy_received = 5;</code>
     */
    protected $proxy_received = 0;
    /**
     **
     * The key to be used to sign transactions from this account, if any.
     * <p>
     * This key SHALL NOT be set for hollow accounts until the account
     * is finalized.<br/>
     * This key SHALL be set on all other accounts, except for certain
     * immutable accounts (0.0.800 and 0.0.801) necessary for network
     * function and otherwise secured by the governing council.
     *
     * Generated from protobuf field <code>.proto.Key key = 6;</code>
     */
    protected $key = null;
    /**
     **
     * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     * <p>
     * This value SHALL always be a whole number.
     *
     * Generated from protobuf field <code>uint64 balance = 7;</code>
     */
    protected $balance = 0;
    /**
     **
     * A boolean indicating that the account requires a receiver signature
     * for inbound token transfer transactions.
     * <p>
     * If this value is `true` then a transaction to transfer tokens to this
     * account SHALL NOT succeed unless this account has signed the
     * transfer transaction.
     *
     * Generated from protobuf field <code>bool receiver_sig_required = 8;</code>
     */
    protected $receiver_sig_required = false;
    /**
     **
     * The current expiration time for this account.
     * <p>
     * This account SHALL be due standard renewal fees when the network
     * consensus time exceeds this time.<br/>
     * If rent and expiration are enabled for the network, and automatic
     * renewal is enabled for this account, renewal fees SHALL be charged
     * after this time, and, if charged, the expiration time SHALL be
     * extended for another renewal period.<br/>
     * This account MAY be expired and removed from state at any point
     * after this time if not renewed.<br/>
     * An account holder MAY extend this time by submitting an account
     * update transaction to modify expiration time, subject to the current
     * maximum expiration time for the network.
     *
     * Generated from protobuf field <code>.proto.Timestamp expiration_time = 9;</code>
     */
    protected $expiration_time = null;
    /**
     **
     * A duration to extend this account's expiration.
     * <p>
     * The network SHALL extend the account's expiration by this
     * duration, if funds are available, upon automatic renewal.<br/>
     * This SHALL NOT apply if the account is already deleted
     * upon expiration.<br/>
     * If this is not provided in an allowed range on account creation, the
     * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     * values for the minimum period and maximum period are currently
     * 30 days and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration auto_renew_period = 10;</code>
     */
    protected $auto_renew_period = null;
    /**
     **
     * As of `HIP-367`, which enabled unlimited token associations, the
     * potential scale for this value requires that users consult a mirror
     * node for this information. Only the top `maxRelsPerInfoQuery`
     * (default 1000) relationships will be returned by this query.<br/>
     * A list of tokens to which this account is "associated", enabling the
     * transfer of that token type by this account.
     *
     * Generated from protobuf field <code>repeated .proto.TokenRelationship token_relationships = 11;</code>
     */
    private $token_relationships;
    /**
     **
     * A short description of this account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 12;</code>
     */
    protected $memo = '';
    /**
     **
     * The total number of non-fungible/unique tokens owned by this account.
     *
     * Generated from protobuf field <code>int64 owned_nfts = 13;</code>
     */
    protected $owned_nfts = 0;
    /**
     **
     * The maximum number of tokens that can be auto-associated with the
     * account.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0),
     * then this account MUST manually associate with a token before
     * transacting in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no
     * limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     */
    protected $max_automatic_token_associations = 0;
    /**
     **
     * An account EVM alias.<br/>
     * This is a value used in some contexts to reference an account when
     * the tripartite account identifier is not available.
     * <p>
     * This field, when set to a non-default value, is immutable and
     * SHALL NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 15;</code>
     */
    protected $alias = '';
    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 16;</code>
     */
    protected $ledger_id = '';
    /**
     **
     * A list of crypto (HBAR) allowances approved by this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" account to spend this account's HBAR balance, up
     * to a designated limit.<br/>
     * This field SHALL permit spending only HBAR balance, not other
     * tokens the account may hold.<br/>
     * Allowances for other tokens SHALL be listed in the
     * `token_allowances` field or the
     * `approve_for_all_nft_allowances` field.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedCryptoAllowance granted_crypto_allowances = 17;</code>
     */
    private $granted_crypto_allowances;
    /**
     **
     * A list of non-fungible token (NFT) allowances approved by
     * this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" account to transfer _all_ of this account's
     * non-fungible/unique tokens from a particular collection.<br/>
     * Allowances for a specific serial number MUST be directly
     * associated with that specific non-fungible/unique token, rather
     * than the holding account.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedNftAllowance granted_nft_allowances = 18;</code>
     */
    private $granted_nft_allowances;
    /**
     **
     * A list of fungible token allowances approved by this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" to spend this account's fungible tokens, of the
     * designated type, up to a designated limit.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedTokenAllowance granted_token_allowances = 19;</code>
     */
    private $granted_token_allowances;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\AccountID $account_id
     *          *
     *           The unique ID of this account.
     *           <p>
     *           An account ID, when assigned to this field, SHALL be of
     *           the form `shard.realm.number`.<br/>
     *           Transactions MAY reference the account by alias, but the account
     *           itself MUST always have a purely numeric identifier. This numeric
     *           ID is the value used to reference the account in query responses,
     *           transaction receipts, transaction records, and the block stream.
     *     @type string $contract_account_id
     *          *
     *           A Solidity ID.<br/>
     *           This identifies the contract instance, and the `Account` associated
     *           with that contract instance.
     *           <p>
     *           This SHALL be populated if this account is a smart contract, and
     *           SHALL NOT be populated otherwise.<br/>
     *           This SHALL be formatted as a string according to Solidity ID
     *           standards.
     *     @type bool $deleted
     *          *
     *           A boolean indicating that this account is deleted.
     *     @type \Proto\AccountID $proxy_account_id
     *          *
     *           Replaced by StakingInfo.<br/>
     *           ID of the account to which this account is staking its balances. If
     *           this account is not currently staking its balances, then this field,
     *           if set, SHALL be the sentinel value of `0.0.0`.
     *     @type int|string $proxy_received
     *          *
     *           The total amount of tinybar proxy staked to this account.
     *     @type \Proto\Key $key
     *          *
     *           The key to be used to sign transactions from this account, if any.
     *           <p>
     *           This key SHALL NOT be set for hollow accounts until the account
     *           is finalized.<br/>
     *           This key SHALL be set on all other accounts, except for certain
     *           immutable accounts (0.0.800 and 0.0.801) necessary for network
     *           function and otherwise secured by the governing council.
     *     @type int|string $balance
     *          *
     *           The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     *           <p>
     *           This value SHALL always be a whole number.
     *     @type bool $receiver_sig_required
     *          *
     *           A boolean indicating that the account requires a receiver signature
     *           for inbound token transfer transactions.
     *           <p>
     *           If this value is `true` then a transaction to transfer tokens to this
     *           account SHALL NOT succeed unless this account has signed the
     *           transfer transaction.
     *     @type \Proto\Timestamp $expiration_time
     *          *
     *           The current expiration time for this account.
     *           <p>
     *           This account SHALL be due standard renewal fees when the network
     *           consensus time exceeds this time.<br/>
     *           If rent and expiration are enabled for the network, and automatic
     *           renewal is enabled for this account, renewal fees SHALL be charged
     *           after this time, and, if charged, the expiration time SHALL be
     *           extended for another renewal period.<br/>
     *           This account MAY be expired and removed from state at any point
     *           after this time if not renewed.<br/>
     *           An account holder MAY extend this time by submitting an account
     *           update transaction to modify expiration time, subject to the current
     *           maximum expiration time for the network.
     *     @type \Proto\Duration $auto_renew_period
     *          *
     *           A duration to extend this account's expiration.
     *           <p>
     *           The network SHALL extend the account's expiration by this
     *           duration, if funds are available, upon automatic renewal.<br/>
     *           This SHALL NOT apply if the account is already deleted
     *           upon expiration.<br/>
     *           If this is not provided in an allowed range on account creation, the
     *           transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     *           values for the minimum period and maximum period are currently
     *           30 days and 90 days, respectively.
     *     @type \Proto\TokenRelationship[] $token_relationships
     *          *
     *           As of `HIP-367`, which enabled unlimited token associations, the
     *           potential scale for this value requires that users consult a mirror
     *           node for this information. Only the top `maxRelsPerInfoQuery`
     *           (default 1000) relationships will be returned by this query.<br/>
     *           A list of tokens to which this account is "associated", enabling the
     *           transfer of that token type by this account.
     *     @type string $memo
     *          *
     *           A short description of this account.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type int|string $owned_nfts
     *          *
     *           The total number of non-fungible/unique tokens owned by this account.
     *     @type int $max_automatic_token_associations
     *          *
     *           The maximum number of tokens that can be auto-associated with the
     *           account.
     *           <p>
     *           If this is less than or equal to `used_auto_associations` (or 0),
     *           then this account MUST manually associate with a token before
     *           transacting in that token.<br/>
     *           Following HIP-904 This value may also be `-1` to indicate no
     *           limit.<br/>
     *           This value MUST NOT be less than `-1`.
     *     @type string $alias
     *          *
     *           An account EVM alias.<br/>
     *           This is a value used in some contexts to reference an account when
     *           the tripartite account identifier is not available.
     *           <p>
     *           This field, when set to a non-default value, is immutable and
     *           SHALL NOT be changed.
     *     @type string $ledger_id
     *          *
     *           The ledger ID of the network that generated this response.
     *           <p>
     *           This value SHALL identify the distributed ledger that responded to
     *           this query.
     *     @type \Proto\GrantedCryptoAllowance[] $granted_crypto_allowances
     *          *
     *           A list of crypto (HBAR) allowances approved by this account.
     *           <p>
     *           If this is not empty, each allowance SHALL permit a specified
     *           "spender" account to spend this account's HBAR balance, up
     *           to a designated limit.<br/>
     *           This field SHALL permit spending only HBAR balance, not other
     *           tokens the account may hold.<br/>
     *           Allowances for other tokens SHALL be listed in the
     *           `token_allowances` field or the
     *           `approve_for_all_nft_allowances` field.
     *     @type \Proto\GrantedNftAllowance[] $granted_nft_allowances
     *          *
     *           A list of non-fungible token (NFT) allowances approved by
     *           this account.
     *           <p>
     *           If this is not empty, each allowance SHALL permit a specified
     *           "spender" account to transfer _all_ of this account's
     *           non-fungible/unique tokens from a particular collection.<br/>
     *           Allowances for a specific serial number MUST be directly
     *           associated with that specific non-fungible/unique token, rather
     *           than the holding account.
     *     @type \Proto\GrantedTokenAllowance[] $granted_token_allowances
     *          *
     *           A list of fungible token allowances approved by this account.
     *           <p>
     *           If this is not empty, each allowance SHALL permit a specified
     *           "spender" to spend this account's fungible tokens, of the
     *           designated type, up to a designated limit.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\GetAccountDetails::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * The unique ID of this account.
     * <p>
     * An account ID, when assigned to this field, SHALL be of
     * the form `shard.realm.number`.<br/>
     * Transactions MAY reference the account by alias, but the account
     * itself MUST always have a purely numeric identifier. This numeric
     * ID is the value used to reference the account in query responses,
     * transaction receipts, transaction records, and the block stream.
     *
     * Generated from protobuf field <code>.proto.AccountID account_id = 1;</code>
     * @return \Proto\AccountID|null
     */
    public function getAccountId()
    {
        return $this->account_id;
    }

    public function hasAccountId()
    {
        return isset($this->account_id);
    }

    public function clearAccountId()
    {
        unset($this->account_id);
    }

    /**
     **
     * The unique ID of this account.
     * <p>
     * An account ID, when assigned to this field, SHALL be of
     * the form `shard.realm.number`.<br/>
     * Transactions MAY reference the account by alias, but the account
     * itself MUST always have a purely numeric identifier. This numeric
     * ID is the value used to reference the account in query responses,
     * transaction receipts, transaction records, and the block stream.
     *
     * Generated from protobuf field <code>.proto.AccountID account_id = 1;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAccountId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->account_id = $var;

        return $this;
    }

    /**
     **
     * A Solidity ID.<br/>
     * This identifies the contract instance, and the `Account` associated
     * with that contract instance.
     * <p>
     * This SHALL be populated if this account is a smart contract, and
     * SHALL NOT be populated otherwise.<br/>
     * This SHALL be formatted as a string according to Solidity ID
     * standards.
     *
     * Generated from protobuf field <code>string contract_account_id = 2;</code>
     * @return string
     */
    public function getContractAccountId()
    {
        return $this->contract_account_id;
    }

    /**
     **
     * A Solidity ID.<br/>
     * This identifies the contract instance, and the `Account` associated
     * with that contract instance.
     * <p>
     * This SHALL be populated if this account is a smart contract, and
     * SHALL NOT be populated otherwise.<br/>
     * This SHALL be formatted as a string according to Solidity ID
     * standards.
     *
     * Generated from protobuf field <code>string contract_account_id = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setContractAccountId($var)
    {
        GPBUtil::checkString($var, True);
        $this->contract_account_id = $var;

        return $this;
    }

    /**
     **
     * A boolean indicating that this account is deleted.
     *
     * Generated from protobuf field <code>bool deleted = 3;</code>
     * @return bool
     */
    public function getDeleted()
    {
        return $this->deleted;
    }

    /**
     **
     * A boolean indicating that this account is deleted.
     *
     * Generated from protobuf field <code>bool deleted = 3;</code>
     * @param bool $var
     * @return $this
     */
    public function setDeleted($var)
    {
        GPBUtil::checkBool($var);
        $this->deleted = $var;

        return $this;
    }

    /**
     **
     * Replaced by StakingInfo.<br/>
     * ID of the account to which this account is staking its balances. If
     * this account is not currently staking its balances, then this field,
     * if set, SHALL be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID proxy_account_id = 4 [deprecated = true];</code>
     * @return \Proto\AccountID|null
     * @deprecated
     */
    public function getProxyAccountId()
    {
        if (isset($this->proxy_account_id)) {
            @trigger_error('proxy_account_id is deprecated.', E_USER_DEPRECATED);
        }
        return $this->proxy_account_id;
    }

    public function hasProxyAccountId()
    {
        if (isset($this->proxy_account_id)) {
            @trigger_error('proxy_account_id is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->proxy_account_id);
    }

    public function clearProxyAccountId()
    {
        @trigger_error('proxy_account_id is deprecated.', E_USER_DEPRECATED);
        unset($this->proxy_account_id);
    }

    /**
     **
     * Replaced by StakingInfo.<br/>
     * ID of the account to which this account is staking its balances. If
     * this account is not currently staking its balances, then this field,
     * if set, SHALL be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID proxy_account_id = 4 [deprecated = true];</code>
     * @param \Proto\AccountID $var
     * @return $this
     * @deprecated
     */
    public function setProxyAccountId($var)
    {
        @trigger_error('proxy_account_id is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->proxy_account_id = $var;

        return $this;
    }

    /**
     **
     * The total amount of tinybar proxy staked to this account.
     *
     * Generated from protobuf field <code>int64 proxy_received = 5;</code>
     * @return int|string
     */
    public function getProxyReceived()
    {
        return $this->proxy_received;
    }

    /**
     **
     * The total amount of tinybar proxy staked to this account.
     *
     * Generated from protobuf field <code>int64 proxy_received = 5;</code>
     * @param int|string $var
     * @return $this
     */
    public function setProxyReceived($var)
    {
        GPBUtil::checkInt64($var);
        $this->proxy_received = $var;

        return $this;
    }

    /**
     **
     * The key to be used to sign transactions from this account, if any.
     * <p>
     * This key SHALL NOT be set for hollow accounts until the account
     * is finalized.<br/>
     * This key SHALL be set on all other accounts, except for certain
     * immutable accounts (0.0.800 and 0.0.801) necessary for network
     * function and otherwise secured by the governing council.
     *
     * Generated from protobuf field <code>.proto.Key key = 6;</code>
     * @return \Proto\Key|null
     */
    public function getKey()
    {
        return $this->key;
    }

    public function hasKey()
    {
        return isset($this->key);
    }

    public function clearKey()
    {
        unset($this->key);
    }

    /**
     **
     * The key to be used to sign transactions from this account, if any.
     * <p>
     * This key SHALL NOT be set for hollow accounts until the account
     * is finalized.<br/>
     * This key SHALL be set on all other accounts, except for certain
     * immutable accounts (0.0.800 and 0.0.801) necessary for network
     * function and otherwise secured by the governing council.
     *
     * Generated from protobuf field <code>.proto.Key key = 6;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->key = $var;

        return $this;
    }

    /**
     **
     * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     * <p>
     * This value SHALL always be a whole number.
     *
     * Generated from protobuf field <code>uint64 balance = 7;</code>
     * @return int|string
     */
    public function getBalance()
    {
        return $this->balance;
    }

    /**
     **
     * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     * <p>
     * This value SHALL always be a whole number.
     *
     * Generated from protobuf field <code>uint64 balance = 7;</code>
     * @param int|string $var
     * @return $this
     */
    public function setBalance($var)
    {
        GPBUtil::checkUint64($var);
        $this->balance = $var;

        return $this;
    }

    /**
     **
     * A boolean indicating that the account requires a receiver signature
     * for inbound token transfer transactions.
     * <p>
     * If this value is `true` then a transaction to transfer tokens to this
     * account SHALL NOT succeed unless this account has signed the
     * transfer transaction.
     *
     * Generated from protobuf field <code>bool receiver_sig_required = 8;</code>
     * @return bool
     */
    public function getReceiverSigRequired()
    {
        return $this->receiver_sig_required;
    }

    /**
     **
     * A boolean indicating that the account requires a receiver signature
     * for inbound token transfer transactions.
     * <p>
     * If this value is `true` then a transaction to transfer tokens to this
     * account SHALL NOT succeed unless this account has signed the
     * transfer transaction.
     *
     * Generated from protobuf field <code>bool receiver_sig_required = 8;</code>
     * @param bool $var
     * @return $this
     */
    public function setReceiverSigRequired($var)
    {
        GPBUtil::checkBool($var);
        $this->receiver_sig_required = $var;

        return $this;
    }

    /**
     **
     * The current expiration time for this account.
     * <p>
     * This account SHALL be due standard renewal fees when the network
     * consensus time exceeds this time.<br/>
     * If rent and expiration are enabled for the network, and automatic
     * renewal is enabled for this account, renewal fees SHALL be charged
     * after this time, and, if charged, the expiration time SHALL be
     * extended for another renewal period.<br/>
     * This account MAY be expired and removed from state at any point
     * after this time if not renewed.<br/>
     * An account holder MAY extend this time by submitting an account
     * update transaction to modify expiration time, subject to the current
     * maximum expiration time for the network.
     *
     * Generated from protobuf field <code>.proto.Timestamp expiration_time = 9;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExpirationTime()
    {
        return $this->expiration_time;
    }

    public function hasExpirationTime()
    {
        return isset($this->expiration_time);
    }

    public function clearExpirationTime()
    {
        unset($this->expiration_time);
    }

    /**
     **
     * The current expiration time for this account.
     * <p>
     * This account SHALL be due standard renewal fees when the network
     * consensus time exceeds this time.<br/>
     * If rent and expiration are enabled for the network, and automatic
     * renewal is enabled for this account, renewal fees SHALL be charged
     * after this time, and, if charged, the expiration time SHALL be
     * extended for another renewal period.<br/>
     * This account MAY be expired and removed from state at any point
     * after this time if not renewed.<br/>
     * An account holder MAY extend this time by submitting an account
     * update transaction to modify expiration time, subject to the current
     * maximum expiration time for the network.
     *
     * Generated from protobuf field <code>.proto.Timestamp expiration_time = 9;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExpirationTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->expiration_time = $var;

        return $this;
    }

    /**
     **
     * A duration to extend this account's expiration.
     * <p>
     * The network SHALL extend the account's expiration by this
     * duration, if funds are available, upon automatic renewal.<br/>
     * This SHALL NOT apply if the account is already deleted
     * upon expiration.<br/>
     * If this is not provided in an allowed range on account creation, the
     * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     * values for the minimum period and maximum period are currently
     * 30 days and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration auto_renew_period = 10;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->auto_renew_period;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->auto_renew_period);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->auto_renew_period);
    }

    /**
     **
     * A duration to extend this account's expiration.
     * <p>
     * The network SHALL extend the account's expiration by this
     * duration, if funds are available, upon automatic renewal.<br/>
     * This SHALL NOT apply if the account is already deleted
     * upon expiration.<br/>
     * If this is not provided in an allowed range on account creation, the
     * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     * values for the minimum period and maximum period are currently
     * 30 days and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration auto_renew_period = 10;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->auto_renew_period = $var;

        return $this;
    }

    /**
     **
     * As of `HIP-367`, which enabled unlimited token associations, the
     * potential scale for this value requires that users consult a mirror
     * node for this information. Only the top `maxRelsPerInfoQuery`
     * (default 1000) relationships will be returned by this query.<br/>
     * A list of tokens to which this account is "associated", enabling the
     * transfer of that token type by this account.
     *
     * Generated from protobuf field <code>repeated .proto.TokenRelationship token_relationships = 11;</code>
     * @return RepeatedField<\Proto\TokenRelationship>
     */
    public function getTokenRelationships()
    {
        return $this->token_relationships;
    }

    /**
     **
     * As of `HIP-367`, which enabled unlimited token associations, the
     * potential scale for this value requires that users consult a mirror
     * node for this information. Only the top `maxRelsPerInfoQuery`
     * (default 1000) relationships will be returned by this query.<br/>
     * A list of tokens to which this account is "associated", enabling the
     * transfer of that token type by this account.
     *
     * Generated from protobuf field <code>repeated .proto.TokenRelationship token_relationships = 11;</code>
     * @param \Proto\TokenRelationship[] $var
     * @return $this
     */
    public function setTokenRelationships($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\TokenRelationship::class);
        $this->token_relationships = $arr;

        return $this;
    }

    /**
     **
     * A short description of this account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 12;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description of this account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 12;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * The total number of non-fungible/unique tokens owned by this account.
     *
     * Generated from protobuf field <code>int64 owned_nfts = 13;</code>
     * @return int|string
     */
    public function getOwnedNfts()
    {
        return $this->owned_nfts;
    }

    /**
     **
     * The total number of non-fungible/unique tokens owned by this account.
     *
     * Generated from protobuf field <code>int64 owned_nfts = 13;</code>
     * @param int|string $var
     * @return $this
     */
    public function setOwnedNfts($var)
    {
        GPBUtil::checkInt64($var);
        $this->owned_nfts = $var;

        return $this;
    }

    /**
     **
     * The maximum number of tokens that can be auto-associated with the
     * account.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0),
     * then this account MUST manually associate with a token before
     * transacting in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no
     * limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     * @return int
     */
    public function getMaxAutomaticTokenAssociations()
    {
        return $this->max_automatic_token_associations;
    }

    /**
     **
     * The maximum number of tokens that can be auto-associated with the
     * account.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0),
     * then this account MUST manually associate with a token before
     * transacting in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no
     * limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     * @param int $var
     * @return $this
     */
    public function setMaxAutomaticTokenAssociations($var)
    {
        GPBUtil::checkInt32($var);
        $this->max_automatic_token_associations = $var;

        return $this;
    }

    /**
     **
     * An account EVM alias.<br/>
     * This is a value used in some contexts to reference an account when
     * the tripartite account identifier is not available.
     * <p>
     * This field, when set to a non-default value, is immutable and
     * SHALL NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 15;</code>
     * @return string
     */
    public function getAlias()
    {
        return $this->alias;
    }

    /**
     **
     * An account EVM alias.<br/>
     * This is a value used in some contexts to reference an account when
     * the tripartite account identifier is not available.
     * <p>
     * This field, when set to a non-default value, is immutable and
     * SHALL NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 15;</code>
     * @param string $var
     * @return $this
     */
    public function setAlias($var)
    {
        GPBUtil::checkString($var, False);
        $this->alias = $var;

        return $this;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 16;</code>
     * @return string
     */
    public function getLedgerId()
    {
        return $this->ledger_id;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 16;</code>
     * @param string $var
     * @return $this
     */
    public function setLedgerId($var)
    {
        GPBUtil::checkString($var, False);
        $this->ledger_id = $var;

        return $this;
    }

    /**
     **
     * A list of crypto (HBAR) allowances approved by this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" account to spend this account's HBAR balance, up
     * to a designated limit.<br/>
     * This field SHALL permit spending only HBAR balance, not other
     * tokens the account may hold.<br/>
     * Allowances for other tokens SHALL be listed in the
     * `token_allowances` field or the
     * `approve_for_all_nft_allowances` field.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedCryptoAllowance granted_crypto_allowances = 17;</code>
     * @return RepeatedField<\Proto\GrantedCryptoAllowance>
     */
    public function getGrantedCryptoAllowances()
    {
        return $this->granted_crypto_allowances;
    }

    /**
     **
     * A list of crypto (HBAR) allowances approved by this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" account to spend this account's HBAR balance, up
     * to a designated limit.<br/>
     * This field SHALL permit spending only HBAR balance, not other
     * tokens the account may hold.<br/>
     * Allowances for other tokens SHALL be listed in the
     * `token_allowances` field or the
     * `approve_for_all_nft_allowances` field.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedCryptoAllowance granted_crypto_allowances = 17;</code>
     * @param \Proto\GrantedCryptoAllowance[] $var
     * @return $this
     */
    public function setGrantedCryptoAllowances($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\GrantedCryptoAllowance::class);
        $this->granted_crypto_allowances = $arr;

        return $this;
    }

    /**
     **
     * A list of non-fungible token (NFT) allowances approved by
     * this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" account to transfer _all_ of this account's
     * non-fungible/unique tokens from a particular collection.<br/>
     * Allowances for a specific serial number MUST be directly
     * associated with that specific non-fungible/unique token, rather
     * than the holding account.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedNftAllowance granted_nft_allowances = 18;</code>
     * @return RepeatedField<\Proto\GrantedNftAllowance>
     */
    public function getGrantedNftAllowances()
    {
        return $this->granted_nft_allowances;
    }

    /**
     **
     * A list of non-fungible token (NFT) allowances approved by
     * this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" account to transfer _all_ of this account's
     * non-fungible/unique tokens from a particular collection.<br/>
     * Allowances for a specific serial number MUST be directly
     * associated with that specific non-fungible/unique token, rather
     * than the holding account.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedNftAllowance granted_nft_allowances = 18;</code>
     * @param \Proto\GrantedNftAllowance[] $var
     * @return $this
     */
    public function setGrantedNftAllowances($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\GrantedNftAllowance::class);
        $this->granted_nft_allowances = $arr;

        return $this;
    }

    /**
     **
     * A list of fungible token allowances approved by this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" to spend this account's fungible tokens, of the
     * designated type, up to a designated limit.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedTokenAllowance granted_token_allowances = 19;</code>
     * @return RepeatedField<\Proto\GrantedTokenAllowance>
     */
    public function getGrantedTokenAllowances()
    {
        return $this->granted_token_allowances;
    }

    /**
     **
     * A list of fungible token allowances approved by this account.
     * <p>
     * If this is not empty, each allowance SHALL permit a specified
     * "spender" to spend this account's fungible tokens, of the
     * designated type, up to a designated limit.
     *
     * Generated from protobuf field <code>repeated .proto.GrantedTokenAllowance granted_token_allowances = 19;</code>
     * @param \Proto\GrantedTokenAllowance[] $var
     * @return $this
     */
    public function setGrantedTokenAllowances($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\GrantedTokenAllowance::class);
        $this->granted_token_allowances = $arr;

        return $this;
    }

}

