<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: contract_create.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Create a new smart contract.
 * If this transaction succeeds, the `ContractID` for the new smart contract
 * SHALL be set in the transaction receipt.<br/>
 * The contract is defined by the initial bytecode (or `initcode`). The
 * `initcode` SHALL be stored either in a previously created file, or in the
 * transaction body itself for very small contracts.
 * As part of contract creation, the constructor defined for the new smart
 * contract SHALL run with the parameters provided in the
 * `constructorParameters` field.<br/>
 * The gas to "power" that constructor MUST be provided via the `gas` field,
 * and SHALL be charged to the payer for this transaction.<br/>
 * If the contract _constructor_ stores information, it is charged gas for that
 * storage. There is a separate fee in HBAR to maintain that storage until the
 * expiration, and that fee SHALL be added to this transaction as part of the
 * _transaction fee_, rather than gas.
 * ### Block Stream Effects
 * A `CreateContractOutput` message SHALL be emitted for each transaction.
 *
 * Generated from protobuf message <code>proto.ContractCreateTransactionBody</code>
 */
class ContractCreateTransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * Access control for modification of the smart contract after
     * it is created.
     * <p>
     * If this field is set, that key MUST sign this transaction.<br/>
     * If this field is set, that key MUST sign each future transaction to
     * update or delete the contract.<br/>
     * An updateContract transaction that _only_ extends the topic
     * expirationTime (a "manual renewal" transaction) SHALL NOT require
     * admin key signature.
     * <p>
     * A contract without an admin key SHALL be immutable, except for
     * expiration and renewal.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 3;</code>
     */
    protected $adminKey = null;
    /**
     **
     * A maximum limit to the amount of gas to use for the constructor call.
     * <p>
     * The network SHALL charge the greater of the following, but SHALL NOT
     * charge more than the value of this field.
     * <ol>
     *   <li>The actual gas consumed by the smart contract
     *       constructor call.</li>
     *   <li>`80%` of this value.</li>
     * </ol>
     * The `80%` factor encourages reasonable estimation, while allowing for
     * some overage to ensure successful execution.
     *
     * Generated from protobuf field <code>int64 gas = 4;</code>
     */
    protected $gas = 0;
    /**
     **
     * The amount of HBAR to use as an initial balance for the account
     * representing the new smart contract.
     * <p>
     * This value is presented in tinybar
     * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
     * The HBAR provided here will be withdrawn from the payer account that
     * signed this transaction.
     *
     * Generated from protobuf field <code>int64 initialBalance = 5;</code>
     */
    protected $initialBalance = 0;
    /**
     **
     * Proxy account staking is handled via `staked_id`.
     * <p>
     * Former field to designate a proxy account for HBAR staking.
     * This field MUST NOT be set.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 6 [deprecated = true];</code>
     * @deprecated
     */
    protected $proxyAccountID = null;
    /**
     **
     * The initial lifetime, in seconds, for the smart contract, and the number
     * of seconds for which the smart contract will be automatically renewed
     * upon expiration.
     * <p>
     * This value MUST be set.<br/>
     * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
     * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 8;</code>
     */
    protected $autoRenewPeriod = null;
    /**
     **
     * An array of bytes containing the EVM-encoded parameters to pass to
     * the smart contract constructor defined in the smart contract init
     * code provided.
     *
     * Generated from protobuf field <code>bytes constructorParameters = 9;</code>
     */
    protected $constructorParameters = '';
    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * Shard should be determined by the node the transaction is submitted to.
     * </blockquote></blockquote>
     * <p>
     * The shard in which to create the new smart contract.<br/>
     * This value is currently ignored.
     *
     * Generated from protobuf field <code>.proto.ShardID shardID = 10;</code>
     */
    protected $shardID = null;
    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * Realm should be determined by node and network parameters.
     * </blockquote></blockquote>
     * <p>
     * The shard/realm in which to create the new smart contract.<br/>
     * This value is currently ignored.
     *
     * Generated from protobuf field <code>.proto.RealmID realmID = 11;</code>
     */
    protected $realmID = null;
    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * If a realm is used, it must already exist; we shouldn't be creating it
     * without a separate transaction.</blockquote></blockquote>
     * <p>
     * This was intended to provide an admin key for any new realm created
     * during the creation of the smart contract.<br/>
     * This value is currently ignored. a new realm SHALL NOT be created,
     * regardless of the value of `realmID`.
     *
     * Generated from protobuf field <code>.proto.Key newRealmAdminKey = 12;</code>
     */
    protected $newRealmAdminKey = null;
    /**
     **
     * A short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 13;</code>
     */
    protected $memo = '';
    /**
     **
     * The maximum number of tokens that can be auto-associated with this
     * smart contract.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0), then
     * this contract MUST manually associate with a token before transacting
     * in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     */
    protected $max_automatic_token_associations = 0;
    /**
     **
     * The id of an account, in the same shard and realm as this smart
     * contract, that has signed this transaction, allowing the network to use
     * its balance, when needed, to automatically extend this contract's
     * expiration time.
     * <p>
     * If this field is set, that key MUST sign this transaction.<br/>
     * If this field is set, then the network SHALL deduct the necessary fees
     * from the designated auto renew account, if that account has sufficient
     * balance. If the auto renew account does not have sufficient balance,
     * then the fees for contract renewal SHALL be deducted from the HBAR
     * balance held by the smart contract.<br/>
     * If this field is not set, then all renewal fees SHALL be deducted from
     * the HBAR balance held by this contract.
     *
     * Generated from protobuf field <code>.proto.AccountID auto_renew_account_id = 15;</code>
     */
    protected $auto_renew_account_id = null;
    /**
     **
     * A flag indicating that this smart contract declines to receive any
     * reward for staking its HBAR balance to help secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>bool decline_reward = 19;</code>
     */
    protected $decline_reward = false;
    protected $initcodeSource;
    protected $staked_id;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\FileID $fileID
     *          *
     *           The source for the smart contract EVM bytecode.
     *           <p>
     *           The file containing the smart contract initcode.
     *           A copy of the contents SHALL be made and held as `bytes`
     *           in smart contract state.<br/>
     *           The contract bytecode is limited in size only by the
     *           network file size limit.
     *     @type string $initcode
     *          *
     *           The source for the smart contract EVM bytecode.
     *           <p>
     *           The bytes of the smart contract initcode. A copy of the contents
     *           SHALL be made and held as `bytes` in smart contract state.<br/>
     *           This value is limited in length by the network transaction size
     *           limit. This entire transaction, including all fields and signatures,
     *           MUST be less than the network transaction size limit.
     *     @type \Proto\Key $adminKey
     *          *
     *           Access control for modification of the smart contract after
     *           it is created.
     *           <p>
     *           If this field is set, that key MUST sign this transaction.<br/>
     *           If this field is set, that key MUST sign each future transaction to
     *           update or delete the contract.<br/>
     *           An updateContract transaction that _only_ extends the topic
     *           expirationTime (a "manual renewal" transaction) SHALL NOT require
     *           admin key signature.
     *           <p>
     *           A contract without an admin key SHALL be immutable, except for
     *           expiration and renewal.
     *     @type int|string $gas
     *          *
     *           A maximum limit to the amount of gas to use for the constructor call.
     *           <p>
     *           The network SHALL charge the greater of the following, but SHALL NOT
     *           charge more than the value of this field.
     *           <ol>
     *             <li>The actual gas consumed by the smart contract
     *                 constructor call.</li>
     *             <li>`80%` of this value.</li>
     *           </ol>
     *           The `80%` factor encourages reasonable estimation, while allowing for
     *           some overage to ensure successful execution.
     *     @type int|string $initialBalance
     *          *
     *           The amount of HBAR to use as an initial balance for the account
     *           representing the new smart contract.
     *           <p>
     *           This value is presented in tinybar
     *           (10<sup><strong>-</strong>8</sup> HBAR).<br/>
     *           The HBAR provided here will be withdrawn from the payer account that
     *           signed this transaction.
     *     @type \Proto\AccountID $proxyAccountID
     *          *
     *           Proxy account staking is handled via `staked_id`.
     *           <p>
     *           Former field to designate a proxy account for HBAR staking.
     *           This field MUST NOT be set.
     *     @type \Proto\Duration $autoRenewPeriod
     *          *
     *           The initial lifetime, in seconds, for the smart contract, and the number
     *           of seconds for which the smart contract will be automatically renewed
     *           upon expiration.
     *           <p>
     *           This value MUST be set.<br/>
     *           This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
     *           This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
     *     @type string $constructorParameters
     *          *
     *           An array of bytes containing the EVM-encoded parameters to pass to
     *           the smart contract constructor defined in the smart contract init
     *           code provided.
     *     @type \Proto\ShardID $shardID
     *          *
     *           <blockquote>Review Question<br/>
     *           <blockquote>Should this be deprecated?<br/>
     *           It's never been used and probably never should be used...<br/>
     *           Shard should be determined by the node the transaction is submitted to.
     *           </blockquote></blockquote>
     *           <p>
     *           The shard in which to create the new smart contract.<br/>
     *           This value is currently ignored.
     *     @type \Proto\RealmID $realmID
     *          *
     *           <blockquote>Review Question<br/>
     *           <blockquote>Should this be deprecated?<br/>
     *           It's never been used and probably never should be used...<br/>
     *           Realm should be determined by node and network parameters.
     *           </blockquote></blockquote>
     *           <p>
     *           The shard/realm in which to create the new smart contract.<br/>
     *           This value is currently ignored.
     *     @type \Proto\Key $newRealmAdminKey
     *          *
     *           <blockquote>Review Question<br/>
     *           <blockquote>Should this be deprecated?<br/>
     *           It's never been used and probably never should be used...<br/>
     *           If a realm is used, it must already exist; we shouldn't be creating it
     *           without a separate transaction.</blockquote></blockquote>
     *           <p>
     *           This was intended to provide an admin key for any new realm created
     *           during the creation of the smart contract.<br/>
     *           This value is currently ignored. a new realm SHALL NOT be created,
     *           regardless of the value of `realmID`.
     *     @type string $memo
     *          *
     *           A short memo for this smart contract.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type int $max_automatic_token_associations
     *          *
     *           The maximum number of tokens that can be auto-associated with this
     *           smart contract.
     *           <p>
     *           If this is less than or equal to `used_auto_associations` (or 0), then
     *           this contract MUST manually associate with a token before transacting
     *           in that token.<br/>
     *           Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
     *           This value MUST NOT be less than `-1`.
     *     @type \Proto\AccountID $auto_renew_account_id
     *          *
     *           The id of an account, in the same shard and realm as this smart
     *           contract, that has signed this transaction, allowing the network to use
     *           its balance, when needed, to automatically extend this contract's
     *           expiration time.
     *           <p>
     *           If this field is set, that key MUST sign this transaction.<br/>
     *           If this field is set, then the network SHALL deduct the necessary fees
     *           from the designated auto renew account, if that account has sufficient
     *           balance. If the auto renew account does not have sufficient balance,
     *           then the fees for contract renewal SHALL be deducted from the HBAR
     *           balance held by the smart contract.<br/>
     *           If this field is not set, then all renewal fees SHALL be deducted from
     *           the HBAR balance held by this contract.
     *     @type \Proto\AccountID $staked_account_id
     *          *
     *           An account ID.
     *           <p>
     *           This smart contract SHALL stake its HBAR via this account as proxy.
     *     @type int|string $staked_node_id
     *          *
     *           The ID of a network node.
     *           <p>
     *           This smart contract SHALL stake its HBAR to this node.
     *           <p>
     *           <blockquote>Note: node IDs do fluctuate as node operators change.
     *           Most contracts are immutable, and a contract staking to an invalid
     *           node ID SHALL NOT participate in staking. Immutable contracts MAY
     *           find it more reliable to use a proxy account for staking
     *           (via `staked_account_id`) to enable updating the _effective_ staking
     *           node ID when necessary through updating the proxy
     *           account.</blockquote>
     *     @type bool $decline_reward
     *          *
     *           A flag indicating that this smart contract declines to receive any
     *           reward for staking its HBAR balance to help secure the network.
     *           <p>
     *           If set to true, this smart contract SHALL NOT receive any reward for
     *           staking its HBAR balance to help secure the network, regardless of
     *           staking configuration, but MAY stake HBAR to support the network
     *           without reward.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ContractCreate::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * The source for the smart contract EVM bytecode.
     * <p>
     * The file containing the smart contract initcode.
     * A copy of the contents SHALL be made and held as `bytes`
     * in smart contract state.<br/>
     * The contract bytecode is limited in size only by the
     * network file size limit.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 1;</code>
     * @return \Proto\FileID|null
     */
    public function getFileID()
    {
        return $this->readOneof(1);
    }

    public function hasFileID()
    {
        return $this->hasOneof(1);
    }

    /**
     **
     * The source for the smart contract EVM bytecode.
     * <p>
     * The file containing the smart contract initcode.
     * A copy of the contents SHALL be made and held as `bytes`
     * in smart contract state.<br/>
     * The contract bytecode is limited in size only by the
     * network file size limit.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 1;</code>
     * @param \Proto\FileID $var
     * @return $this
     */
    public function setFileID($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileID::class);
        $this->writeOneof(1, $var);

        return $this;
    }

    /**
     **
     * The source for the smart contract EVM bytecode.
     * <p>
     * The bytes of the smart contract initcode. A copy of the contents
     * SHALL be made and held as `bytes` in smart contract state.<br/>
     * This value is limited in length by the network transaction size
     * limit. This entire transaction, including all fields and signatures,
     * MUST be less than the network transaction size limit.
     *
     * Generated from protobuf field <code>bytes initcode = 16;</code>
     * @return string
     */
    public function getInitcode()
    {
        return $this->readOneof(16);
    }

    public function hasInitcode()
    {
        return $this->hasOneof(16);
    }

    /**
     **
     * The source for the smart contract EVM bytecode.
     * <p>
     * The bytes of the smart contract initcode. A copy of the contents
     * SHALL be made and held as `bytes` in smart contract state.<br/>
     * This value is limited in length by the network transaction size
     * limit. This entire transaction, including all fields and signatures,
     * MUST be less than the network transaction size limit.
     *
     * Generated from protobuf field <code>bytes initcode = 16;</code>
     * @param string $var
     * @return $this
     */
    public function setInitcode($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(16, $var);

        return $this;
    }

    /**
     **
     * Access control for modification of the smart contract after
     * it is created.
     * <p>
     * If this field is set, that key MUST sign this transaction.<br/>
     * If this field is set, that key MUST sign each future transaction to
     * update or delete the contract.<br/>
     * An updateContract transaction that _only_ extends the topic
     * expirationTime (a "manual renewal" transaction) SHALL NOT require
     * admin key signature.
     * <p>
     * A contract without an admin key SHALL be immutable, except for
     * expiration and renewal.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 3;</code>
     * @return \Proto\Key|null
     */
    public function getAdminKey()
    {
        return $this->adminKey;
    }

    public function hasAdminKey()
    {
        return isset($this->adminKey);
    }

    public function clearAdminKey()
    {
        unset($this->adminKey);
    }

    /**
     **
     * Access control for modification of the smart contract after
     * it is created.
     * <p>
     * If this field is set, that key MUST sign this transaction.<br/>
     * If this field is set, that key MUST sign each future transaction to
     * update or delete the contract.<br/>
     * An updateContract transaction that _only_ extends the topic
     * expirationTime (a "manual renewal" transaction) SHALL NOT require
     * admin key signature.
     * <p>
     * A contract without an admin key SHALL be immutable, except for
     * expiration and renewal.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 3;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setAdminKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->adminKey = $var;

        return $this;
    }

    /**
     **
     * A maximum limit to the amount of gas to use for the constructor call.
     * <p>
     * The network SHALL charge the greater of the following, but SHALL NOT
     * charge more than the value of this field.
     * <ol>
     *   <li>The actual gas consumed by the smart contract
     *       constructor call.</li>
     *   <li>`80%` of this value.</li>
     * </ol>
     * The `80%` factor encourages reasonable estimation, while allowing for
     * some overage to ensure successful execution.
     *
     * Generated from protobuf field <code>int64 gas = 4;</code>
     * @return int|string
     */
    public function getGas()
    {
        return $this->gas;
    }

    /**
     **
     * A maximum limit to the amount of gas to use for the constructor call.
     * <p>
     * The network SHALL charge the greater of the following, but SHALL NOT
     * charge more than the value of this field.
     * <ol>
     *   <li>The actual gas consumed by the smart contract
     *       constructor call.</li>
     *   <li>`80%` of this value.</li>
     * </ol>
     * The `80%` factor encourages reasonable estimation, while allowing for
     * some overage to ensure successful execution.
     *
     * Generated from protobuf field <code>int64 gas = 4;</code>
     * @param int|string $var
     * @return $this
     */
    public function setGas($var)
    {
        GPBUtil::checkInt64($var);
        $this->gas = $var;

        return $this;
    }

    /**
     **
     * The amount of HBAR to use as an initial balance for the account
     * representing the new smart contract.
     * <p>
     * This value is presented in tinybar
     * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
     * The HBAR provided here will be withdrawn from the payer account that
     * signed this transaction.
     *
     * Generated from protobuf field <code>int64 initialBalance = 5;</code>
     * @return int|string
     */
    public function getInitialBalance()
    {
        return $this->initialBalance;
    }

    /**
     **
     * The amount of HBAR to use as an initial balance for the account
     * representing the new smart contract.
     * <p>
     * This value is presented in tinybar
     * (10<sup><strong>-</strong>8</sup> HBAR).<br/>
     * The HBAR provided here will be withdrawn from the payer account that
     * signed this transaction.
     *
     * Generated from protobuf field <code>int64 initialBalance = 5;</code>
     * @param int|string $var
     * @return $this
     */
    public function setInitialBalance($var)
    {
        GPBUtil::checkInt64($var);
        $this->initialBalance = $var;

        return $this;
    }

    /**
     **
     * Proxy account staking is handled via `staked_id`.
     * <p>
     * Former field to designate a proxy account for HBAR staking.
     * This field MUST NOT be set.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 6 [deprecated = true];</code>
     * @return \Proto\AccountID|null
     * @deprecated
     */
    public function getProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return $this->proxyAccountID;
    }

    public function hasProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->proxyAccountID);
    }

    public function clearProxyAccountID()
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        unset($this->proxyAccountID);
    }

    /**
     **
     * Proxy account staking is handled via `staked_id`.
     * <p>
     * Former field to designate a proxy account for HBAR staking.
     * This field MUST NOT be set.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 6 [deprecated = true];</code>
     * @param \Proto\AccountID $var
     * @return $this
     * @deprecated
     */
    public function setProxyAccountID($var)
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->proxyAccountID = $var;

        return $this;
    }

    /**
     **
     * The initial lifetime, in seconds, for the smart contract, and the number
     * of seconds for which the smart contract will be automatically renewed
     * upon expiration.
     * <p>
     * This value MUST be set.<br/>
     * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
     * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 8;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->autoRenewPeriod;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->autoRenewPeriod);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->autoRenewPeriod);
    }

    /**
     **
     * The initial lifetime, in seconds, for the smart contract, and the number
     * of seconds for which the smart contract will be automatically renewed
     * upon expiration.
     * <p>
     * This value MUST be set.<br/>
     * This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.<br/>
     * This value MUST be less than the configured MAX_AUTORENEW_PERIOD.<br/>
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 8;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->autoRenewPeriod = $var;

        return $this;
    }

    /**
     **
     * An array of bytes containing the EVM-encoded parameters to pass to
     * the smart contract constructor defined in the smart contract init
     * code provided.
     *
     * Generated from protobuf field <code>bytes constructorParameters = 9;</code>
     * @return string
     */
    public function getConstructorParameters()
    {
        return $this->constructorParameters;
    }

    /**
     **
     * An array of bytes containing the EVM-encoded parameters to pass to
     * the smart contract constructor defined in the smart contract init
     * code provided.
     *
     * Generated from protobuf field <code>bytes constructorParameters = 9;</code>
     * @param string $var
     * @return $this
     */
    public function setConstructorParameters($var)
    {
        GPBUtil::checkString($var, False);
        $this->constructorParameters = $var;

        return $this;
    }

    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * Shard should be determined by the node the transaction is submitted to.
     * </blockquote></blockquote>
     * <p>
     * The shard in which to create the new smart contract.<br/>
     * This value is currently ignored.
     *
     * Generated from protobuf field <code>.proto.ShardID shardID = 10;</code>
     * @return \Proto\ShardID|null
     */
    public function getShardID()
    {
        return $this->shardID;
    }

    public function hasShardID()
    {
        return isset($this->shardID);
    }

    public function clearShardID()
    {
        unset($this->shardID);
    }

    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * Shard should be determined by the node the transaction is submitted to.
     * </blockquote></blockquote>
     * <p>
     * The shard in which to create the new smart contract.<br/>
     * This value is currently ignored.
     *
     * Generated from protobuf field <code>.proto.ShardID shardID = 10;</code>
     * @param \Proto\ShardID $var
     * @return $this
     */
    public function setShardID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ShardID::class);
        $this->shardID = $var;

        return $this;
    }

    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * Realm should be determined by node and network parameters.
     * </blockquote></blockquote>
     * <p>
     * The shard/realm in which to create the new smart contract.<br/>
     * This value is currently ignored.
     *
     * Generated from protobuf field <code>.proto.RealmID realmID = 11;</code>
     * @return \Proto\RealmID|null
     */
    public function getRealmID()
    {
        return $this->realmID;
    }

    public function hasRealmID()
    {
        return isset($this->realmID);
    }

    public function clearRealmID()
    {
        unset($this->realmID);
    }

    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * Realm should be determined by node and network parameters.
     * </blockquote></blockquote>
     * <p>
     * The shard/realm in which to create the new smart contract.<br/>
     * This value is currently ignored.
     *
     * Generated from protobuf field <code>.proto.RealmID realmID = 11;</code>
     * @param \Proto\RealmID $var
     * @return $this
     */
    public function setRealmID($var)
    {
        GPBUtil::checkMessage($var, \Proto\RealmID::class);
        $this->realmID = $var;

        return $this;
    }

    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * If a realm is used, it must already exist; we shouldn't be creating it
     * without a separate transaction.</blockquote></blockquote>
     * <p>
     * This was intended to provide an admin key for any new realm created
     * during the creation of the smart contract.<br/>
     * This value is currently ignored. a new realm SHALL NOT be created,
     * regardless of the value of `realmID`.
     *
     * Generated from protobuf field <code>.proto.Key newRealmAdminKey = 12;</code>
     * @return \Proto\Key|null
     */
    public function getNewRealmAdminKey()
    {
        return $this->newRealmAdminKey;
    }

    public function hasNewRealmAdminKey()
    {
        return isset($this->newRealmAdminKey);
    }

    public function clearNewRealmAdminKey()
    {
        unset($this->newRealmAdminKey);
    }

    /**
     **
     * <blockquote>Review Question<br/>
     * <blockquote>Should this be deprecated?<br/>
     * It's never been used and probably never should be used...<br/>
     * If a realm is used, it must already exist; we shouldn't be creating it
     * without a separate transaction.</blockquote></blockquote>
     * <p>
     * This was intended to provide an admin key for any new realm created
     * during the creation of the smart contract.<br/>
     * This value is currently ignored. a new realm SHALL NOT be created,
     * regardless of the value of `realmID`.
     *
     * Generated from protobuf field <code>.proto.Key newRealmAdminKey = 12;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setNewRealmAdminKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->newRealmAdminKey = $var;

        return $this;
    }

    /**
     **
     * A short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 13;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 13;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * The maximum number of tokens that can be auto-associated with this
     * smart contract.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0), then
     * this contract MUST manually associate with a token before transacting
     * in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     * @return int
     */
    public function getMaxAutomaticTokenAssociations()
    {
        return $this->max_automatic_token_associations;
    }

    /**
     **
     * The maximum number of tokens that can be auto-associated with this
     * smart contract.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0), then
     * this contract MUST manually associate with a token before transacting
     * in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     * @param int $var
     * @return $this
     */
    public function setMaxAutomaticTokenAssociations($var)
    {
        GPBUtil::checkInt32($var);
        $this->max_automatic_token_associations = $var;

        return $this;
    }

    /**
     **
     * The id of an account, in the same shard and realm as this smart
     * contract, that has signed this transaction, allowing the network to use
     * its balance, when needed, to automatically extend this contract's
     * expiration time.
     * <p>
     * If this field is set, that key MUST sign this transaction.<br/>
     * If this field is set, then the network SHALL deduct the necessary fees
     * from the designated auto renew account, if that account has sufficient
     * balance. If the auto renew account does not have sufficient balance,
     * then the fees for contract renewal SHALL be deducted from the HBAR
     * balance held by the smart contract.<br/>
     * If this field is not set, then all renewal fees SHALL be deducted from
     * the HBAR balance held by this contract.
     *
     * Generated from protobuf field <code>.proto.AccountID auto_renew_account_id = 15;</code>
     * @return \Proto\AccountID|null
     */
    public function getAutoRenewAccountId()
    {
        return $this->auto_renew_account_id;
    }

    public function hasAutoRenewAccountId()
    {
        return isset($this->auto_renew_account_id);
    }

    public function clearAutoRenewAccountId()
    {
        unset($this->auto_renew_account_id);
    }

    /**
     **
     * The id of an account, in the same shard and realm as this smart
     * contract, that has signed this transaction, allowing the network to use
     * its balance, when needed, to automatically extend this contract's
     * expiration time.
     * <p>
     * If this field is set, that key MUST sign this transaction.<br/>
     * If this field is set, then the network SHALL deduct the necessary fees
     * from the designated auto renew account, if that account has sufficient
     * balance. If the auto renew account does not have sufficient balance,
     * then the fees for contract renewal SHALL be deducted from the HBAR
     * balance held by the smart contract.<br/>
     * If this field is not set, then all renewal fees SHALL be deducted from
     * the HBAR balance held by this contract.
     *
     * Generated from protobuf field <code>.proto.AccountID auto_renew_account_id = 15;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAutoRenewAccountId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->auto_renew_account_id = $var;

        return $this;
    }

    /**
     **
     * An account ID.
     * <p>
     * This smart contract SHALL stake its HBAR via this account as proxy.
     *
     * Generated from protobuf field <code>.proto.AccountID staked_account_id = 17;</code>
     * @return \Proto\AccountID|null
     */
    public function getStakedAccountId()
    {
        return $this->readOneof(17);
    }

    public function hasStakedAccountId()
    {
        return $this->hasOneof(17);
    }

    /**
     **
     * An account ID.
     * <p>
     * This smart contract SHALL stake its HBAR via this account as proxy.
     *
     * Generated from protobuf field <code>.proto.AccountID staked_account_id = 17;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setStakedAccountId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->writeOneof(17, $var);

        return $this;
    }

    /**
     **
     * The ID of a network node.
     * <p>
     * This smart contract SHALL stake its HBAR to this node.
     * <p>
     * <blockquote>Note: node IDs do fluctuate as node operators change.
     * Most contracts are immutable, and a contract staking to an invalid
     * node ID SHALL NOT participate in staking. Immutable contracts MAY
     * find it more reliable to use a proxy account for staking
     * (via `staked_account_id`) to enable updating the _effective_ staking
     * node ID when necessary through updating the proxy
     * account.</blockquote>
     *
     * Generated from protobuf field <code>int64 staked_node_id = 18;</code>
     * @return int|string
     */
    public function getStakedNodeId()
    {
        return $this->readOneof(18);
    }

    public function hasStakedNodeId()
    {
        return $this->hasOneof(18);
    }

    /**
     **
     * The ID of a network node.
     * <p>
     * This smart contract SHALL stake its HBAR to this node.
     * <p>
     * <blockquote>Note: node IDs do fluctuate as node operators change.
     * Most contracts are immutable, and a contract staking to an invalid
     * node ID SHALL NOT participate in staking. Immutable contracts MAY
     * find it more reliable to use a proxy account for staking
     * (via `staked_account_id`) to enable updating the _effective_ staking
     * node ID when necessary through updating the proxy
     * account.</blockquote>
     *
     * Generated from protobuf field <code>int64 staked_node_id = 18;</code>
     * @param int|string $var
     * @return $this
     */
    public function setStakedNodeId($var)
    {
        GPBUtil::checkInt64($var);
        $this->writeOneof(18, $var);

        return $this;
    }

    /**
     **
     * A flag indicating that this smart contract declines to receive any
     * reward for staking its HBAR balance to help secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>bool decline_reward = 19;</code>
     * @return bool
     */
    public function getDeclineReward()
    {
        return $this->decline_reward;
    }

    /**
     **
     * A flag indicating that this smart contract declines to receive any
     * reward for staking its HBAR balance to help secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>bool decline_reward = 19;</code>
     * @param bool $var
     * @return $this
     */
    public function setDeclineReward($var)
    {
        GPBUtil::checkBool($var);
        $this->decline_reward = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getInitcodeSource()
    {
        return $this->whichOneof("initcodeSource");
    }

    /**
     * @return string
     */
    public function getStakedId()
    {
        return $this->whichOneof("staked_id");
    }

}

