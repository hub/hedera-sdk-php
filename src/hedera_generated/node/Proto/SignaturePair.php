<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: basic_types.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A public key and signature pair.<br/>
 * Only Ed25519 and ECDSA(secp256k1) keys and signatures are currently supported
 * as cryptographic (non-implied) signatures.
 *
 * Generated from protobuf message <code>proto.SignaturePair</code>
 */
class SignaturePair extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * Prefix bytes of the public key.
     * <p>
     * The client may use any number of bytes from zero to the whole length of
     * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
     * true that only one cryptographic key is required to sign the associated
     * transaction.<br/>
     * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
     * key is required to sign the transaction, the request SHALL resolve to
     * `INVALID_SIGNATURE`.
     * <blockquote>Important Note<blockquote>
     * In the special case that a signature is provided to authorize a
     * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
     * key_.<br/>
     * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
     * 32 bytes long and contain the full public key bytes.<br/>
     * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
     * 33 bytes long and contain the full _compressed_ form of the public key.
     * </blockquote></blockquote>
     * <p>
     * <dl><dt>Purpose</dt>
     * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
     * shorter prefixes will have fewer bytes, and so will have a lower
     * transaction fee.
     * The prefixes, however, MUST be long enough to distinguish between all
     * of the public keys that might be signing the transaction. Therefore,
     * software signing a transaction SHOULD evaluate which keys might possibly
     * be required to sign a transaction, and ensure that the shortest prefix
     * that is sufficient to unambiguously identify the correct key is used.
     * </dd></dl>
     *
     * Generated from protobuf field <code>bytes pubKeyPrefix = 1;</code>
     */
    protected $pubKeyPrefix = '';
    protected $signature;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $pubKeyPrefix
     *          *
     *           Prefix bytes of the public key.
     *           <p>
     *           The client may use any number of bytes from zero to the whole length of
     *           the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
     *           true that only one cryptographic key is required to sign the associated
     *           transaction.<br/>
     *           If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
     *           key is required to sign the transaction, the request SHALL resolve to
     *           `INVALID_SIGNATURE`.
     *           <blockquote>Important Note<blockquote>
     *           In the special case that a signature is provided to authorize a
     *           precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
     *           key_.<br/>
     *           That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
     *           32 bytes long and contain the full public key bytes.<br/>
     *           If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
     *           33 bytes long and contain the full _compressed_ form of the public key.
     *           </blockquote></blockquote>
     *           <p>
     *           <dl><dt>Purpose</dt>
     *           <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
     *           shorter prefixes will have fewer bytes, and so will have a lower
     *           transaction fee.
     *           The prefixes, however, MUST be long enough to distinguish between all
     *           of the public keys that might be signing the transaction. Therefore,
     *           software signing a transaction SHOULD evaluate which keys might possibly
     *           be required to sign a transaction, and ensure that the shortest prefix
     *           that is sufficient to unambiguously identify the correct key is used.
     *           </dd></dl>
     *     @type string $contract
     *          *
     *           A smart contract virtual signature.
     *           <p>
     *           This value MUST be length zero, if set.
     *     @type string $ed25519
     *          *
     *           An Ed25519 signature.
     *     @type string $RSA_3072
     *          *
     *           This option is not supported.<br/>
     *           A RSA-3072 signature.
     *     @type string $ECDSA_384
     *          *
     *           This option is not supported.<br/>
     *           ECDSA p-384 signature.
     *     @type string $ECDSA_secp256k1
     *          *
     *           An ECDSA(secp256k1) signature.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\BasicTypes::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * Prefix bytes of the public key.
     * <p>
     * The client may use any number of bytes from zero to the whole length of
     * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
     * true that only one cryptographic key is required to sign the associated
     * transaction.<br/>
     * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
     * key is required to sign the transaction, the request SHALL resolve to
     * `INVALID_SIGNATURE`.
     * <blockquote>Important Note<blockquote>
     * In the special case that a signature is provided to authorize a
     * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
     * key_.<br/>
     * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
     * 32 bytes long and contain the full public key bytes.<br/>
     * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
     * 33 bytes long and contain the full _compressed_ form of the public key.
     * </blockquote></blockquote>
     * <p>
     * <dl><dt>Purpose</dt>
     * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
     * shorter prefixes will have fewer bytes, and so will have a lower
     * transaction fee.
     * The prefixes, however, MUST be long enough to distinguish between all
     * of the public keys that might be signing the transaction. Therefore,
     * software signing a transaction SHOULD evaluate which keys might possibly
     * be required to sign a transaction, and ensure that the shortest prefix
     * that is sufficient to unambiguously identify the correct key is used.
     * </dd></dl>
     *
     * Generated from protobuf field <code>bytes pubKeyPrefix = 1;</code>
     * @return string
     */
    public function getPubKeyPrefix()
    {
        return $this->pubKeyPrefix;
    }

    /**
     **
     * Prefix bytes of the public key.
     * <p>
     * The client may use any number of bytes from zero to the whole length of
     * the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
     * true that only one cryptographic key is required to sign the associated
     * transaction.<br/>
     * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
     * key is required to sign the transaction, the request SHALL resolve to
     * `INVALID_SIGNATURE`.
     * <blockquote>Important Note<blockquote>
     * In the special case that a signature is provided to authorize a
     * precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
     * key_.<br/>
     * That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
     * 32 bytes long and contain the full public key bytes.<br/>
     * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
     * 33 bytes long and contain the full _compressed_ form of the public key.
     * </blockquote></blockquote>
     * <p>
     * <dl><dt>Purpose</dt>
     * <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
     * shorter prefixes will have fewer bytes, and so will have a lower
     * transaction fee.
     * The prefixes, however, MUST be long enough to distinguish between all
     * of the public keys that might be signing the transaction. Therefore,
     * software signing a transaction SHOULD evaluate which keys might possibly
     * be required to sign a transaction, and ensure that the shortest prefix
     * that is sufficient to unambiguously identify the correct key is used.
     * </dd></dl>
     *
     * Generated from protobuf field <code>bytes pubKeyPrefix = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setPubKeyPrefix($var)
    {
        GPBUtil::checkString($var, False);
        $this->pubKeyPrefix = $var;

        return $this;
    }

    /**
     **
     * A smart contract virtual signature.
     * <p>
     * This value MUST be length zero, if set.
     *
     * Generated from protobuf field <code>bytes contract = 2;</code>
     * @return string
     */
    public function getContract()
    {
        return $this->readOneof(2);
    }

    public function hasContract()
    {
        return $this->hasOneof(2);
    }

    /**
     **
     * A smart contract virtual signature.
     * <p>
     * This value MUST be length zero, if set.
     *
     * Generated from protobuf field <code>bytes contract = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setContract($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(2, $var);

        return $this;
    }

    /**
     **
     * An Ed25519 signature.
     *
     * Generated from protobuf field <code>bytes ed25519 = 3;</code>
     * @return string
     */
    public function getEd25519()
    {
        return $this->readOneof(3);
    }

    public function hasEd25519()
    {
        return $this->hasOneof(3);
    }

    /**
     **
     * An Ed25519 signature.
     *
     * Generated from protobuf field <code>bytes ed25519 = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setEd25519($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     **
     * This option is not supported.<br/>
     * A RSA-3072 signature.
     *
     * Generated from protobuf field <code>bytes RSA_3072 = 4 [deprecated = true];</code>
     * @return string
     * @deprecated
     */
    public function getRSA3072()
    {
        if ($this->hasOneof(4)) {
            @trigger_error('RSA_3072 is deprecated.', E_USER_DEPRECATED);
        }
        return $this->readOneof(4);
    }

    public function hasRSA3072()
    {
        if ($this->hasOneof(4)) {
            @trigger_error('RSA_3072 is deprecated.', E_USER_DEPRECATED);
        }
        return $this->hasOneof(4);
    }

    /**
     **
     * This option is not supported.<br/>
     * A RSA-3072 signature.
     *
     * Generated from protobuf field <code>bytes RSA_3072 = 4 [deprecated = true];</code>
     * @param string $var
     * @return $this
     * @deprecated
     */
    public function setRSA3072($var)
    {
        @trigger_error('RSA_3072 is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkString($var, False);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     **
     * This option is not supported.<br/>
     * ECDSA p-384 signature.
     *
     * Generated from protobuf field <code>bytes ECDSA_384 = 5 [deprecated = true];</code>
     * @return string
     * @deprecated
     */
    public function getECDSA384()
    {
        if ($this->hasOneof(5)) {
            @trigger_error('ECDSA_384 is deprecated.', E_USER_DEPRECATED);
        }
        return $this->readOneof(5);
    }

    public function hasECDSA384()
    {
        if ($this->hasOneof(5)) {
            @trigger_error('ECDSA_384 is deprecated.', E_USER_DEPRECATED);
        }
        return $this->hasOneof(5);
    }

    /**
     **
     * This option is not supported.<br/>
     * ECDSA p-384 signature.
     *
     * Generated from protobuf field <code>bytes ECDSA_384 = 5 [deprecated = true];</code>
     * @param string $var
     * @return $this
     * @deprecated
     */
    public function setECDSA384($var)
    {
        @trigger_error('ECDSA_384 is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkString($var, False);
        $this->writeOneof(5, $var);

        return $this;
    }

    /**
     **
     * An ECDSA(secp256k1) signature.
     *
     * Generated from protobuf field <code>bytes ECDSA_secp256k1 = 6;</code>
     * @return string
     */
    public function getECDSASecp256K1()
    {
        return $this->readOneof(6);
    }

    public function hasECDSASecp256K1()
    {
        return $this->hasOneof(6);
    }

    /**
     **
     * An ECDSA(secp256k1) signature.
     *
     * Generated from protobuf field <code>bytes ECDSA_secp256k1 = 6;</code>
     * @param string $var
     * @return $this
     */
    public function setECDSASecp256K1($var)
    {
        GPBUtil::checkString($var, False);
        $this->writeOneof(6, $var);

        return $this;
    }

    /**
     * @return string
     */
    public function getSignature()
    {
        return $this->whichOneof("signature");
    }

}

