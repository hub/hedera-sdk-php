<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: contract_update.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Modify the current state of a smart contract.
 * ### Requirements
 * - The `adminKey` MUST sign all contract update transactions except one
 *   that only updates the `expirationTime`.
 * - A transaction that modifies any field other than `expirationTime` for
 *   a contract without a valid `adminKey` set SHALL fail with response
 *   code `MODIFYING_IMMUTABLE_CONTRACT`.
 * - Fields set to non-default values in this transaction SHALL be updated on
 *   success. Fields not set to non-default values SHALL NOT be
 *   updated on success.
 * ### Block Stream Effects
 * None
 *
 * Generated from protobuf message <code>proto.ContractUpdateTransactionBody</code>
 */
class ContractUpdateTransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * The contact ID that identifies the smart contract to be updated.<br/>
     * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 1;</code>
     */
    protected $contractID = null;
    /**
     **
     * If set, modify the time at which this contract will expire.<br/>
     * An expired contract requires a rent payment to "renew" the contract.
     * A transaction to update this field is how that rent payment is made.
     * <p>
     * This value MUST NOT be less than the current `expirationTime`
     * of the contract. If this value is earlier than the current
     * value, the transaction SHALL fail with response
     * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 2;</code>
     */
    protected $expirationTime = null;
    /**
     **
     * If set, modify the key that authorizes updates to the contract.
     * <p>
     * If this field is set to a valid Key, this key and the previously set key
     * MUST both sign this transaction.<br/>
     * If this value is an empty `KeyList`, the prior key MUST sign this
     * transaction, and the smart contract SHALL be immutable after this
     * transaction completes, except for expiration and renewal.<br/>
     * If this value is not an empty `KeyList`, but does not contain any
     * cryptographic keys, or is otherwise malformed, this transaction SHALL
     * fail with response code `INVALID_ADMIN_KEY`.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 3;</code>
     */
    protected $adminKey = null;
    /**
     **
     * Replaced with `staked_id` alternatives.
     * This field is unused and SHALL NOT modify the contract state.<br/>
     * The id of an account to which the contract is proxy staked
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 6 [deprecated = true];</code>
     * @deprecated
     */
    protected $proxyAccountID = null;
    /**
     **
     * If set, modify the duration added to expiration time by each
     * auto-renewal to this value.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 7;</code>
     */
    protected $autoRenewPeriod = null;
    /**
     **
     * This field is unused and SHALL NOT modify the contract state.<br/>
     * Previously, an ID of a file containing the bytecode of the Solidity
     * transaction that created this contract.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 8 [deprecated = true];</code>
     * @deprecated
     */
    protected $fileID = null;
    /**
     **
     * If set, modify the maximum number of tokens that can be auto-associated with the
     * contract.
     * <p>
     * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
     * MUST manually associate with a token before transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_automatic_token_associations = 11;</code>
     */
    protected $max_automatic_token_associations = null;
    /**
     **
     * If set, modify the account, in the same shard and realm as this smart
     * contract, that has agreed to allow the network to use its balance, when
     * needed, to automatically extend this contract's expiration time.
     * <p>
     * If this field is set to a non-default value, that Account MUST sign this
     * transaction.<br/>
     * If this field is set to a default AccountID value (`0.0.0`), any
     * pre-existing `auto_renew_account_id` value SHALL be removed on success.
     *
     * Generated from protobuf field <code>.proto.AccountID auto_renew_account_id = 12;</code>
     */
    protected $auto_renew_account_id = null;
    /**
     **
     * A flag indicating if staking rewards are declined.<br/>
     * If set, modify the flag indicating if this contract declines to accept
     * rewards for staking its HBAR to secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue decline_reward = 15;</code>
     */
    protected $decline_reward = null;
    protected $memoField;
    protected $staked_id;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\ContractID $contractID
     *          *
     *           The contact ID that identifies the smart contract to be updated.<br/>
     *           This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
     *     @type \Proto\Timestamp $expirationTime
     *          *
     *           If set, modify the time at which this contract will expire.<br/>
     *           An expired contract requires a rent payment to "renew" the contract.
     *           A transaction to update this field is how that rent payment is made.
     *           <p>
     *           This value MUST NOT be less than the current `expirationTime`
     *           of the contract. If this value is earlier than the current
     *           value, the transaction SHALL fail with response
     *           code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
     *     @type \Proto\Key $adminKey
     *          *
     *           If set, modify the key that authorizes updates to the contract.
     *           <p>
     *           If this field is set to a valid Key, this key and the previously set key
     *           MUST both sign this transaction.<br/>
     *           If this value is an empty `KeyList`, the prior key MUST sign this
     *           transaction, and the smart contract SHALL be immutable after this
     *           transaction completes, except for expiration and renewal.<br/>
     *           If this value is not an empty `KeyList`, but does not contain any
     *           cryptographic keys, or is otherwise malformed, this transaction SHALL
     *           fail with response code `INVALID_ADMIN_KEY`.
     *     @type \Proto\AccountID $proxyAccountID
     *          *
     *           Replaced with `staked_id` alternatives.
     *           This field is unused and SHALL NOT modify the contract state.<br/>
     *           The id of an account to which the contract is proxy staked
     *     @type \Proto\Duration $autoRenewPeriod
     *          *
     *           If set, modify the duration added to expiration time by each
     *           auto-renewal to this value.
     *     @type \Proto\FileID $fileID
     *          *
     *           This field is unused and SHALL NOT modify the contract state.<br/>
     *           Previously, an ID of a file containing the bytecode of the Solidity
     *           transaction that created this contract.
     *     @type string $memo
     *          *
     *           This value could not accurately distinguish unset or deliberately
     *           empty. memoWrapper should be used instead.<br/>
     *     @type \Google\Protobuf\StringValue $memoWrapper
     *          *
     *           If set, modify the short memo for this smart contract.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type \Google\Protobuf\Int32Value $max_automatic_token_associations
     *          *
     *           If set, modify the maximum number of tokens that can be auto-associated with the
     *           contract.
     *           <p>
     *           If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
     *           MUST manually associate with a token before transacting in that token.<br/>
     *           This value MAY also be `-1` to indicate no limit.<br/>
     *           This value MUST NOT be less than `-1`.
     *     @type \Proto\AccountID $auto_renew_account_id
     *          *
     *           If set, modify the account, in the same shard and realm as this smart
     *           contract, that has agreed to allow the network to use its balance, when
     *           needed, to automatically extend this contract's expiration time.
     *           <p>
     *           If this field is set to a non-default value, that Account MUST sign this
     *           transaction.<br/>
     *           If this field is set to a default AccountID value (`0.0.0`), any
     *           pre-existing `auto_renew_account_id` value SHALL be removed on success.
     *     @type \Proto\AccountID $staked_account_id
     *          *
     *           An account identifier.<br/>
     *           A staked account acts as a proxy, and this contract effectively
     *           nominates the same node as the identified account.
     *           <p>
     *           If set, modify this smart contract such that it SHALL stake its HBAR
     *           to the same node as the identified account.<br/>
     *           If this field is set to a default AccountID value (`0.0.0`), any
     *           pre-existing `staked_account_id` value SHALL be removed on success.
     *     @type int|string $staked_node_id
     *          *
     *           A node identifier.<br/>
     *           A staked node identifier indicates the consensus node that this
     *           account nominates for staking.
     *           <p>
     *           If set, modify this smart contract such that it SHALL stake its HBAR
     *           to this node.
     *           If set to a the value `-1` any pre-existing `staked_node_id` value
     *           SHALL be removed on success.
     *           <p>
     *           <blockquote>Note: node IDs do fluctuate as node operators change.
     *           Most contracts are immutable, and a contract staking to an invalid
     *           node ID SHALL NOT participate in staking. Immutable contracts may
     *           find it more reliable to use a proxy account for staking (via
     *           `staked_account_id`) to enable updating the _effective_ staking node
     *           ID when necessary through updating the proxy account.</blockquote>
     *     @type \Google\Protobuf\BoolValue $decline_reward
     *          *
     *           A flag indicating if staking rewards are declined.<br/>
     *           If set, modify the flag indicating if this contract declines to accept
     *           rewards for staking its HBAR to secure the network.
     *           <p>
     *           If set to true, this smart contract SHALL NOT receive any reward for
     *           staking its HBAR balance to help secure the network, regardless of
     *           staking configuration, but MAY stake HBAR to support the network
     *           without reward.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ContractUpdate::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * The contact ID that identifies the smart contract to be updated.<br/>
     * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 1;</code>
     * @return \Proto\ContractID|null
     */
    public function getContractID()
    {
        return $this->contractID;
    }

    public function hasContractID()
    {
        return isset($this->contractID);
    }

    public function clearContractID()
    {
        unset($this->contractID);
    }

    /**
     **
     * The contact ID that identifies the smart contract to be updated.<br/>
     * This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 1;</code>
     * @param \Proto\ContractID $var
     * @return $this
     */
    public function setContractID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractID::class);
        $this->contractID = $var;

        return $this;
    }

    /**
     **
     * If set, modify the time at which this contract will expire.<br/>
     * An expired contract requires a rent payment to "renew" the contract.
     * A transaction to update this field is how that rent payment is made.
     * <p>
     * This value MUST NOT be less than the current `expirationTime`
     * of the contract. If this value is earlier than the current
     * value, the transaction SHALL fail with response
     * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 2;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExpirationTime()
    {
        return $this->expirationTime;
    }

    public function hasExpirationTime()
    {
        return isset($this->expirationTime);
    }

    public function clearExpirationTime()
    {
        unset($this->expirationTime);
    }

    /**
     **
     * If set, modify the time at which this contract will expire.<br/>
     * An expired contract requires a rent payment to "renew" the contract.
     * A transaction to update this field is how that rent payment is made.
     * <p>
     * This value MUST NOT be less than the current `expirationTime`
     * of the contract. If this value is earlier than the current
     * value, the transaction SHALL fail with response
     * code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 2;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExpirationTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->expirationTime = $var;

        return $this;
    }

    /**
     **
     * If set, modify the key that authorizes updates to the contract.
     * <p>
     * If this field is set to a valid Key, this key and the previously set key
     * MUST both sign this transaction.<br/>
     * If this value is an empty `KeyList`, the prior key MUST sign this
     * transaction, and the smart contract SHALL be immutable after this
     * transaction completes, except for expiration and renewal.<br/>
     * If this value is not an empty `KeyList`, but does not contain any
     * cryptographic keys, or is otherwise malformed, this transaction SHALL
     * fail with response code `INVALID_ADMIN_KEY`.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 3;</code>
     * @return \Proto\Key|null
     */
    public function getAdminKey()
    {
        return $this->adminKey;
    }

    public function hasAdminKey()
    {
        return isset($this->adminKey);
    }

    public function clearAdminKey()
    {
        unset($this->adminKey);
    }

    /**
     **
     * If set, modify the key that authorizes updates to the contract.
     * <p>
     * If this field is set to a valid Key, this key and the previously set key
     * MUST both sign this transaction.<br/>
     * If this value is an empty `KeyList`, the prior key MUST sign this
     * transaction, and the smart contract SHALL be immutable after this
     * transaction completes, except for expiration and renewal.<br/>
     * If this value is not an empty `KeyList`, but does not contain any
     * cryptographic keys, or is otherwise malformed, this transaction SHALL
     * fail with response code `INVALID_ADMIN_KEY`.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 3;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setAdminKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->adminKey = $var;

        return $this;
    }

    /**
     **
     * Replaced with `staked_id` alternatives.
     * This field is unused and SHALL NOT modify the contract state.<br/>
     * The id of an account to which the contract is proxy staked
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 6 [deprecated = true];</code>
     * @return \Proto\AccountID|null
     * @deprecated
     */
    public function getProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return $this->proxyAccountID;
    }

    public function hasProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->proxyAccountID);
    }

    public function clearProxyAccountID()
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        unset($this->proxyAccountID);
    }

    /**
     **
     * Replaced with `staked_id` alternatives.
     * This field is unused and SHALL NOT modify the contract state.<br/>
     * The id of an account to which the contract is proxy staked
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 6 [deprecated = true];</code>
     * @param \Proto\AccountID $var
     * @return $this
     * @deprecated
     */
    public function setProxyAccountID($var)
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->proxyAccountID = $var;

        return $this;
    }

    /**
     **
     * If set, modify the duration added to expiration time by each
     * auto-renewal to this value.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 7;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->autoRenewPeriod;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->autoRenewPeriod);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->autoRenewPeriod);
    }

    /**
     **
     * If set, modify the duration added to expiration time by each
     * auto-renewal to this value.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 7;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->autoRenewPeriod = $var;

        return $this;
    }

    /**
     **
     * This field is unused and SHALL NOT modify the contract state.<br/>
     * Previously, an ID of a file containing the bytecode of the Solidity
     * transaction that created this contract.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 8 [deprecated = true];</code>
     * @return \Proto\FileID|null
     * @deprecated
     */
    public function getFileID()
    {
        if (isset($this->fileID)) {
            @trigger_error('fileID is deprecated.', E_USER_DEPRECATED);
        }
        return $this->fileID;
    }

    public function hasFileID()
    {
        if (isset($this->fileID)) {
            @trigger_error('fileID is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->fileID);
    }

    public function clearFileID()
    {
        @trigger_error('fileID is deprecated.', E_USER_DEPRECATED);
        unset($this->fileID);
    }

    /**
     **
     * This field is unused and SHALL NOT modify the contract state.<br/>
     * Previously, an ID of a file containing the bytecode of the Solidity
     * transaction that created this contract.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 8 [deprecated = true];</code>
     * @param \Proto\FileID $var
     * @return $this
     * @deprecated
     */
    public function setFileID($var)
    {
        @trigger_error('fileID is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\FileID::class);
        $this->fileID = $var;

        return $this;
    }

    /**
     **
     * This value could not accurately distinguish unset or deliberately
     * empty. memoWrapper should be used instead.<br/>
     *
     * Generated from protobuf field <code>string memo = 9 [deprecated = true];</code>
     * @return string
     * @deprecated
     */
    public function getMemo()
    {
        if ($this->hasOneof(9)) {
            @trigger_error('memo is deprecated.', E_USER_DEPRECATED);
        }
        return $this->readOneof(9);
    }

    public function hasMemo()
    {
        if ($this->hasOneof(9)) {
            @trigger_error('memo is deprecated.', E_USER_DEPRECATED);
        }
        return $this->hasOneof(9);
    }

    /**
     **
     * This value could not accurately distinguish unset or deliberately
     * empty. memoWrapper should be used instead.<br/>
     *
     * Generated from protobuf field <code>string memo = 9 [deprecated = true];</code>
     * @param string $var
     * @return $this
     * @deprecated
     */
    public function setMemo($var)
    {
        @trigger_error('memo is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkString($var, True);
        $this->writeOneof(9, $var);

        return $this;
    }

    /**
     **
     * If set, modify the short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>.google.protobuf.StringValue memoWrapper = 10;</code>
     * @return \Google\Protobuf\StringValue|null
     */
    public function getMemoWrapper()
    {
        return $this->readOneof(10);
    }

    public function hasMemoWrapper()
    {
        return $this->hasOneof(10);
    }

    /**
     * Returns the unboxed value from <code>getMemoWrapper()</code>

     **
     * If set, modify the short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>.google.protobuf.StringValue memoWrapper = 10;</code>
     * @return string|null
     */
    public function getMemoWrapperUnwrapped()
    {
        return $this->readWrapperValue("memoWrapper");
    }

    /**
     **
     * If set, modify the short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>.google.protobuf.StringValue memoWrapper = 10;</code>
     * @param \Google\Protobuf\StringValue $var
     * @return $this
     */
    public function setMemoWrapper($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\StringValue::class);
        $this->writeOneof(10, $var);

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\StringValue object.

     **
     * If set, modify the short memo for this smart contract.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>.google.protobuf.StringValue memoWrapper = 10;</code>
     * @param string|null $var
     * @return $this
     */
    public function setMemoWrapperUnwrapped($var)
    {
        $this->writeWrapperValue("memoWrapper", $var);
        return $this;}

    /**
     **
     * If set, modify the maximum number of tokens that can be auto-associated with the
     * contract.
     * <p>
     * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
     * MUST manually associate with a token before transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_automatic_token_associations = 11;</code>
     * @return \Google\Protobuf\Int32Value|null
     */
    public function getMaxAutomaticTokenAssociations()
    {
        return $this->max_automatic_token_associations;
    }

    public function hasMaxAutomaticTokenAssociations()
    {
        return isset($this->max_automatic_token_associations);
    }

    public function clearMaxAutomaticTokenAssociations()
    {
        unset($this->max_automatic_token_associations);
    }

    /**
     * Returns the unboxed value from <code>getMaxAutomaticTokenAssociations()</code>

     **
     * If set, modify the maximum number of tokens that can be auto-associated with the
     * contract.
     * <p>
     * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
     * MUST manually associate with a token before transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_automatic_token_associations = 11;</code>
     * @return int|null
     */
    public function getMaxAutomaticTokenAssociationsUnwrapped()
    {
        return $this->readWrapperValue("max_automatic_token_associations");
    }

    /**
     **
     * If set, modify the maximum number of tokens that can be auto-associated with the
     * contract.
     * <p>
     * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
     * MUST manually associate with a token before transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_automatic_token_associations = 11;</code>
     * @param \Google\Protobuf\Int32Value $var
     * @return $this
     */
    public function setMaxAutomaticTokenAssociations($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int32Value::class);
        $this->max_automatic_token_associations = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int32Value object.

     **
     * If set, modify the maximum number of tokens that can be auto-associated with the
     * contract.
     * <p>
     * If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
     * MUST manually associate with a token before transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int32Value max_automatic_token_associations = 11;</code>
     * @param int|null $var
     * @return $this
     */
    public function setMaxAutomaticTokenAssociationsUnwrapped($var)
    {
        $this->writeWrapperValue("max_automatic_token_associations", $var);
        return $this;}

    /**
     **
     * If set, modify the account, in the same shard and realm as this smart
     * contract, that has agreed to allow the network to use its balance, when
     * needed, to automatically extend this contract's expiration time.
     * <p>
     * If this field is set to a non-default value, that Account MUST sign this
     * transaction.<br/>
     * If this field is set to a default AccountID value (`0.0.0`), any
     * pre-existing `auto_renew_account_id` value SHALL be removed on success.
     *
     * Generated from protobuf field <code>.proto.AccountID auto_renew_account_id = 12;</code>
     * @return \Proto\AccountID|null
     */
    public function getAutoRenewAccountId()
    {
        return $this->auto_renew_account_id;
    }

    public function hasAutoRenewAccountId()
    {
        return isset($this->auto_renew_account_id);
    }

    public function clearAutoRenewAccountId()
    {
        unset($this->auto_renew_account_id);
    }

    /**
     **
     * If set, modify the account, in the same shard and realm as this smart
     * contract, that has agreed to allow the network to use its balance, when
     * needed, to automatically extend this contract's expiration time.
     * <p>
     * If this field is set to a non-default value, that Account MUST sign this
     * transaction.<br/>
     * If this field is set to a default AccountID value (`0.0.0`), any
     * pre-existing `auto_renew_account_id` value SHALL be removed on success.
     *
     * Generated from protobuf field <code>.proto.AccountID auto_renew_account_id = 12;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAutoRenewAccountId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->auto_renew_account_id = $var;

        return $this;
    }

    /**
     **
     * An account identifier.<br/>
     * A staked account acts as a proxy, and this contract effectively
     * nominates the same node as the identified account.
     * <p>
     * If set, modify this smart contract such that it SHALL stake its HBAR
     * to the same node as the identified account.<br/>
     * If this field is set to a default AccountID value (`0.0.0`), any
     * pre-existing `staked_account_id` value SHALL be removed on success.
     *
     * Generated from protobuf field <code>.proto.AccountID staked_account_id = 13;</code>
     * @return \Proto\AccountID|null
     */
    public function getStakedAccountId()
    {
        return $this->readOneof(13);
    }

    public function hasStakedAccountId()
    {
        return $this->hasOneof(13);
    }

    /**
     **
     * An account identifier.<br/>
     * A staked account acts as a proxy, and this contract effectively
     * nominates the same node as the identified account.
     * <p>
     * If set, modify this smart contract such that it SHALL stake its HBAR
     * to the same node as the identified account.<br/>
     * If this field is set to a default AccountID value (`0.0.0`), any
     * pre-existing `staked_account_id` value SHALL be removed on success.
     *
     * Generated from protobuf field <code>.proto.AccountID staked_account_id = 13;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setStakedAccountId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->writeOneof(13, $var);

        return $this;
    }

    /**
     **
     * A node identifier.<br/>
     * A staked node identifier indicates the consensus node that this
     * account nominates for staking.
     * <p>
     * If set, modify this smart contract such that it SHALL stake its HBAR
     * to this node.
     * If set to a the value `-1` any pre-existing `staked_node_id` value
     * SHALL be removed on success.
     * <p>
     * <blockquote>Note: node IDs do fluctuate as node operators change.
     * Most contracts are immutable, and a contract staking to an invalid
     * node ID SHALL NOT participate in staking. Immutable contracts may
     * find it more reliable to use a proxy account for staking (via
     * `staked_account_id`) to enable updating the _effective_ staking node
     * ID when necessary through updating the proxy account.</blockquote>
     *
     * Generated from protobuf field <code>int64 staked_node_id = 14;</code>
     * @return int|string
     */
    public function getStakedNodeId()
    {
        return $this->readOneof(14);
    }

    public function hasStakedNodeId()
    {
        return $this->hasOneof(14);
    }

    /**
     **
     * A node identifier.<br/>
     * A staked node identifier indicates the consensus node that this
     * account nominates for staking.
     * <p>
     * If set, modify this smart contract such that it SHALL stake its HBAR
     * to this node.
     * If set to a the value `-1` any pre-existing `staked_node_id` value
     * SHALL be removed on success.
     * <p>
     * <blockquote>Note: node IDs do fluctuate as node operators change.
     * Most contracts are immutable, and a contract staking to an invalid
     * node ID SHALL NOT participate in staking. Immutable contracts may
     * find it more reliable to use a proxy account for staking (via
     * `staked_account_id`) to enable updating the _effective_ staking node
     * ID when necessary through updating the proxy account.</blockquote>
     *
     * Generated from protobuf field <code>int64 staked_node_id = 14;</code>
     * @param int|string $var
     * @return $this
     */
    public function setStakedNodeId($var)
    {
        GPBUtil::checkInt64($var);
        $this->writeOneof(14, $var);

        return $this;
    }

    /**
     **
     * A flag indicating if staking rewards are declined.<br/>
     * If set, modify the flag indicating if this contract declines to accept
     * rewards for staking its HBAR to secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue decline_reward = 15;</code>
     * @return \Google\Protobuf\BoolValue|null
     */
    public function getDeclineReward()
    {
        return $this->decline_reward;
    }

    public function hasDeclineReward()
    {
        return isset($this->decline_reward);
    }

    public function clearDeclineReward()
    {
        unset($this->decline_reward);
    }

    /**
     * Returns the unboxed value from <code>getDeclineReward()</code>

     **
     * A flag indicating if staking rewards are declined.<br/>
     * If set, modify the flag indicating if this contract declines to accept
     * rewards for staking its HBAR to secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue decline_reward = 15;</code>
     * @return bool|null
     */
    public function getDeclineRewardUnwrapped()
    {
        return $this->readWrapperValue("decline_reward");
    }

    /**
     **
     * A flag indicating if staking rewards are declined.<br/>
     * If set, modify the flag indicating if this contract declines to accept
     * rewards for staking its HBAR to secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue decline_reward = 15;</code>
     * @param \Google\Protobuf\BoolValue $var
     * @return $this
     */
    public function setDeclineReward($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\BoolValue::class);
        $this->decline_reward = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\BoolValue object.

     **
     * A flag indicating if staking rewards are declined.<br/>
     * If set, modify the flag indicating if this contract declines to accept
     * rewards for staking its HBAR to secure the network.
     * <p>
     * If set to true, this smart contract SHALL NOT receive any reward for
     * staking its HBAR balance to help secure the network, regardless of
     * staking configuration, but MAY stake HBAR to support the network
     * without reward.
     *
     * Generated from protobuf field <code>.google.protobuf.BoolValue decline_reward = 15;</code>
     * @param bool|null $var
     * @return $this
     */
    public function setDeclineRewardUnwrapped($var)
    {
        $this->writeWrapperValue("decline_reward", $var);
        return $this;}

    /**
     * @return string
     */
    public function getMemoField()
    {
        return $this->whichOneof("memoField");
    }

    /**
     * @return string
     */
    public function getStakedId()
    {
        return $this->whichOneof("staked_id");
    }

}

