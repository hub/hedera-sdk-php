<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: contract_types.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A contract function result.<br/>
 * The result returned by a call to a smart contract function. This is part of
 * the response to a ContractCallLocal query, and is in the record for a
 * ContractCall. The ContractCreateInstance transaction record also carries a
 * function result, which is the results of the call to the constructor.
 *
 * Generated from protobuf message <code>proto.ContractFunctionResult</code>
 */
class ContractFunctionResult extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A contract identifier.<br/>
     * This identifies the smart contract that defines the function called.
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 1;</code>
     */
    protected $contractID = null;
    /**
     **
     * Result data from the function call.
     * <p>
     * This SHALL be encoded in RLP bytecode format.
     *
     * Generated from protobuf field <code>bytes contractCallResult = 2;</code>
     */
    protected $contractCallResult = '';
    /**
     **
     * Any error message produced by the contract call.
     * <p>
     * This SHALL be unset if the contract call succeeded.
     *
     * Generated from protobuf field <code>string errorMessage = 3;</code>
     */
    protected $errorMessage = '';
    /**
     **
     * A bloom filter produced by this contract call.<br/>
     * Ethereum uses this bloom filter to search for call results in the
     * Ethereum block history. High false positive rates make the bloom
     * filters quite limited value.
     *
     * Generated from protobuf field <code>bytes bloom = 4;</code>
     */
    protected $bloom = '';
    /**
     **
     * A quantity of "gas" used.<br/>
     * This represents the resource units expended to execute this
     * contract call, and correlates to transaction costs.
     *
     * Generated from protobuf field <code>uint64 gasUsed = 5;</code>
     */
    protected $gasUsed = 0;
    /**
     **
     * Any Log events produced by this contract call.
     *
     * Generated from protobuf field <code>repeated .proto.ContractLoginfo logInfo = 6;</code>
     */
    private $logInfo;
    /**
     **
     * Replaced by values in transaction records to support
     * `CREATE2` calls.<br/>
     * <p>
     * The list of smart contracts that were created by the function call.<br/>
     * The created ids will now _also_ be externalized through internal
     * transaction records, where each record has its alias field populated
     * with the new contract's EVM address.<br/>
     * This is needed for contracts created with CREATE2, which removes the
     * trivial relationship between a new contract's Identifier and its
     * Solidity address.
     *
     * Generated from protobuf field <code>repeated .proto.ContractID createdContractIDs = 7 [deprecated = true];</code>
     * @deprecated
     */
    private $createdContractIDs;
    /**
     **
     * A created contract address.<br/>
     * If the function created a new contract (e.g. `CREATE2`),
     * this is the primary 20-byte EVM address for that contract.
     * <p>
     * Every contract SHALL have a "base" EVM address that is determined by its
     * `shard.realm.num` contract ID.<br/>
     * This address is constructed as follows
     * <ol>
     *   <li>The first 4 bytes are the big-endian
     *       representation of the shard.</li>
     *   <li>The next 8 bytes are the big-endian
     *       representation of the realm.</li>
     *   <li>The final 8 bytes are the big-endian
     *       representation of the number.</li>
     * </ol>
     * <p>
     * Contracts created via `CREATE2` SHALL have an _additional_, primary,
     * address that is derived from the
     * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
     * specification. This additional address SHALL NOT be directly related to
     * the `shard.realm.num` contract ID.<br/>
     * It should be emphasized that Contracts created via a `CREATE2` call can
     * also be referenced via the same "base" EVM address as described above.
     *
     * Generated from protobuf field <code>.google.protobuf.BytesValue evm_address = 9;</code>
     */
    protected $evm_address = null;
    /**
     **
     * The amount of gas available for this call, sometimes referred to as the
     * gasLimit.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>int64 gas = 10;</code>
     */
    protected $gas = 0;
    /**
     **
     * An amount, in tinybar, sent by this function call.<br/>
     * This SHALL be zero(0) if the function called is not `payable`.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>int64 amount = 11;</code>
     */
    protected $amount = 0;
    /**
     **
     * The smart contract function to call, and the parameters to pass to that
     * function.<br/>
     * These SHALL be presented in EVM bytecode function call format.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>bytes functionParameters = 12;</code>
     */
    protected $functionParameters = '';
    /**
     **
     * The account that was the "sender" for this contract call.<br/>
     * If this is not set it SHALL be read from the accountId in the
     * transactionId for the contract call.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>.proto.AccountID sender_id = 13;</code>
     */
    protected $sender_id = null;
    /**
     **
     * A list of contract account nonce values.<br/>
     * This list SHALL contain a nonce value for each contract account modified
     * as a result of this contract call. These nonce values SHALL be the value
     * after the contract call is completed.
     *
     * Generated from protobuf field <code>repeated .proto.ContractNonceInfo contract_nonces = 14;</code>
     */
    private $contract_nonces;
    /**
     **
     * A nonce value for the "signer account".<br/>
     * If the contract call updated the signer nonce for the signer account
     * (i.e. by creating another contract), this field SHALL contain the
     * updated value.<br/>
     * If the signer account nonce was not updated, this field SHALL be `null`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int64Value signer_nonce = 15;</code>
     */
    protected $signer_nonce = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\ContractID $contractID
     *          *
     *           A contract identifier.<br/>
     *           This identifies the smart contract that defines the function called.
     *     @type string $contractCallResult
     *          *
     *           Result data from the function call.
     *           <p>
     *           This SHALL be encoded in RLP bytecode format.
     *     @type string $errorMessage
     *          *
     *           Any error message produced by the contract call.
     *           <p>
     *           This SHALL be unset if the contract call succeeded.
     *     @type string $bloom
     *          *
     *           A bloom filter produced by this contract call.<br/>
     *           Ethereum uses this bloom filter to search for call results in the
     *           Ethereum block history. High false positive rates make the bloom
     *           filters quite limited value.
     *     @type int|string $gasUsed
     *          *
     *           A quantity of "gas" used.<br/>
     *           This represents the resource units expended to execute this
     *           contract call, and correlates to transaction costs.
     *     @type \Proto\ContractLoginfo[] $logInfo
     *          *
     *           Any Log events produced by this contract call.
     *     @type \Proto\ContractID[] $createdContractIDs
     *          *
     *           Replaced by values in transaction records to support
     *           `CREATE2` calls.<br/>
     *           <p>
     *           The list of smart contracts that were created by the function call.<br/>
     *           The created ids will now _also_ be externalized through internal
     *           transaction records, where each record has its alias field populated
     *           with the new contract's EVM address.<br/>
     *           This is needed for contracts created with CREATE2, which removes the
     *           trivial relationship between a new contract's Identifier and its
     *           Solidity address.
     *     @type \Google\Protobuf\BytesValue $evm_address
     *          *
     *           A created contract address.<br/>
     *           If the function created a new contract (e.g. `CREATE2`),
     *           this is the primary 20-byte EVM address for that contract.
     *           <p>
     *           Every contract SHALL have a "base" EVM address that is determined by its
     *           `shard.realm.num` contract ID.<br/>
     *           This address is constructed as follows
     *           <ol>
     *             <li>The first 4 bytes are the big-endian
     *                 representation of the shard.</li>
     *             <li>The next 8 bytes are the big-endian
     *                 representation of the realm.</li>
     *             <li>The final 8 bytes are the big-endian
     *                 representation of the number.</li>
     *           </ol>
     *           <p>
     *           Contracts created via `CREATE2` SHALL have an _additional_, primary,
     *           address that is derived from the
     *           <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
     *           specification. This additional address SHALL NOT be directly related to
     *           the `shard.realm.num` contract ID.<br/>
     *           It should be emphasized that Contracts created via a `CREATE2` call can
     *           also be referenced via the same "base" EVM address as described above.
     *     @type int|string $gas
     *          *
     *           The amount of gas available for this call, sometimes referred to as the
     *           gasLimit.<br/>
     *           This field SHALL NOT be populated when the associated `TransactionBody`
     *           in the block stream is a `ContractCreateTransactionBody` or
     *           a `ContractCallTransactionBody`.
     *     @type int|string $amount
     *          *
     *           An amount, in tinybar, sent by this function call.<br/>
     *           This SHALL be zero(0) if the function called is not `payable`.<br/>
     *           This field SHALL NOT be populated when the associated `TransactionBody`
     *           in the block stream is a `ContractCreateTransactionBody` or
     *           a `ContractCallTransactionBody`.
     *     @type string $functionParameters
     *          *
     *           The smart contract function to call, and the parameters to pass to that
     *           function.<br/>
     *           These SHALL be presented in EVM bytecode function call format.<br/>
     *           This field SHALL NOT be populated when the associated `TransactionBody`
     *           in the block stream is a `ContractCreateTransactionBody` or
     *           a `ContractCallTransactionBody`.
     *     @type \Proto\AccountID $sender_id
     *          *
     *           The account that was the "sender" for this contract call.<br/>
     *           If this is not set it SHALL be read from the accountId in the
     *           transactionId for the contract call.<br/>
     *           This field SHALL NOT be populated when the associated `TransactionBody`
     *           in the block stream is a `ContractCreateTransactionBody` or
     *           a `ContractCallTransactionBody`.
     *     @type \Proto\ContractNonceInfo[] $contract_nonces
     *          *
     *           A list of contract account nonce values.<br/>
     *           This list SHALL contain a nonce value for each contract account modified
     *           as a result of this contract call. These nonce values SHALL be the value
     *           after the contract call is completed.
     *     @type \Google\Protobuf\Int64Value $signer_nonce
     *          *
     *           A nonce value for the "signer account".<br/>
     *           If the contract call updated the signer nonce for the signer account
     *           (i.e. by creating another contract), this field SHALL contain the
     *           updated value.<br/>
     *           If the signer account nonce was not updated, this field SHALL be `null`.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ContractTypes::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A contract identifier.<br/>
     * This identifies the smart contract that defines the function called.
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 1;</code>
     * @return \Proto\ContractID|null
     */
    public function getContractID()
    {
        return $this->contractID;
    }

    public function hasContractID()
    {
        return isset($this->contractID);
    }

    public function clearContractID()
    {
        unset($this->contractID);
    }

    /**
     **
     * A contract identifier.<br/>
     * This identifies the smart contract that defines the function called.
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 1;</code>
     * @param \Proto\ContractID $var
     * @return $this
     */
    public function setContractID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractID::class);
        $this->contractID = $var;

        return $this;
    }

    /**
     **
     * Result data from the function call.
     * <p>
     * This SHALL be encoded in RLP bytecode format.
     *
     * Generated from protobuf field <code>bytes contractCallResult = 2;</code>
     * @return string
     */
    public function getContractCallResult()
    {
        return $this->contractCallResult;
    }

    /**
     **
     * Result data from the function call.
     * <p>
     * This SHALL be encoded in RLP bytecode format.
     *
     * Generated from protobuf field <code>bytes contractCallResult = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setContractCallResult($var)
    {
        GPBUtil::checkString($var, False);
        $this->contractCallResult = $var;

        return $this;
    }

    /**
     **
     * Any error message produced by the contract call.
     * <p>
     * This SHALL be unset if the contract call succeeded.
     *
     * Generated from protobuf field <code>string errorMessage = 3;</code>
     * @return string
     */
    public function getErrorMessage()
    {
        return $this->errorMessage;
    }

    /**
     **
     * Any error message produced by the contract call.
     * <p>
     * This SHALL be unset if the contract call succeeded.
     *
     * Generated from protobuf field <code>string errorMessage = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setErrorMessage($var)
    {
        GPBUtil::checkString($var, True);
        $this->errorMessage = $var;

        return $this;
    }

    /**
     **
     * A bloom filter produced by this contract call.<br/>
     * Ethereum uses this bloom filter to search for call results in the
     * Ethereum block history. High false positive rates make the bloom
     * filters quite limited value.
     *
     * Generated from protobuf field <code>bytes bloom = 4;</code>
     * @return string
     */
    public function getBloom()
    {
        return $this->bloom;
    }

    /**
     **
     * A bloom filter produced by this contract call.<br/>
     * Ethereum uses this bloom filter to search for call results in the
     * Ethereum block history. High false positive rates make the bloom
     * filters quite limited value.
     *
     * Generated from protobuf field <code>bytes bloom = 4;</code>
     * @param string $var
     * @return $this
     */
    public function setBloom($var)
    {
        GPBUtil::checkString($var, False);
        $this->bloom = $var;

        return $this;
    }

    /**
     **
     * A quantity of "gas" used.<br/>
     * This represents the resource units expended to execute this
     * contract call, and correlates to transaction costs.
     *
     * Generated from protobuf field <code>uint64 gasUsed = 5;</code>
     * @return int|string
     */
    public function getGasUsed()
    {
        return $this->gasUsed;
    }

    /**
     **
     * A quantity of "gas" used.<br/>
     * This represents the resource units expended to execute this
     * contract call, and correlates to transaction costs.
     *
     * Generated from protobuf field <code>uint64 gasUsed = 5;</code>
     * @param int|string $var
     * @return $this
     */
    public function setGasUsed($var)
    {
        GPBUtil::checkUint64($var);
        $this->gasUsed = $var;

        return $this;
    }

    /**
     **
     * Any Log events produced by this contract call.
     *
     * Generated from protobuf field <code>repeated .proto.ContractLoginfo logInfo = 6;</code>
     * @return RepeatedField<\Proto\ContractLoginfo>
     */
    public function getLogInfo()
    {
        return $this->logInfo;
    }

    /**
     **
     * Any Log events produced by this contract call.
     *
     * Generated from protobuf field <code>repeated .proto.ContractLoginfo logInfo = 6;</code>
     * @param \Proto\ContractLoginfo[] $var
     * @return $this
     */
    public function setLogInfo($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\ContractLoginfo::class);
        $this->logInfo = $arr;

        return $this;
    }

    /**
     **
     * Replaced by values in transaction records to support
     * `CREATE2` calls.<br/>
     * <p>
     * The list of smart contracts that were created by the function call.<br/>
     * The created ids will now _also_ be externalized through internal
     * transaction records, where each record has its alias field populated
     * with the new contract's EVM address.<br/>
     * This is needed for contracts created with CREATE2, which removes the
     * trivial relationship between a new contract's Identifier and its
     * Solidity address.
     *
     * Generated from protobuf field <code>repeated .proto.ContractID createdContractIDs = 7 [deprecated = true];</code>
     * @return RepeatedField<\Proto\ContractID>
     * @deprecated
     */
    public function getCreatedContractIDs()
    {
        if ($this->createdContractIDs->count() !== 0) {
            @trigger_error('createdContractIDs is deprecated.', E_USER_DEPRECATED);
        }
        return $this->createdContractIDs;
    }

    /**
     **
     * Replaced by values in transaction records to support
     * `CREATE2` calls.<br/>
     * <p>
     * The list of smart contracts that were created by the function call.<br/>
     * The created ids will now _also_ be externalized through internal
     * transaction records, where each record has its alias field populated
     * with the new contract's EVM address.<br/>
     * This is needed for contracts created with CREATE2, which removes the
     * trivial relationship between a new contract's Identifier and its
     * Solidity address.
     *
     * Generated from protobuf field <code>repeated .proto.ContractID createdContractIDs = 7 [deprecated = true];</code>
     * @param \Proto\ContractID[] $var
     * @return $this
     * @deprecated
     */
    public function setCreatedContractIDs($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\ContractID::class);
        if ($arr->count() !== 0) {
            @trigger_error('createdContractIDs is deprecated.', E_USER_DEPRECATED);
        }
        $this->createdContractIDs = $arr;

        return $this;
    }

    /**
     **
     * A created contract address.<br/>
     * If the function created a new contract (e.g. `CREATE2`),
     * this is the primary 20-byte EVM address for that contract.
     * <p>
     * Every contract SHALL have a "base" EVM address that is determined by its
     * `shard.realm.num` contract ID.<br/>
     * This address is constructed as follows
     * <ol>
     *   <li>The first 4 bytes are the big-endian
     *       representation of the shard.</li>
     *   <li>The next 8 bytes are the big-endian
     *       representation of the realm.</li>
     *   <li>The final 8 bytes are the big-endian
     *       representation of the number.</li>
     * </ol>
     * <p>
     * Contracts created via `CREATE2` SHALL have an _additional_, primary,
     * address that is derived from the
     * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
     * specification. This additional address SHALL NOT be directly related to
     * the `shard.realm.num` contract ID.<br/>
     * It should be emphasized that Contracts created via a `CREATE2` call can
     * also be referenced via the same "base" EVM address as described above.
     *
     * Generated from protobuf field <code>.google.protobuf.BytesValue evm_address = 9;</code>
     * @return \Google\Protobuf\BytesValue|null
     */
    public function getEvmAddress()
    {
        return $this->evm_address;
    }

    public function hasEvmAddress()
    {
        return isset($this->evm_address);
    }

    public function clearEvmAddress()
    {
        unset($this->evm_address);
    }

    /**
     * Returns the unboxed value from <code>getEvmAddress()</code>

     **
     * A created contract address.<br/>
     * If the function created a new contract (e.g. `CREATE2`),
     * this is the primary 20-byte EVM address for that contract.
     * <p>
     * Every contract SHALL have a "base" EVM address that is determined by its
     * `shard.realm.num` contract ID.<br/>
     * This address is constructed as follows
     * <ol>
     *   <li>The first 4 bytes are the big-endian
     *       representation of the shard.</li>
     *   <li>The next 8 bytes are the big-endian
     *       representation of the realm.</li>
     *   <li>The final 8 bytes are the big-endian
     *       representation of the number.</li>
     * </ol>
     * <p>
     * Contracts created via `CREATE2` SHALL have an _additional_, primary,
     * address that is derived from the
     * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
     * specification. This additional address SHALL NOT be directly related to
     * the `shard.realm.num` contract ID.<br/>
     * It should be emphasized that Contracts created via a `CREATE2` call can
     * also be referenced via the same "base" EVM address as described above.
     *
     * Generated from protobuf field <code>.google.protobuf.BytesValue evm_address = 9;</code>
     * @return string|null
     */
    public function getEvmAddressUnwrapped()
    {
        return $this->readWrapperValue("evm_address");
    }

    /**
     **
     * A created contract address.<br/>
     * If the function created a new contract (e.g. `CREATE2`),
     * this is the primary 20-byte EVM address for that contract.
     * <p>
     * Every contract SHALL have a "base" EVM address that is determined by its
     * `shard.realm.num` contract ID.<br/>
     * This address is constructed as follows
     * <ol>
     *   <li>The first 4 bytes are the big-endian
     *       representation of the shard.</li>
     *   <li>The next 8 bytes are the big-endian
     *       representation of the realm.</li>
     *   <li>The final 8 bytes are the big-endian
     *       representation of the number.</li>
     * </ol>
     * <p>
     * Contracts created via `CREATE2` SHALL have an _additional_, primary,
     * address that is derived from the
     * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
     * specification. This additional address SHALL NOT be directly related to
     * the `shard.realm.num` contract ID.<br/>
     * It should be emphasized that Contracts created via a `CREATE2` call can
     * also be referenced via the same "base" EVM address as described above.
     *
     * Generated from protobuf field <code>.google.protobuf.BytesValue evm_address = 9;</code>
     * @param \Google\Protobuf\BytesValue $var
     * @return $this
     */
    public function setEvmAddress($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\BytesValue::class);
        $this->evm_address = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\BytesValue object.

     **
     * A created contract address.<br/>
     * If the function created a new contract (e.g. `CREATE2`),
     * this is the primary 20-byte EVM address for that contract.
     * <p>
     * Every contract SHALL have a "base" EVM address that is determined by its
     * `shard.realm.num` contract ID.<br/>
     * This address is constructed as follows
     * <ol>
     *   <li>The first 4 bytes are the big-endian
     *       representation of the shard.</li>
     *   <li>The next 8 bytes are the big-endian
     *       representation of the realm.</li>
     *   <li>The final 8 bytes are the big-endian
     *       representation of the number.</li>
     * </ol>
     * <p>
     * Contracts created via `CREATE2` SHALL have an _additional_, primary,
     * address that is derived from the
     * <a href="https://eips.ethereum.org/EIPS/eip-1014"><tt>EIP-1014</tt></a>
     * specification. This additional address SHALL NOT be directly related to
     * the `shard.realm.num` contract ID.<br/>
     * It should be emphasized that Contracts created via a `CREATE2` call can
     * also be referenced via the same "base" EVM address as described above.
     *
     * Generated from protobuf field <code>.google.protobuf.BytesValue evm_address = 9;</code>
     * @param string|null $var
     * @return $this
     */
    public function setEvmAddressUnwrapped($var)
    {
        $this->writeWrapperValue("evm_address", $var);
        return $this;}

    /**
     **
     * The amount of gas available for this call, sometimes referred to as the
     * gasLimit.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>int64 gas = 10;</code>
     * @return int|string
     */
    public function getGas()
    {
        return $this->gas;
    }

    /**
     **
     * The amount of gas available for this call, sometimes referred to as the
     * gasLimit.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>int64 gas = 10;</code>
     * @param int|string $var
     * @return $this
     */
    public function setGas($var)
    {
        GPBUtil::checkInt64($var);
        $this->gas = $var;

        return $this;
    }

    /**
     **
     * An amount, in tinybar, sent by this function call.<br/>
     * This SHALL be zero(0) if the function called is not `payable`.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>int64 amount = 11;</code>
     * @return int|string
     */
    public function getAmount()
    {
        return $this->amount;
    }

    /**
     **
     * An amount, in tinybar, sent by this function call.<br/>
     * This SHALL be zero(0) if the function called is not `payable`.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>int64 amount = 11;</code>
     * @param int|string $var
     * @return $this
     */
    public function setAmount($var)
    {
        GPBUtil::checkInt64($var);
        $this->amount = $var;

        return $this;
    }

    /**
     **
     * The smart contract function to call, and the parameters to pass to that
     * function.<br/>
     * These SHALL be presented in EVM bytecode function call format.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>bytes functionParameters = 12;</code>
     * @return string
     */
    public function getFunctionParameters()
    {
        return $this->functionParameters;
    }

    /**
     **
     * The smart contract function to call, and the parameters to pass to that
     * function.<br/>
     * These SHALL be presented in EVM bytecode function call format.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>bytes functionParameters = 12;</code>
     * @param string $var
     * @return $this
     */
    public function setFunctionParameters($var)
    {
        GPBUtil::checkString($var, False);
        $this->functionParameters = $var;

        return $this;
    }

    /**
     **
     * The account that was the "sender" for this contract call.<br/>
     * If this is not set it SHALL be read from the accountId in the
     * transactionId for the contract call.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>.proto.AccountID sender_id = 13;</code>
     * @return \Proto\AccountID|null
     */
    public function getSenderId()
    {
        return $this->sender_id;
    }

    public function hasSenderId()
    {
        return isset($this->sender_id);
    }

    public function clearSenderId()
    {
        unset($this->sender_id);
    }

    /**
     **
     * The account that was the "sender" for this contract call.<br/>
     * If this is not set it SHALL be read from the accountId in the
     * transactionId for the contract call.<br/>
     * This field SHALL NOT be populated when the associated `TransactionBody`
     * in the block stream is a `ContractCreateTransactionBody` or
     * a `ContractCallTransactionBody`.
     *
     * Generated from protobuf field <code>.proto.AccountID sender_id = 13;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setSenderId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->sender_id = $var;

        return $this;
    }

    /**
     **
     * A list of contract account nonce values.<br/>
     * This list SHALL contain a nonce value for each contract account modified
     * as a result of this contract call. These nonce values SHALL be the value
     * after the contract call is completed.
     *
     * Generated from protobuf field <code>repeated .proto.ContractNonceInfo contract_nonces = 14;</code>
     * @return RepeatedField<\Proto\ContractNonceInfo>
     */
    public function getContractNonces()
    {
        return $this->contract_nonces;
    }

    /**
     **
     * A list of contract account nonce values.<br/>
     * This list SHALL contain a nonce value for each contract account modified
     * as a result of this contract call. These nonce values SHALL be the value
     * after the contract call is completed.
     *
     * Generated from protobuf field <code>repeated .proto.ContractNonceInfo contract_nonces = 14;</code>
     * @param \Proto\ContractNonceInfo[] $var
     * @return $this
     */
    public function setContractNonces($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\ContractNonceInfo::class);
        $this->contract_nonces = $arr;

        return $this;
    }

    /**
     **
     * A nonce value for the "signer account".<br/>
     * If the contract call updated the signer nonce for the signer account
     * (i.e. by creating another contract), this field SHALL contain the
     * updated value.<br/>
     * If the signer account nonce was not updated, this field SHALL be `null`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int64Value signer_nonce = 15;</code>
     * @return \Google\Protobuf\Int64Value|null
     */
    public function getSignerNonce()
    {
        return $this->signer_nonce;
    }

    public function hasSignerNonce()
    {
        return isset($this->signer_nonce);
    }

    public function clearSignerNonce()
    {
        unset($this->signer_nonce);
    }

    /**
     * Returns the unboxed value from <code>getSignerNonce()</code>

     **
     * A nonce value for the "signer account".<br/>
     * If the contract call updated the signer nonce for the signer account
     * (i.e. by creating another contract), this field SHALL contain the
     * updated value.<br/>
     * If the signer account nonce was not updated, this field SHALL be `null`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int64Value signer_nonce = 15;</code>
     * @return int|string|null
     */
    public function getSignerNonceUnwrapped()
    {
        return $this->readWrapperValue("signer_nonce");
    }

    /**
     **
     * A nonce value for the "signer account".<br/>
     * If the contract call updated the signer nonce for the signer account
     * (i.e. by creating another contract), this field SHALL contain the
     * updated value.<br/>
     * If the signer account nonce was not updated, this field SHALL be `null`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int64Value signer_nonce = 15;</code>
     * @param \Google\Protobuf\Int64Value $var
     * @return $this
     */
    public function setSignerNonce($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Int64Value::class);
        $this->signer_nonce = $var;

        return $this;
    }

    /**
     * Sets the field by wrapping a primitive type in a Google\Protobuf\Int64Value object.

     **
     * A nonce value for the "signer account".<br/>
     * If the contract call updated the signer nonce for the signer account
     * (i.e. by creating another contract), this field SHALL contain the
     * updated value.<br/>
     * If the signer account nonce was not updated, this field SHALL be `null`.
     *
     * Generated from protobuf field <code>.google.protobuf.Int64Value signer_nonce = 15;</code>
     * @param int|string|null $var
     * @return $this
     */
    public function setSignerNonceUnwrapped($var)
    {
        $this->writeWrapperValue("signer_nonce", $var);
        return $this;}

}

