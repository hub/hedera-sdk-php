<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: basic_types.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A unique, composite, identifier for a pending airdrop.
 * Each pending airdrop SHALL be uniquely identified by
 * a `PendingAirdropId`.<br/>
 * A `PendingAirdropId` SHALL be recorded when created and MUST be provided in
 * any transaction that would modify that pending airdrop
 * (such as a `claimAirdrop` or `cancelAirdrop`).
 *
 * Generated from protobuf message <code>proto.PendingAirdropId</code>
 */
class PendingAirdropId extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A sending account.
     * <p>
     * This is the account that initiated, and SHALL fund,
     * this pending airdrop.<br/>
     * This field is REQUIRED.
     *
     * Generated from protobuf field <code>.proto.AccountID sender_id = 1;</code>
     */
    protected $sender_id = null;
    /**
     **
     * A receiving account.
     * <p>
     * This is the ID of the account that SHALL receive the airdrop.<br/>
     * This field is REQUIRED.
     *
     * Generated from protobuf field <code>.proto.AccountID receiver_id = 2;</code>
     */
    protected $receiver_id = null;
    protected $token_reference;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\AccountID $sender_id
     *          *
     *           A sending account.
     *           <p>
     *           This is the account that initiated, and SHALL fund,
     *           this pending airdrop.<br/>
     *           This field is REQUIRED.
     *     @type \Proto\AccountID $receiver_id
     *          *
     *           A receiving account.
     *           <p>
     *           This is the ID of the account that SHALL receive the airdrop.<br/>
     *           This field is REQUIRED.
     *     @type \Proto\TokenID $fungible_token_type
     *          *
     *           A token identifier.<br/>
     *           This is the type of token for a fungible/common token airdrop.
     *           <p>
     *           This field is REQUIRED for a fungible/common token and MUST NOT
     *           be used for a non-fungible/unique token.
     *     @type \Proto\NftID $non_fungible_token
     *          *
     *           The id of a single NFT<br/>
     *           This is the type of token for a non-fungible/unique token airdrop
     *           and consists of a Token ID and serial number.
     *           <p>
     *           This field is REQUIRED for a non-fungible/unique token and
     *           MUST NOT be used for a fungible/common token.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\BasicTypes::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A sending account.
     * <p>
     * This is the account that initiated, and SHALL fund,
     * this pending airdrop.<br/>
     * This field is REQUIRED.
     *
     * Generated from protobuf field <code>.proto.AccountID sender_id = 1;</code>
     * @return \Proto\AccountID|null
     */
    public function getSenderId()
    {
        return $this->sender_id;
    }

    public function hasSenderId()
    {
        return isset($this->sender_id);
    }

    public function clearSenderId()
    {
        unset($this->sender_id);
    }

    /**
     **
     * A sending account.
     * <p>
     * This is the account that initiated, and SHALL fund,
     * this pending airdrop.<br/>
     * This field is REQUIRED.
     *
     * Generated from protobuf field <code>.proto.AccountID sender_id = 1;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setSenderId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->sender_id = $var;

        return $this;
    }

    /**
     **
     * A receiving account.
     * <p>
     * This is the ID of the account that SHALL receive the airdrop.<br/>
     * This field is REQUIRED.
     *
     * Generated from protobuf field <code>.proto.AccountID receiver_id = 2;</code>
     * @return \Proto\AccountID|null
     */
    public function getReceiverId()
    {
        return $this->receiver_id;
    }

    public function hasReceiverId()
    {
        return isset($this->receiver_id);
    }

    public function clearReceiverId()
    {
        unset($this->receiver_id);
    }

    /**
     **
     * A receiving account.
     * <p>
     * This is the ID of the account that SHALL receive the airdrop.<br/>
     * This field is REQUIRED.
     *
     * Generated from protobuf field <code>.proto.AccountID receiver_id = 2;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setReceiverId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->receiver_id = $var;

        return $this;
    }

    /**
     **
     * A token identifier.<br/>
     * This is the type of token for a fungible/common token airdrop.
     * <p>
     * This field is REQUIRED for a fungible/common token and MUST NOT
     * be used for a non-fungible/unique token.
     *
     * Generated from protobuf field <code>.proto.TokenID fungible_token_type = 3;</code>
     * @return \Proto\TokenID|null
     */
    public function getFungibleTokenType()
    {
        return $this->readOneof(3);
    }

    public function hasFungibleTokenType()
    {
        return $this->hasOneof(3);
    }

    /**
     **
     * A token identifier.<br/>
     * This is the type of token for a fungible/common token airdrop.
     * <p>
     * This field is REQUIRED for a fungible/common token and MUST NOT
     * be used for a non-fungible/unique token.
     *
     * Generated from protobuf field <code>.proto.TokenID fungible_token_type = 3;</code>
     * @param \Proto\TokenID $var
     * @return $this
     */
    public function setFungibleTokenType($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenID::class);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     **
     * The id of a single NFT<br/>
     * This is the type of token for a non-fungible/unique token airdrop
     * and consists of a Token ID and serial number.
     * <p>
     * This field is REQUIRED for a non-fungible/unique token and
     * MUST NOT be used for a fungible/common token.
     *
     * Generated from protobuf field <code>.proto.NftID non_fungible_token = 4;</code>
     * @return \Proto\NftID|null
     */
    public function getNonFungibleToken()
    {
        return $this->readOneof(4);
    }

    public function hasNonFungibleToken()
    {
        return $this->hasOneof(4);
    }

    /**
     **
     * The id of a single NFT<br/>
     * This is the type of token for a non-fungible/unique token airdrop
     * and consists of a Token ID and serial number.
     * <p>
     * This field is REQUIRED for a non-fungible/unique token and
     * MUST NOT be used for a fungible/common token.
     *
     * Generated from protobuf field <code>.proto.NftID non_fungible_token = 4;</code>
     * @param \Proto\NftID $var
     * @return $this
     */
    public function setNonFungibleToken($var)
    {
        GPBUtil::checkMessage($var, \Proto\NftID::class);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     * @return string
     */
    public function getTokenReference()
    {
        return $this->whichOneof("token_reference");
    }

}

