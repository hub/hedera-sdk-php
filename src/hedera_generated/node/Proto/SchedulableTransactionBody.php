<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: schedulable_transaction_body.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A schedulable transaction.
 * The network configuration `scheduling.whitelist` limits which of these
 * transaction types may actually be scheduled. As of version `0.50.0` of the
 * consensus node software this list contains only `CryptoTransfer`,
 * `ConsensusSubmitMessage`, `TokenBurn`, `TokenMint`,
 * and `CryptoApproveAllowance`.
 *
 * Generated from protobuf message <code>proto.SchedulableTransactionBody</code>
 */
class SchedulableTransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A limit for the transaction fee the client is willing to pay.
     * <p>
     * The network SHALL NOT charge fees greater than this value.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 1;</code>
     */
    protected $transactionFee = 0;
    /**
     **
     * A short description of the schedulable transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 2;</code>
     */
    protected $memo = '';
    protected $data;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int|string $transactionFee
     *          *
     *           A limit for the transaction fee the client is willing to pay.
     *           <p>
     *           The network SHALL NOT charge fees greater than this value.
     *     @type string $memo
     *          *
     *           A short description of the schedulable transaction.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type \Proto\ContractCallTransactionBody $contractCall
     *          *
     *           Call a function defined on a smart contract.
     *     @type \Proto\ContractCreateTransactionBody $contractCreateInstance
     *          *
     *           Create a smart contract.
     *     @type \Proto\ContractUpdateTransactionBody $contractUpdateInstance
     *          *
     *           Update a smart contract.
     *     @type \Proto\ContractDeleteTransactionBody $contractDeleteInstance
     *          *
     *           Delete a smart contract and transfer remaining balance
     *           to a specified account.
     *     @type \Proto\CryptoCreateTransactionBody $cryptoCreateAccount
     *          *
     *           Create a new Hedera account.
     *     @type \Proto\CryptoDeleteTransactionBody $cryptoDelete
     *          *
     *           Delete an Hedera account.<br/>
     *           This will mark the account as deleted, and transfer all remaining
     *           HBAR to a receiver account.
     *     @type \Proto\CryptoTransferTransactionBody $cryptoTransfer
     *          *
     *           Transfer HBAR between accounts.
     *     @type \Proto\CryptoUpdateTransactionBody $cryptoUpdateAccount
     *          *
     *           Modify an Hedera account.
     *     @type \Proto\FileAppendTransactionBody $fileAppend
     *          *
     *           Append data to the end of a file.
     *     @type \Proto\FileCreateTransactionBody $fileCreate
     *          *
     *           Create a new file.
     *     @type \Proto\FileDeleteTransactionBody $fileDelete
     *          *
     *           Delete a file.<br/>
     *           This will remove the content of the file, and mark the file as
     *           deleted.
     *     @type \Proto\FileUpdateTransactionBody $fileUpdate
     *          *
     *           Modify a file.<br/>
     *           This may modify any metadata, and/or _replace_ the content.
     *     @type \Proto\SystemDeleteTransactionBody $systemDelete
     *          *
     *           Delete a file as an Hedera administrative function.<br/>
     *           This is a privileged operation.
     *     @type \Proto\SystemUndeleteTransactionBody $systemUndelete
     *          *
     *           Restore a file deleted via `systemDelete`.<br/>
     *           This is a privileged operation.
     *     @type \Proto\FreezeTransactionBody $freeze
     *          *
     *           Freeze the network.<br/>
     *           This is actually several possible operations, and the caller
     *           should examine the "freeze service" for more detail.<br/>
     *           This is a privileged operation.
     *     @type \Proto\ConsensusCreateTopicTransactionBody $consensusCreateTopic
     *          *
     *           Create a topic.
     *     @type \Proto\ConsensusUpdateTopicTransactionBody $consensusUpdateTopic
     *          *
     *           Update a topic.
     *     @type \Proto\ConsensusDeleteTopicTransactionBody $consensusDeleteTopic
     *          *
     *           Delete a topic.
     *     @type \Proto\ConsensusSubmitMessageTransactionBody $consensusSubmitMessage
     *          *
     *           Submit a message to a topic.<br/>
     *           A message may be "chunked", and submitted in parts, if the total
     *           message size exceeds the limit for a single transaction.
     *     @type \Proto\TokenCreateTransactionBody $tokenCreation
     *          *
     *           Create a new Hedera token.
     *     @type \Proto\TokenFreezeAccountTransactionBody $tokenFreeze
     *          *
     *           Freeze an account with respect to a token.<br/>
     *           A frozen account cannot transact in that token until unfrozen.
     *     @type \Proto\TokenUnfreezeAccountTransactionBody $tokenUnfreeze
     *          *
     *           Unfreeze an account with respect to a token.
     *     @type \Proto\TokenGrantKycTransactionBody $tokenGrantKyc
     *          *
     *           Grant KYC to an account with respect to a token.<br/>
     *           KYC is generally a "know your customer" assertion that a
     *           responsible entity has sufficient information to positively
     *           identify the account holder to relevant authorities.
     *     @type \Proto\TokenRevokeKycTransactionBody $tokenRevokeKyc
     *          *
     *           Revoke KYC from an account with respect to a token.
     *     @type \Proto\TokenDeleteTransactionBody $tokenDeletion
     *          *
     *           Deletes an Hedera token.<br/>
     *           The token will be marked deleted.
     *     @type \Proto\TokenUpdateTransactionBody $tokenUpdate
     *          *
     *           Update an Hedera token.<br/>
     *           Depending on what fields are to be modified, the signature
     *           requirements will vary. See `TokenUpdateTransactionBody` for
     *           further detail.
     *     @type \Proto\TokenMintTransactionBody $tokenMint
     *          *
     *           Mint new tokens.<br/>
     *           All minted tokens will be delivered to the treasury account for
     *           the token type. The "mint key" for the token must sign this
     *           transaction.
     *     @type \Proto\TokenBurnTransactionBody $tokenBurn
     *          *
     *           Burn tokens from the treasury account.<br/>
     *           The "burn key" for the token must sign this transaction.
     *     @type \Proto\TokenWipeAccountTransactionBody $tokenWipe
     *          *
     *           Wipe tokens from an account.<br/>
     *           This will remove a specified amount of fungible/common tokens or
     *           a specified list of non-fungible/unique serial numbered tokens
     *           of a given token type from an Hedera account. The removed tokens
     *           are _burned_ as if by a `tokenBurn` transaction.<br/>
     *           The "wipe key" for the token must sign this transaction.
     *     @type \Proto\TokenAssociateTransactionBody $tokenAssociate
     *          *
     *           Associate tokens to an account.
     *     @type \Proto\TokenDissociateTransactionBody $tokenDissociate
     *          *
     *           Dissociate tokens from an account.
     *     @type \Proto\ScheduleDeleteTransactionBody $scheduleDelete
     *          *
     *           Delete a schedule.<br/>
     *           The schedule will be marked as deleted.
     *     @type \Proto\TokenPauseTransactionBody $token_pause
     *          *
     *           Pause a Token.<br/>
     *           This transaction must be signed by the "pause key" for the token.
     *     @type \Proto\TokenUnpauseTransactionBody $token_unpause
     *          *
     *           Unpause a Token.<br/>
     *           This transaction must be signed by the "pause key" for the token.
     *     @type \Proto\CryptoApproveAllowanceTransactionBody $cryptoApproveAllowance
     *          *
     *           Add one or more approved allowances for spenders to transfer the
     *           paying account's hbar or tokens.
     *     @type \Proto\CryptoDeleteAllowanceTransactionBody $cryptoDeleteAllowance
     *          *
     *           Delete one or more approvals for spenders to transfer the
     *           paying account's hbar or tokens.
     *     @type \Proto\TokenFeeScheduleUpdateTransactionBody $token_fee_schedule_update
     *          *
     *           Update the custom fee schedule for a token.<br/>
     *           This transaction must be signed by the "fee schedule key"
     *           for the token.
     *     @type \Proto\UtilPrngTransactionBody $util_prng
     *          *
     *           Provide a deterministic pseudorandom number based on network state.
     *     @type \Proto\TokenUpdateNftsTransactionBody $token_update_nfts
     *          *
     *           Update one or more non-fungible/unique tokens.<br/>
     *           This will update metadata for one or more serial numbers within
     *           a collection (token type).
     *     @type \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody $nodeCreate
     *          *
     *           Create a new node in the network address book.<br/>
     *           This is a privileged operation.
     *     @type \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody $nodeUpdate
     *          *
     *           Update a node in the network address book.<br/>
     *           This is a privileged operation.
     *     @type \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody $nodeDelete
     *          *
     *           Delete a node from the network address book.<br/>
     *           This will mark the node as deleted.<br/>
     *           This is a privileged operation.
     *     @type \Proto\TokenRejectTransactionBody $tokenReject
     *          *
     *           "Reject" undesired tokens.<br/>
     *           This transaction will transfer one or more tokens or token
     *           balances held by the requesting account to the treasury
     *           for each token type.
     *           <p>
     *           Each transfer MUST be one of the following:
     *           <ul>
     *             <li>A single non-fungible/unique token.</li>
     *             <li>The full balance held for a fungible/common
     *                 token type.</li>
     *           </ul>
     *           When complete, the requesting account SHALL NOT hold the
     *           rejected tokens.<br/>
     *           Custom fees and royalties defined for the tokens rejected
     *           SHALL NOT be charged for this transaction.
     *     @type \Proto\TokenCancelAirdropTransactionBody $tokenCancelAirdrop
     *          *
     *           Cancel an "airdrop".<br/>
     *           This transaction cancels a pending airdrop for one or more
     *           recipients.
     *           <p>
     *           The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
     *     @type \Proto\TokenClaimAirdropTransactionBody $tokenClaimAirdrop
     *          *
     *           Claim an "airdrop".
     *           This transaction "claims" one or more pending "airdrops".
     *           <p>
     *           The airdrop(s) to claim MUST be pending, and not
     *           already claimed.<br/>
     *     @type \Proto\TokenAirdropTransactionBody $tokenAirdrop
     *          *
     *           Send an "airdrop" of tokens to one or more recipients.
     *           <p>
     *           This transaction unilaterally "gifts" tokens by transferring them
     *           from a "sender" account to the "recipient" account(s). If any
     *           recipient is not already associated to the token to airdrop, or
     *           has set a "reciever signature required" flag, then that recipient
     *           is recorded as a "pending" airdrop which must be "claimed".  All
     *           other recipients receive the "airdropped" tokens immediately.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\SchedulableTransactionBody::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A limit for the transaction fee the client is willing to pay.
     * <p>
     * The network SHALL NOT charge fees greater than this value.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 1;</code>
     * @return int|string
     */
    public function getTransactionFee()
    {
        return $this->transactionFee;
    }

    /**
     **
     * A limit for the transaction fee the client is willing to pay.
     * <p>
     * The network SHALL NOT charge fees greater than this value.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 1;</code>
     * @param int|string $var
     * @return $this
     */
    public function setTransactionFee($var)
    {
        GPBUtil::checkUint64($var);
        $this->transactionFee = $var;

        return $this;
    }

    /**
     **
     * A short description of the schedulable transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 2;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description of the schedulable transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * Call a function defined on a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCallTransactionBody contractCall = 3;</code>
     * @return \Proto\ContractCallTransactionBody|null
     */
    public function getContractCall()
    {
        return $this->readOneof(3);
    }

    public function hasContractCall()
    {
        return $this->hasOneof(3);
    }

    /**
     **
     * Call a function defined on a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCallTransactionBody contractCall = 3;</code>
     * @param \Proto\ContractCallTransactionBody $var
     * @return $this
     */
    public function setContractCall($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractCallTransactionBody::class);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     **
     * Create a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCreateTransactionBody contractCreateInstance = 4;</code>
     * @return \Proto\ContractCreateTransactionBody|null
     */
    public function getContractCreateInstance()
    {
        return $this->readOneof(4);
    }

    public function hasContractCreateInstance()
    {
        return $this->hasOneof(4);
    }

    /**
     **
     * Create a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCreateTransactionBody contractCreateInstance = 4;</code>
     * @param \Proto\ContractCreateTransactionBody $var
     * @return $this
     */
    public function setContractCreateInstance($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractCreateTransactionBody::class);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     **
     * Update a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractUpdateTransactionBody contractUpdateInstance = 5;</code>
     * @return \Proto\ContractUpdateTransactionBody|null
     */
    public function getContractUpdateInstance()
    {
        return $this->readOneof(5);
    }

    public function hasContractUpdateInstance()
    {
        return $this->hasOneof(5);
    }

    /**
     **
     * Update a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractUpdateTransactionBody contractUpdateInstance = 5;</code>
     * @param \Proto\ContractUpdateTransactionBody $var
     * @return $this
     */
    public function setContractUpdateInstance($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractUpdateTransactionBody::class);
        $this->writeOneof(5, $var);

        return $this;
    }

    /**
     **
     * Delete a smart contract and transfer remaining balance
     * to a specified account.
     *
     * Generated from protobuf field <code>.proto.ContractDeleteTransactionBody contractDeleteInstance = 6;</code>
     * @return \Proto\ContractDeleteTransactionBody|null
     */
    public function getContractDeleteInstance()
    {
        return $this->readOneof(6);
    }

    public function hasContractDeleteInstance()
    {
        return $this->hasOneof(6);
    }

    /**
     **
     * Delete a smart contract and transfer remaining balance
     * to a specified account.
     *
     * Generated from protobuf field <code>.proto.ContractDeleteTransactionBody contractDeleteInstance = 6;</code>
     * @param \Proto\ContractDeleteTransactionBody $var
     * @return $this
     */
    public function setContractDeleteInstance($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractDeleteTransactionBody::class);
        $this->writeOneof(6, $var);

        return $this;
    }

    /**
     **
     * Create a new Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoCreateTransactionBody cryptoCreateAccount = 7;</code>
     * @return \Proto\CryptoCreateTransactionBody|null
     */
    public function getCryptoCreateAccount()
    {
        return $this->readOneof(7);
    }

    public function hasCryptoCreateAccount()
    {
        return $this->hasOneof(7);
    }

    /**
     **
     * Create a new Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoCreateTransactionBody cryptoCreateAccount = 7;</code>
     * @param \Proto\CryptoCreateTransactionBody $var
     * @return $this
     */
    public function setCryptoCreateAccount($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoCreateTransactionBody::class);
        $this->writeOneof(7, $var);

        return $this;
    }

    /**
     **
     * Delete an Hedera account.<br/>
     * This will mark the account as deleted, and transfer all remaining
     * HBAR to a receiver account.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteTransactionBody cryptoDelete = 8;</code>
     * @return \Proto\CryptoDeleteTransactionBody|null
     */
    public function getCryptoDelete()
    {
        return $this->readOneof(8);
    }

    public function hasCryptoDelete()
    {
        return $this->hasOneof(8);
    }

    /**
     **
     * Delete an Hedera account.<br/>
     * This will mark the account as deleted, and transfer all remaining
     * HBAR to a receiver account.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteTransactionBody cryptoDelete = 8;</code>
     * @param \Proto\CryptoDeleteTransactionBody $var
     * @return $this
     */
    public function setCryptoDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoDeleteTransactionBody::class);
        $this->writeOneof(8, $var);

        return $this;
    }

    /**
     **
     * Transfer HBAR between accounts.
     *
     * Generated from protobuf field <code>.proto.CryptoTransferTransactionBody cryptoTransfer = 9;</code>
     * @return \Proto\CryptoTransferTransactionBody|null
     */
    public function getCryptoTransfer()
    {
        return $this->readOneof(9);
    }

    public function hasCryptoTransfer()
    {
        return $this->hasOneof(9);
    }

    /**
     **
     * Transfer HBAR between accounts.
     *
     * Generated from protobuf field <code>.proto.CryptoTransferTransactionBody cryptoTransfer = 9;</code>
     * @param \Proto\CryptoTransferTransactionBody $var
     * @return $this
     */
    public function setCryptoTransfer($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoTransferTransactionBody::class);
        $this->writeOneof(9, $var);

        return $this;
    }

    /**
     **
     * Modify an Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 10;</code>
     * @return \Proto\CryptoUpdateTransactionBody|null
     */
    public function getCryptoUpdateAccount()
    {
        return $this->readOneof(10);
    }

    public function hasCryptoUpdateAccount()
    {
        return $this->hasOneof(10);
    }

    /**
     **
     * Modify an Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 10;</code>
     * @param \Proto\CryptoUpdateTransactionBody $var
     * @return $this
     */
    public function setCryptoUpdateAccount($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoUpdateTransactionBody::class);
        $this->writeOneof(10, $var);

        return $this;
    }

    /**
     **
     * Append data to the end of a file.
     *
     * Generated from protobuf field <code>.proto.FileAppendTransactionBody fileAppend = 11;</code>
     * @return \Proto\FileAppendTransactionBody|null
     */
    public function getFileAppend()
    {
        return $this->readOneof(11);
    }

    public function hasFileAppend()
    {
        return $this->hasOneof(11);
    }

    /**
     **
     * Append data to the end of a file.
     *
     * Generated from protobuf field <code>.proto.FileAppendTransactionBody fileAppend = 11;</code>
     * @param \Proto\FileAppendTransactionBody $var
     * @return $this
     */
    public function setFileAppend($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileAppendTransactionBody::class);
        $this->writeOneof(11, $var);

        return $this;
    }

    /**
     **
     * Create a new file.
     *
     * Generated from protobuf field <code>.proto.FileCreateTransactionBody fileCreate = 12;</code>
     * @return \Proto\FileCreateTransactionBody|null
     */
    public function getFileCreate()
    {
        return $this->readOneof(12);
    }

    public function hasFileCreate()
    {
        return $this->hasOneof(12);
    }

    /**
     **
     * Create a new file.
     *
     * Generated from protobuf field <code>.proto.FileCreateTransactionBody fileCreate = 12;</code>
     * @param \Proto\FileCreateTransactionBody $var
     * @return $this
     */
    public function setFileCreate($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileCreateTransactionBody::class);
        $this->writeOneof(12, $var);

        return $this;
    }

    /**
     **
     * Delete a file.<br/>
     * This will remove the content of the file, and mark the file as
     * deleted.
     *
     * Generated from protobuf field <code>.proto.FileDeleteTransactionBody fileDelete = 13;</code>
     * @return \Proto\FileDeleteTransactionBody|null
     */
    public function getFileDelete()
    {
        return $this->readOneof(13);
    }

    public function hasFileDelete()
    {
        return $this->hasOneof(13);
    }

    /**
     **
     * Delete a file.<br/>
     * This will remove the content of the file, and mark the file as
     * deleted.
     *
     * Generated from protobuf field <code>.proto.FileDeleteTransactionBody fileDelete = 13;</code>
     * @param \Proto\FileDeleteTransactionBody $var
     * @return $this
     */
    public function setFileDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileDeleteTransactionBody::class);
        $this->writeOneof(13, $var);

        return $this;
    }

    /**
     **
     * Modify a file.<br/>
     * This may modify any metadata, and/or _replace_ the content.
     *
     * Generated from protobuf field <code>.proto.FileUpdateTransactionBody fileUpdate = 14;</code>
     * @return \Proto\FileUpdateTransactionBody|null
     */
    public function getFileUpdate()
    {
        return $this->readOneof(14);
    }

    public function hasFileUpdate()
    {
        return $this->hasOneof(14);
    }

    /**
     **
     * Modify a file.<br/>
     * This may modify any metadata, and/or _replace_ the content.
     *
     * Generated from protobuf field <code>.proto.FileUpdateTransactionBody fileUpdate = 14;</code>
     * @param \Proto\FileUpdateTransactionBody $var
     * @return $this
     */
    public function setFileUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileUpdateTransactionBody::class);
        $this->writeOneof(14, $var);

        return $this;
    }

    /**
     **
     * Delete a file as an Hedera administrative function.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemDeleteTransactionBody systemDelete = 15;</code>
     * @return \Proto\SystemDeleteTransactionBody|null
     */
    public function getSystemDelete()
    {
        return $this->readOneof(15);
    }

    public function hasSystemDelete()
    {
        return $this->hasOneof(15);
    }

    /**
     **
     * Delete a file as an Hedera administrative function.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemDeleteTransactionBody systemDelete = 15;</code>
     * @param \Proto\SystemDeleteTransactionBody $var
     * @return $this
     */
    public function setSystemDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\SystemDeleteTransactionBody::class);
        $this->writeOneof(15, $var);

        return $this;
    }

    /**
     **
     * Restore a file deleted via `systemDelete`.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemUndeleteTransactionBody systemUndelete = 16;</code>
     * @return \Proto\SystemUndeleteTransactionBody|null
     */
    public function getSystemUndelete()
    {
        return $this->readOneof(16);
    }

    public function hasSystemUndelete()
    {
        return $this->hasOneof(16);
    }

    /**
     **
     * Restore a file deleted via `systemDelete`.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemUndeleteTransactionBody systemUndelete = 16;</code>
     * @param \Proto\SystemUndeleteTransactionBody $var
     * @return $this
     */
    public function setSystemUndelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\SystemUndeleteTransactionBody::class);
        $this->writeOneof(16, $var);

        return $this;
    }

    /**
     **
     * Freeze the network.<br/>
     * This is actually several possible operations, and the caller
     * should examine the "freeze service" for more detail.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.FreezeTransactionBody freeze = 17;</code>
     * @return \Proto\FreezeTransactionBody|null
     */
    public function getFreeze()
    {
        return $this->readOneof(17);
    }

    public function hasFreeze()
    {
        return $this->hasOneof(17);
    }

    /**
     **
     * Freeze the network.<br/>
     * This is actually several possible operations, and the caller
     * should examine the "freeze service" for more detail.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.FreezeTransactionBody freeze = 17;</code>
     * @param \Proto\FreezeTransactionBody $var
     * @return $this
     */
    public function setFreeze($var)
    {
        GPBUtil::checkMessage($var, \Proto\FreezeTransactionBody::class);
        $this->writeOneof(17, $var);

        return $this;
    }

    /**
     **
     * Create a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 18;</code>
     * @return \Proto\ConsensusCreateTopicTransactionBody|null
     */
    public function getConsensusCreateTopic()
    {
        return $this->readOneof(18);
    }

    public function hasConsensusCreateTopic()
    {
        return $this->hasOneof(18);
    }

    /**
     **
     * Create a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 18;</code>
     * @param \Proto\ConsensusCreateTopicTransactionBody $var
     * @return $this
     */
    public function setConsensusCreateTopic($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusCreateTopicTransactionBody::class);
        $this->writeOneof(18, $var);

        return $this;
    }

    /**
     **
     * Update a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 19;</code>
     * @return \Proto\ConsensusUpdateTopicTransactionBody|null
     */
    public function getConsensusUpdateTopic()
    {
        return $this->readOneof(19);
    }

    public function hasConsensusUpdateTopic()
    {
        return $this->hasOneof(19);
    }

    /**
     **
     * Update a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 19;</code>
     * @param \Proto\ConsensusUpdateTopicTransactionBody $var
     * @return $this
     */
    public function setConsensusUpdateTopic($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusUpdateTopicTransactionBody::class);
        $this->writeOneof(19, $var);

        return $this;
    }

    /**
     **
     * Delete a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 20;</code>
     * @return \Proto\ConsensusDeleteTopicTransactionBody|null
     */
    public function getConsensusDeleteTopic()
    {
        return $this->readOneof(20);
    }

    public function hasConsensusDeleteTopic()
    {
        return $this->hasOneof(20);
    }

    /**
     **
     * Delete a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 20;</code>
     * @param \Proto\ConsensusDeleteTopicTransactionBody $var
     * @return $this
     */
    public function setConsensusDeleteTopic($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusDeleteTopicTransactionBody::class);
        $this->writeOneof(20, $var);

        return $this;
    }

    /**
     **
     * Submit a message to a topic.<br/>
     * A message may be "chunked", and submitted in parts, if the total
     * message size exceeds the limit for a single transaction.
     *
     * Generated from protobuf field <code>.proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 21;</code>
     * @return \Proto\ConsensusSubmitMessageTransactionBody|null
     */
    public function getConsensusSubmitMessage()
    {
        return $this->readOneof(21);
    }

    public function hasConsensusSubmitMessage()
    {
        return $this->hasOneof(21);
    }

    /**
     **
     * Submit a message to a topic.<br/>
     * A message may be "chunked", and submitted in parts, if the total
     * message size exceeds the limit for a single transaction.
     *
     * Generated from protobuf field <code>.proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 21;</code>
     * @param \Proto\ConsensusSubmitMessageTransactionBody $var
     * @return $this
     */
    public function setConsensusSubmitMessage($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusSubmitMessageTransactionBody::class);
        $this->writeOneof(21, $var);

        return $this;
    }

    /**
     **
     * Create a new Hedera token.
     *
     * Generated from protobuf field <code>.proto.TokenCreateTransactionBody tokenCreation = 22;</code>
     * @return \Proto\TokenCreateTransactionBody|null
     */
    public function getTokenCreation()
    {
        return $this->readOneof(22);
    }

    public function hasTokenCreation()
    {
        return $this->hasOneof(22);
    }

    /**
     **
     * Create a new Hedera token.
     *
     * Generated from protobuf field <code>.proto.TokenCreateTransactionBody tokenCreation = 22;</code>
     * @param \Proto\TokenCreateTransactionBody $var
     * @return $this
     */
    public function setTokenCreation($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenCreateTransactionBody::class);
        $this->writeOneof(22, $var);

        return $this;
    }

    /**
     **
     * Freeze an account with respect to a token.<br/>
     * A frozen account cannot transact in that token until unfrozen.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeAccountTransactionBody tokenFreeze = 23;</code>
     * @return \Proto\TokenFreezeAccountTransactionBody|null
     */
    public function getTokenFreeze()
    {
        return $this->readOneof(23);
    }

    public function hasTokenFreeze()
    {
        return $this->hasOneof(23);
    }

    /**
     **
     * Freeze an account with respect to a token.<br/>
     * A frozen account cannot transact in that token until unfrozen.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeAccountTransactionBody tokenFreeze = 23;</code>
     * @param \Proto\TokenFreezeAccountTransactionBody $var
     * @return $this
     */
    public function setTokenFreeze($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenFreezeAccountTransactionBody::class);
        $this->writeOneof(23, $var);

        return $this;
    }

    /**
     **
     * Unfreeze an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 24;</code>
     * @return \Proto\TokenUnfreezeAccountTransactionBody|null
     */
    public function getTokenUnfreeze()
    {
        return $this->readOneof(24);
    }

    public function hasTokenUnfreeze()
    {
        return $this->hasOneof(24);
    }

    /**
     **
     * Unfreeze an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 24;</code>
     * @param \Proto\TokenUnfreezeAccountTransactionBody $var
     * @return $this
     */
    public function setTokenUnfreeze($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUnfreezeAccountTransactionBody::class);
        $this->writeOneof(24, $var);

        return $this;
    }

    /**
     **
     * Grant KYC to an account with respect to a token.<br/>
     * KYC is generally a "know your customer" assertion that a
     * responsible entity has sufficient information to positively
     * identify the account holder to relevant authorities.
     *
     * Generated from protobuf field <code>.proto.TokenGrantKycTransactionBody tokenGrantKyc = 25;</code>
     * @return \Proto\TokenGrantKycTransactionBody|null
     */
    public function getTokenGrantKyc()
    {
        return $this->readOneof(25);
    }

    public function hasTokenGrantKyc()
    {
        return $this->hasOneof(25);
    }

    /**
     **
     * Grant KYC to an account with respect to a token.<br/>
     * KYC is generally a "know your customer" assertion that a
     * responsible entity has sufficient information to positively
     * identify the account holder to relevant authorities.
     *
     * Generated from protobuf field <code>.proto.TokenGrantKycTransactionBody tokenGrantKyc = 25;</code>
     * @param \Proto\TokenGrantKycTransactionBody $var
     * @return $this
     */
    public function setTokenGrantKyc($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenGrantKycTransactionBody::class);
        $this->writeOneof(25, $var);

        return $this;
    }

    /**
     **
     * Revoke KYC from an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 26;</code>
     * @return \Proto\TokenRevokeKycTransactionBody|null
     */
    public function getTokenRevokeKyc()
    {
        return $this->readOneof(26);
    }

    public function hasTokenRevokeKyc()
    {
        return $this->hasOneof(26);
    }

    /**
     **
     * Revoke KYC from an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 26;</code>
     * @param \Proto\TokenRevokeKycTransactionBody $var
     * @return $this
     */
    public function setTokenRevokeKyc($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenRevokeKycTransactionBody::class);
        $this->writeOneof(26, $var);

        return $this;
    }

    /**
     **
     * Deletes an Hedera token.<br/>
     * The token will be marked deleted.
     *
     * Generated from protobuf field <code>.proto.TokenDeleteTransactionBody tokenDeletion = 27;</code>
     * @return \Proto\TokenDeleteTransactionBody|null
     */
    public function getTokenDeletion()
    {
        return $this->readOneof(27);
    }

    public function hasTokenDeletion()
    {
        return $this->hasOneof(27);
    }

    /**
     **
     * Deletes an Hedera token.<br/>
     * The token will be marked deleted.
     *
     * Generated from protobuf field <code>.proto.TokenDeleteTransactionBody tokenDeletion = 27;</code>
     * @param \Proto\TokenDeleteTransactionBody $var
     * @return $this
     */
    public function setTokenDeletion($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenDeleteTransactionBody::class);
        $this->writeOneof(27, $var);

        return $this;
    }

    /**
     **
     * Update an Hedera token.<br/>
     * Depending on what fields are to be modified, the signature
     * requirements will vary. See `TokenUpdateTransactionBody` for
     * further detail.
     *
     * Generated from protobuf field <code>.proto.TokenUpdateTransactionBody tokenUpdate = 28;</code>
     * @return \Proto\TokenUpdateTransactionBody|null
     */
    public function getTokenUpdate()
    {
        return $this->readOneof(28);
    }

    public function hasTokenUpdate()
    {
        return $this->hasOneof(28);
    }

    /**
     **
     * Update an Hedera token.<br/>
     * Depending on what fields are to be modified, the signature
     * requirements will vary. See `TokenUpdateTransactionBody` for
     * further detail.
     *
     * Generated from protobuf field <code>.proto.TokenUpdateTransactionBody tokenUpdate = 28;</code>
     * @param \Proto\TokenUpdateTransactionBody $var
     * @return $this
     */
    public function setTokenUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUpdateTransactionBody::class);
        $this->writeOneof(28, $var);

        return $this;
    }

    /**
     **
     * Mint new tokens.<br/>
     * All minted tokens will be delivered to the treasury account for
     * the token type. The "mint key" for the token must sign this
     * transaction.
     *
     * Generated from protobuf field <code>.proto.TokenMintTransactionBody tokenMint = 29;</code>
     * @return \Proto\TokenMintTransactionBody|null
     */
    public function getTokenMint()
    {
        return $this->readOneof(29);
    }

    public function hasTokenMint()
    {
        return $this->hasOneof(29);
    }

    /**
     **
     * Mint new tokens.<br/>
     * All minted tokens will be delivered to the treasury account for
     * the token type. The "mint key" for the token must sign this
     * transaction.
     *
     * Generated from protobuf field <code>.proto.TokenMintTransactionBody tokenMint = 29;</code>
     * @param \Proto\TokenMintTransactionBody $var
     * @return $this
     */
    public function setTokenMint($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenMintTransactionBody::class);
        $this->writeOneof(29, $var);

        return $this;
    }

    /**
     **
     * Burn tokens from the treasury account.<br/>
     * The "burn key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenBurnTransactionBody tokenBurn = 30;</code>
     * @return \Proto\TokenBurnTransactionBody|null
     */
    public function getTokenBurn()
    {
        return $this->readOneof(30);
    }

    public function hasTokenBurn()
    {
        return $this->hasOneof(30);
    }

    /**
     **
     * Burn tokens from the treasury account.<br/>
     * The "burn key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenBurnTransactionBody tokenBurn = 30;</code>
     * @param \Proto\TokenBurnTransactionBody $var
     * @return $this
     */
    public function setTokenBurn($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenBurnTransactionBody::class);
        $this->writeOneof(30, $var);

        return $this;
    }

    /**
     **
     * Wipe tokens from an account.<br/>
     * This will remove a specified amount of fungible/common tokens or
     * a specified list of non-fungible/unique serial numbered tokens
     * of a given token type from an Hedera account. The removed tokens
     * are _burned_ as if by a `tokenBurn` transaction.<br/>
     * The "wipe key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenWipeAccountTransactionBody tokenWipe = 31;</code>
     * @return \Proto\TokenWipeAccountTransactionBody|null
     */
    public function getTokenWipe()
    {
        return $this->readOneof(31);
    }

    public function hasTokenWipe()
    {
        return $this->hasOneof(31);
    }

    /**
     **
     * Wipe tokens from an account.<br/>
     * This will remove a specified amount of fungible/common tokens or
     * a specified list of non-fungible/unique serial numbered tokens
     * of a given token type from an Hedera account. The removed tokens
     * are _burned_ as if by a `tokenBurn` transaction.<br/>
     * The "wipe key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenWipeAccountTransactionBody tokenWipe = 31;</code>
     * @param \Proto\TokenWipeAccountTransactionBody $var
     * @return $this
     */
    public function setTokenWipe($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenWipeAccountTransactionBody::class);
        $this->writeOneof(31, $var);

        return $this;
    }

    /**
     **
     * Associate tokens to an account.
     *
     * Generated from protobuf field <code>.proto.TokenAssociateTransactionBody tokenAssociate = 32;</code>
     * @return \Proto\TokenAssociateTransactionBody|null
     */
    public function getTokenAssociate()
    {
        return $this->readOneof(32);
    }

    public function hasTokenAssociate()
    {
        return $this->hasOneof(32);
    }

    /**
     **
     * Associate tokens to an account.
     *
     * Generated from protobuf field <code>.proto.TokenAssociateTransactionBody tokenAssociate = 32;</code>
     * @param \Proto\TokenAssociateTransactionBody $var
     * @return $this
     */
    public function setTokenAssociate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenAssociateTransactionBody::class);
        $this->writeOneof(32, $var);

        return $this;
    }

    /**
     **
     * Dissociate tokens from an account.
     *
     * Generated from protobuf field <code>.proto.TokenDissociateTransactionBody tokenDissociate = 33;</code>
     * @return \Proto\TokenDissociateTransactionBody|null
     */
    public function getTokenDissociate()
    {
        return $this->readOneof(33);
    }

    public function hasTokenDissociate()
    {
        return $this->hasOneof(33);
    }

    /**
     **
     * Dissociate tokens from an account.
     *
     * Generated from protobuf field <code>.proto.TokenDissociateTransactionBody tokenDissociate = 33;</code>
     * @param \Proto\TokenDissociateTransactionBody $var
     * @return $this
     */
    public function setTokenDissociate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenDissociateTransactionBody::class);
        $this->writeOneof(33, $var);

        return $this;
    }

    /**
     **
     * Delete a schedule.<br/>
     * The schedule will be marked as deleted.
     *
     * Generated from protobuf field <code>.proto.ScheduleDeleteTransactionBody scheduleDelete = 34;</code>
     * @return \Proto\ScheduleDeleteTransactionBody|null
     */
    public function getScheduleDelete()
    {
        return $this->readOneof(34);
    }

    public function hasScheduleDelete()
    {
        return $this->hasOneof(34);
    }

    /**
     **
     * Delete a schedule.<br/>
     * The schedule will be marked as deleted.
     *
     * Generated from protobuf field <code>.proto.ScheduleDeleteTransactionBody scheduleDelete = 34;</code>
     * @param \Proto\ScheduleDeleteTransactionBody $var
     * @return $this
     */
    public function setScheduleDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleDeleteTransactionBody::class);
        $this->writeOneof(34, $var);

        return $this;
    }

    /**
     **
     * Pause a Token.<br/>
     * This transaction must be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenPauseTransactionBody token_pause = 35;</code>
     * @return \Proto\TokenPauseTransactionBody|null
     */
    public function getTokenPause()
    {
        return $this->readOneof(35);
    }

    public function hasTokenPause()
    {
        return $this->hasOneof(35);
    }

    /**
     **
     * Pause a Token.<br/>
     * This transaction must be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenPauseTransactionBody token_pause = 35;</code>
     * @param \Proto\TokenPauseTransactionBody $var
     * @return $this
     */
    public function setTokenPause($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenPauseTransactionBody::class);
        $this->writeOneof(35, $var);

        return $this;
    }

    /**
     **
     * Unpause a Token.<br/>
     * This transaction must be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenUnpauseTransactionBody token_unpause = 36;</code>
     * @return \Proto\TokenUnpauseTransactionBody|null
     */
    public function getTokenUnpause()
    {
        return $this->readOneof(36);
    }

    public function hasTokenUnpause()
    {
        return $this->hasOneof(36);
    }

    /**
     **
     * Unpause a Token.<br/>
     * This transaction must be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenUnpauseTransactionBody token_unpause = 36;</code>
     * @param \Proto\TokenUnpauseTransactionBody $var
     * @return $this
     */
    public function setTokenUnpause($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUnpauseTransactionBody::class);
        $this->writeOneof(36, $var);

        return $this;
    }

    /**
     **
     * Add one or more approved allowances for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 37;</code>
     * @return \Proto\CryptoApproveAllowanceTransactionBody|null
     */
    public function getCryptoApproveAllowance()
    {
        return $this->readOneof(37);
    }

    public function hasCryptoApproveAllowance()
    {
        return $this->hasOneof(37);
    }

    /**
     **
     * Add one or more approved allowances for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 37;</code>
     * @param \Proto\CryptoApproveAllowanceTransactionBody $var
     * @return $this
     */
    public function setCryptoApproveAllowance($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoApproveAllowanceTransactionBody::class);
        $this->writeOneof(37, $var);

        return $this;
    }

    /**
     **
     * Delete one or more approvals for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 38;</code>
     * @return \Proto\CryptoDeleteAllowanceTransactionBody|null
     */
    public function getCryptoDeleteAllowance()
    {
        return $this->readOneof(38);
    }

    public function hasCryptoDeleteAllowance()
    {
        return $this->hasOneof(38);
    }

    /**
     **
     * Delete one or more approvals for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 38;</code>
     * @param \Proto\CryptoDeleteAllowanceTransactionBody $var
     * @return $this
     */
    public function setCryptoDeleteAllowance($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoDeleteAllowanceTransactionBody::class);
        $this->writeOneof(38, $var);

        return $this;
    }

    /**
     **
     * Update the custom fee schedule for a token.<br/>
     * This transaction must be signed by the "fee schedule key"
     * for the token.
     *
     * Generated from protobuf field <code>.proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 39;</code>
     * @return \Proto\TokenFeeScheduleUpdateTransactionBody|null
     */
    public function getTokenFeeScheduleUpdate()
    {
        return $this->readOneof(39);
    }

    public function hasTokenFeeScheduleUpdate()
    {
        return $this->hasOneof(39);
    }

    /**
     **
     * Update the custom fee schedule for a token.<br/>
     * This transaction must be signed by the "fee schedule key"
     * for the token.
     *
     * Generated from protobuf field <code>.proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 39;</code>
     * @param \Proto\TokenFeeScheduleUpdateTransactionBody $var
     * @return $this
     */
    public function setTokenFeeScheduleUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenFeeScheduleUpdateTransactionBody::class);
        $this->writeOneof(39, $var);

        return $this;
    }

    /**
     **
     * Provide a deterministic pseudorandom number based on network state.
     *
     * Generated from protobuf field <code>.proto.UtilPrngTransactionBody util_prng = 40;</code>
     * @return \Proto\UtilPrngTransactionBody|null
     */
    public function getUtilPrng()
    {
        return $this->readOneof(40);
    }

    public function hasUtilPrng()
    {
        return $this->hasOneof(40);
    }

    /**
     **
     * Provide a deterministic pseudorandom number based on network state.
     *
     * Generated from protobuf field <code>.proto.UtilPrngTransactionBody util_prng = 40;</code>
     * @param \Proto\UtilPrngTransactionBody $var
     * @return $this
     */
    public function setUtilPrng($var)
    {
        GPBUtil::checkMessage($var, \Proto\UtilPrngTransactionBody::class);
        $this->writeOneof(40, $var);

        return $this;
    }

    /**
     **
     * Update one or more non-fungible/unique tokens.<br/>
     * This will update metadata for one or more serial numbers within
     * a collection (token type).
     *
     * Generated from protobuf field <code>.proto.TokenUpdateNftsTransactionBody token_update_nfts = 41;</code>
     * @return \Proto\TokenUpdateNftsTransactionBody|null
     */
    public function getTokenUpdateNfts()
    {
        return $this->readOneof(41);
    }

    public function hasTokenUpdateNfts()
    {
        return $this->hasOneof(41);
    }

    /**
     **
     * Update one or more non-fungible/unique tokens.<br/>
     * This will update metadata for one or more serial numbers within
     * a collection (token type).
     *
     * Generated from protobuf field <code>.proto.TokenUpdateNftsTransactionBody token_update_nfts = 41;</code>
     * @param \Proto\TokenUpdateNftsTransactionBody $var
     * @return $this
     */
    public function setTokenUpdateNfts($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUpdateNftsTransactionBody::class);
        $this->writeOneof(41, $var);

        return $this;
    }

    /**
     **
     * Create a new node in the network address book.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody nodeCreate = 42;</code>
     * @return \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody|null
     */
    public function getNodeCreate()
    {
        return $this->readOneof(42);
    }

    public function hasNodeCreate()
    {
        return $this->hasOneof(42);
    }

    /**
     **
     * Create a new node in the network address book.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody nodeCreate = 42;</code>
     * @param \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody $var
     * @return $this
     */
    public function setNodeCreate($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody::class);
        $this->writeOneof(42, $var);

        return $this;
    }

    /**
     **
     * Update a node in the network address book.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody nodeUpdate = 43;</code>
     * @return \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody|null
     */
    public function getNodeUpdate()
    {
        return $this->readOneof(43);
    }

    public function hasNodeUpdate()
    {
        return $this->hasOneof(43);
    }

    /**
     **
     * Update a node in the network address book.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody nodeUpdate = 43;</code>
     * @param \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody $var
     * @return $this
     */
    public function setNodeUpdate($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody::class);
        $this->writeOneof(43, $var);

        return $this;
    }

    /**
     **
     * Delete a node from the network address book.<br/>
     * This will mark the node as deleted.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody nodeDelete = 44;</code>
     * @return \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody|null
     */
    public function getNodeDelete()
    {
        return $this->readOneof(44);
    }

    public function hasNodeDelete()
    {
        return $this->hasOneof(44);
    }

    /**
     **
     * Delete a node from the network address book.<br/>
     * This will mark the node as deleted.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody nodeDelete = 44;</code>
     * @param \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody $var
     * @return $this
     */
    public function setNodeDelete($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody::class);
        $this->writeOneof(44, $var);

        return $this;
    }

    /**
     **
     * "Reject" undesired tokens.<br/>
     * This transaction will transfer one or more tokens or token
     * balances held by the requesting account to the treasury
     * for each token type.
     * <p>
     * Each transfer MUST be one of the following:
     * <ul>
     *   <li>A single non-fungible/unique token.</li>
     *   <li>The full balance held for a fungible/common
     *       token type.</li>
     * </ul>
     * When complete, the requesting account SHALL NOT hold the
     * rejected tokens.<br/>
     * Custom fees and royalties defined for the tokens rejected
     * SHALL NOT be charged for this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenRejectTransactionBody tokenReject = 45;</code>
     * @return \Proto\TokenRejectTransactionBody|null
     */
    public function getTokenReject()
    {
        return $this->readOneof(45);
    }

    public function hasTokenReject()
    {
        return $this->hasOneof(45);
    }

    /**
     **
     * "Reject" undesired tokens.<br/>
     * This transaction will transfer one or more tokens or token
     * balances held by the requesting account to the treasury
     * for each token type.
     * <p>
     * Each transfer MUST be one of the following:
     * <ul>
     *   <li>A single non-fungible/unique token.</li>
     *   <li>The full balance held for a fungible/common
     *       token type.</li>
     * </ul>
     * When complete, the requesting account SHALL NOT hold the
     * rejected tokens.<br/>
     * Custom fees and royalties defined for the tokens rejected
     * SHALL NOT be charged for this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenRejectTransactionBody tokenReject = 45;</code>
     * @param \Proto\TokenRejectTransactionBody $var
     * @return $this
     */
    public function setTokenReject($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenRejectTransactionBody::class);
        $this->writeOneof(45, $var);

        return $this;
    }

    /**
     **
     * Cancel an "airdrop".<br/>
     * This transaction cancels a pending airdrop for one or more
     * recipients.
     * <p>
     * The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
     *
     * Generated from protobuf field <code>.proto.TokenCancelAirdropTransactionBody tokenCancelAirdrop = 46;</code>
     * @return \Proto\TokenCancelAirdropTransactionBody|null
     */
    public function getTokenCancelAirdrop()
    {
        return $this->readOneof(46);
    }

    public function hasTokenCancelAirdrop()
    {
        return $this->hasOneof(46);
    }

    /**
     **
     * Cancel an "airdrop".<br/>
     * This transaction cancels a pending airdrop for one or more
     * recipients.
     * <p>
     * The airdrop(s) to cancel MUST be pending, and not claimed.<br/>
     *
     * Generated from protobuf field <code>.proto.TokenCancelAirdropTransactionBody tokenCancelAirdrop = 46;</code>
     * @param \Proto\TokenCancelAirdropTransactionBody $var
     * @return $this
     */
    public function setTokenCancelAirdrop($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenCancelAirdropTransactionBody::class);
        $this->writeOneof(46, $var);

        return $this;
    }

    /**
     **
     * Claim an "airdrop".
     * This transaction "claims" one or more pending "airdrops".
     * <p>
     * The airdrop(s) to claim MUST be pending, and not
     * already claimed.<br/>
     *
     * Generated from protobuf field <code>.proto.TokenClaimAirdropTransactionBody tokenClaimAirdrop = 47;</code>
     * @return \Proto\TokenClaimAirdropTransactionBody|null
     */
    public function getTokenClaimAirdrop()
    {
        return $this->readOneof(47);
    }

    public function hasTokenClaimAirdrop()
    {
        return $this->hasOneof(47);
    }

    /**
     **
     * Claim an "airdrop".
     * This transaction "claims" one or more pending "airdrops".
     * <p>
     * The airdrop(s) to claim MUST be pending, and not
     * already claimed.<br/>
     *
     * Generated from protobuf field <code>.proto.TokenClaimAirdropTransactionBody tokenClaimAirdrop = 47;</code>
     * @param \Proto\TokenClaimAirdropTransactionBody $var
     * @return $this
     */
    public function setTokenClaimAirdrop($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenClaimAirdropTransactionBody::class);
        $this->writeOneof(47, $var);

        return $this;
    }

    /**
     **
     * Send an "airdrop" of tokens to one or more recipients.
     * <p>
     * This transaction unilaterally "gifts" tokens by transferring them
     * from a "sender" account to the "recipient" account(s). If any
     * recipient is not already associated to the token to airdrop, or
     * has set a "reciever signature required" flag, then that recipient
     * is recorded as a "pending" airdrop which must be "claimed".  All
     * other recipients receive the "airdropped" tokens immediately.
     *
     * Generated from protobuf field <code>.proto.TokenAirdropTransactionBody tokenAirdrop = 48;</code>
     * @return \Proto\TokenAirdropTransactionBody|null
     */
    public function getTokenAirdrop()
    {
        return $this->readOneof(48);
    }

    public function hasTokenAirdrop()
    {
        return $this->hasOneof(48);
    }

    /**
     **
     * Send an "airdrop" of tokens to one or more recipients.
     * <p>
     * This transaction unilaterally "gifts" tokens by transferring them
     * from a "sender" account to the "recipient" account(s). If any
     * recipient is not already associated to the token to airdrop, or
     * has set a "reciever signature required" flag, then that recipient
     * is recorded as a "pending" airdrop which must be "claimed".  All
     * other recipients receive the "airdropped" tokens immediately.
     *
     * Generated from protobuf field <code>.proto.TokenAirdropTransactionBody tokenAirdrop = 48;</code>
     * @param \Proto\TokenAirdropTransactionBody $var
     * @return $this
     */
    public function setTokenAirdrop($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenAirdropTransactionBody::class);
        $this->writeOneof(48, $var);

        return $this;
    }

    /**
     * @return string
     */
    public function getData()
    {
        return $this->whichOneof("data");
    }

}

