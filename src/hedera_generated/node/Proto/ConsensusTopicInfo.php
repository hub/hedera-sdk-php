<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: consensus_topic_info.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A query response describing the current state of a topic for the Hedera
 * Consensus Service (HCS).
 *
 * Generated from protobuf message <code>proto.ConsensusTopicInfo</code>
 */
class ConsensusTopicInfo extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A short description of this topic.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 1;</code>
     */
    protected $memo = '';
    /**
     **
     * The latest running hash of the topic.
     * <p>
     * This 48-byte field is the output of a SHA-384 digest with input
     * data determined by the current version of the running hash algorithm
     * used by the network.<br/>
     * All new transactions SHALL use algorithm version `3`.<br/>
     * The bytes of each uint64 or uint32 encoded for the hash input
     * MUST be in Big-Endian format.
     * <p>
     * <hr/>
     * If the algorithm version is '3', then the input data to the
     * SHA-384 digest are, in order:
     * <ol>
     *   <li>The previous running hash of the topic (48 bytes)</li>
     *   <li>The `topicRunningHashVersion` (8 bytes)</li>
     *   <li>The payer account's shard (8 bytes)</li>
     *   <li>The payer account's realm (8 bytes)</li>
     *   <li>The payer account's number (8 bytes)</li>
     *   <li>The topic's shard (8 bytes)</li>
     *   <li>The topic's realm (8 bytes)</li>
     *   <li>The topic's number (8 bytes)</li>
     *   <li>The number of seconds since the epoch when the
     *       `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *   <li>The number of nanoseconds within the second when the
     *       `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *   <li>The `topicSequenceNumber` (8 bytes)</li>
     *   <li>The output of a SHA-384 digest of the message bytes from the
     *       `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     *
     * Generated from protobuf field <code>bytes runningHash = 2;</code>
     */
    protected $runningHash = '';
    /**
     **
     * A current sequence number (starting at 1 for the first message)
     * for messages on this topic.
     *
     * Generated from protobuf field <code>uint64 sequenceNumber = 3;</code>
     */
    protected $sequenceNumber = 0;
    /**
     **
     * An expiration time for this topic, in seconds since the epoch.
     * <p>
     * For this purpose, `epoch` SHALL be the UNIX epoch
     * with 0 at `1970-01-01T00:00:00.000Z`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 4;</code>
     */
    protected $expirationTime = null;
    /**
     **
     * A key that MUST sign any transaction to update or delete this topic.
     * <p>
     * If this value is not set (null) then the topic CANNOT be deleted,
     * modified, or updated.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 5;</code>
     */
    protected $adminKey = null;
    /**
     **
     * A key that MUST sign any transaction to submit a message to this topic.
     * <p>
     * If this value is not set (null) then any account MAY submit messages to
     * this topic.
     *
     * Generated from protobuf field <code>.proto.Key submitKey = 6;</code>
     */
    protected $submitKey = null;
    /**
     **
     * A duration, in seconds, to extend the `expirationTime` value when
     * this topic is automatically renewed.
     * <p>
     * If the `autoRenewAccount` value for this topic is set to a valid account
     * with sufficient HBAR balance to pay renewal fees when this topic
     * expires, the system SHALL automatically renew this topic, extending the
     * `expirationTime` value by the number of seconds described here.<br/>
     * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
     * to pay renewal fees when this topic expires, this topic SHALL be
     * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
     * configuration value.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 7;</code>
     */
    protected $autoRenewPeriod = null;
    /**
     **
     * An account that is designated to pay automatic renewal fees.
     * <p>
     * If this value is a valid account ID when this topic expires,
     * this account SHALL be charged the renewal fees for this topic,
     * if it holds sufficient HBAR balance. If the account does not hold
     * sufficient HBAR balance to pay renewal fees when necessary, then
     * this topic SHALL be deleted.<br/>
     * If this value is not set (null), or is not a valid account ID, when
     * this topic expires, then this topic SHALL be deleted after the time
     * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
     *
     * Generated from protobuf field <code>.proto.AccountID autoRenewAccount = 8;</code>
     */
    protected $autoRenewAccount = null;
    /**
     **
     * A ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 9;</code>
     */
    protected $ledger_id = '';
    /**
     **
     * Access control for update/delete of custom fees.
     * <p>
     * If unset, custom fees CANNOT be set for this topic.<br/>
     * If not set when the topic is created, this field CANNOT be set via
     * update.<br/>
     * If set when the topic is created, this field MAY be changed via update.
     *
     * Generated from protobuf field <code>.proto.Key fee_schedule_key = 10;</code>
     */
    protected $fee_schedule_key = null;
    /**
     **
     * A set of keys.<br/>
     * Keys in this list are permitted to submit messages to this topic without
     * paying custom fees associated with this topic.
     * <p>
     * If a topic submit message is signed by _any_ key included in this set,
     * custom fees SHALL NOT be charged for that transaction.<br/>
     * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
     * deleted, or non-existent.<br/>
     * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
     * following keys SHALL NOT be implicitly or automatically added to this
     * list: `adminKey`, `submitKey`, `fee_schedule_key`.
     * A `fee_exempt_key_list` MUST NOT contain more than
     * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
     * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
     *
     * Generated from protobuf field <code>repeated .proto.Key fee_exempt_key_list = 11;</code>
     */
    private $fee_exempt_key_list;
    /**
     **
     * A set of custom fee definitions.<br/>
     * These are fees to be assessed for each submit to this topic.
     * <p>
     * Each fee defined in this set SHALL be evaluated for
     * each message submitted to this topic, and the resultant
     * total assessed fees SHALL be charged.<br/>
     * Custom fees defined here SHALL be assessed in addition to the base
     * network and node fees.
     *
     * Generated from protobuf field <code>repeated .proto.FixedCustomFee custom_fees = 12;</code>
     */
    private $custom_fees;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $memo
     *          *
     *           A short description of this topic.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type string $runningHash
     *          *
     *           The latest running hash of the topic.
     *           <p>
     *           This 48-byte field is the output of a SHA-384 digest with input
     *           data determined by the current version of the running hash algorithm
     *           used by the network.<br/>
     *           All new transactions SHALL use algorithm version `3`.<br/>
     *           The bytes of each uint64 or uint32 encoded for the hash input
     *           MUST be in Big-Endian format.
     *           <p>
     *           <hr/>
     *           If the algorithm version is '3', then the input data to the
     *           SHA-384 digest are, in order:
     *           <ol>
     *             <li>The previous running hash of the topic (48 bytes)</li>
     *             <li>The `topicRunningHashVersion` (8 bytes)</li>
     *             <li>The payer account's shard (8 bytes)</li>
     *             <li>The payer account's realm (8 bytes)</li>
     *             <li>The payer account's number (8 bytes)</li>
     *             <li>The topic's shard (8 bytes)</li>
     *             <li>The topic's realm (8 bytes)</li>
     *             <li>The topic's number (8 bytes)</li>
     *             <li>The number of seconds since the epoch when the
     *                 `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *             <li>The number of nanoseconds within the second when the
     *                 `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *             <li>The `topicSequenceNumber` (8 bytes)</li>
     *             <li>The output of a SHA-384 digest of the message bytes from the
     *                 `ConsensusSubmitMessage` (48 bytes)</li>
     *           </ol>
     *     @type int|string $sequenceNumber
     *          *
     *           A current sequence number (starting at 1 for the first message)
     *           for messages on this topic.
     *     @type \Proto\Timestamp $expirationTime
     *          *
     *           An expiration time for this topic, in seconds since the epoch.
     *           <p>
     *           For this purpose, `epoch` SHALL be the UNIX epoch
     *           with 0 at `1970-01-01T00:00:00.000Z`.
     *     @type \Proto\Key $adminKey
     *          *
     *           A key that MUST sign any transaction to update or delete this topic.
     *           <p>
     *           If this value is not set (null) then the topic CANNOT be deleted,
     *           modified, or updated.
     *     @type \Proto\Key $submitKey
     *          *
     *           A key that MUST sign any transaction to submit a message to this topic.
     *           <p>
     *           If this value is not set (null) then any account MAY submit messages to
     *           this topic.
     *     @type \Proto\Duration $autoRenewPeriod
     *          *
     *           A duration, in seconds, to extend the `expirationTime` value when
     *           this topic is automatically renewed.
     *           <p>
     *           If the `autoRenewAccount` value for this topic is set to a valid account
     *           with sufficient HBAR balance to pay renewal fees when this topic
     *           expires, the system SHALL automatically renew this topic, extending the
     *           `expirationTime` value by the number of seconds described here.<br/>
     *           If, however, the `autoRenewAccount` lacks sufficient HBAR balance
     *           to pay renewal fees when this topic expires, this topic SHALL be
     *           deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
     *           configuration value.
     *     @type \Proto\AccountID $autoRenewAccount
     *          *
     *           An account that is designated to pay automatic renewal fees.
     *           <p>
     *           If this value is a valid account ID when this topic expires,
     *           this account SHALL be charged the renewal fees for this topic,
     *           if it holds sufficient HBAR balance. If the account does not hold
     *           sufficient HBAR balance to pay renewal fees when necessary, then
     *           this topic SHALL be deleted.<br/>
     *           If this value is not set (null), or is not a valid account ID, when
     *           this topic expires, then this topic SHALL be deleted after the time
     *           period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
     *     @type string $ledger_id
     *          *
     *           A ledger ID of the network that generated this response.
     *           <p>
     *           This value SHALL identify the distributed ledger that responded to
     *           this query.
     *     @type \Proto\Key $fee_schedule_key
     *          *
     *           Access control for update/delete of custom fees.
     *           <p>
     *           If unset, custom fees CANNOT be set for this topic.<br/>
     *           If not set when the topic is created, this field CANNOT be set via
     *           update.<br/>
     *           If set when the topic is created, this field MAY be changed via update.
     *     @type \Proto\Key[] $fee_exempt_key_list
     *          *
     *           A set of keys.<br/>
     *           Keys in this list are permitted to submit messages to this topic without
     *           paying custom fees associated with this topic.
     *           <p>
     *           If a topic submit message is signed by _any_ key included in this set,
     *           custom fees SHALL NOT be charged for that transaction.<br/>
     *           `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
     *           deleted, or non-existent.<br/>
     *           If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
     *           following keys SHALL NOT be implicitly or automatically added to this
     *           list: `adminKey`, `submitKey`, `fee_schedule_key`.
     *           A `fee_exempt_key_list` MUST NOT contain more than
     *           `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
     *           A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
     *     @type \Proto\FixedCustomFee[] $custom_fees
     *          *
     *           A set of custom fee definitions.<br/>
     *           These are fees to be assessed for each submit to this topic.
     *           <p>
     *           Each fee defined in this set SHALL be evaluated for
     *           each message submitted to this topic, and the resultant
     *           total assessed fees SHALL be charged.<br/>
     *           Custom fees defined here SHALL be assessed in addition to the base
     *           network and node fees.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ConsensusTopicInfo::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A short description of this topic.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 1;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description of this topic.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * The latest running hash of the topic.
     * <p>
     * This 48-byte field is the output of a SHA-384 digest with input
     * data determined by the current version of the running hash algorithm
     * used by the network.<br/>
     * All new transactions SHALL use algorithm version `3`.<br/>
     * The bytes of each uint64 or uint32 encoded for the hash input
     * MUST be in Big-Endian format.
     * <p>
     * <hr/>
     * If the algorithm version is '3', then the input data to the
     * SHA-384 digest are, in order:
     * <ol>
     *   <li>The previous running hash of the topic (48 bytes)</li>
     *   <li>The `topicRunningHashVersion` (8 bytes)</li>
     *   <li>The payer account's shard (8 bytes)</li>
     *   <li>The payer account's realm (8 bytes)</li>
     *   <li>The payer account's number (8 bytes)</li>
     *   <li>The topic's shard (8 bytes)</li>
     *   <li>The topic's realm (8 bytes)</li>
     *   <li>The topic's number (8 bytes)</li>
     *   <li>The number of seconds since the epoch when the
     *       `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *   <li>The number of nanoseconds within the second when the
     *       `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *   <li>The `topicSequenceNumber` (8 bytes)</li>
     *   <li>The output of a SHA-384 digest of the message bytes from the
     *       `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     *
     * Generated from protobuf field <code>bytes runningHash = 2;</code>
     * @return string
     */
    public function getRunningHash()
    {
        return $this->runningHash;
    }

    /**
     **
     * The latest running hash of the topic.
     * <p>
     * This 48-byte field is the output of a SHA-384 digest with input
     * data determined by the current version of the running hash algorithm
     * used by the network.<br/>
     * All new transactions SHALL use algorithm version `3`.<br/>
     * The bytes of each uint64 or uint32 encoded for the hash input
     * MUST be in Big-Endian format.
     * <p>
     * <hr/>
     * If the algorithm version is '3', then the input data to the
     * SHA-384 digest are, in order:
     * <ol>
     *   <li>The previous running hash of the topic (48 bytes)</li>
     *   <li>The `topicRunningHashVersion` (8 bytes)</li>
     *   <li>The payer account's shard (8 bytes)</li>
     *   <li>The payer account's realm (8 bytes)</li>
     *   <li>The payer account's number (8 bytes)</li>
     *   <li>The topic's shard (8 bytes)</li>
     *   <li>The topic's realm (8 bytes)</li>
     *   <li>The topic's number (8 bytes)</li>
     *   <li>The number of seconds since the epoch when the
     *       `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *   <li>The number of nanoseconds within the second when the
     *       `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *   <li>The `topicSequenceNumber` (8 bytes)</li>
     *   <li>The output of a SHA-384 digest of the message bytes from the
     *       `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     *
     * Generated from protobuf field <code>bytes runningHash = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setRunningHash($var)
    {
        GPBUtil::checkString($var, False);
        $this->runningHash = $var;

        return $this;
    }

    /**
     **
     * A current sequence number (starting at 1 for the first message)
     * for messages on this topic.
     *
     * Generated from protobuf field <code>uint64 sequenceNumber = 3;</code>
     * @return int|string
     */
    public function getSequenceNumber()
    {
        return $this->sequenceNumber;
    }

    /**
     **
     * A current sequence number (starting at 1 for the first message)
     * for messages on this topic.
     *
     * Generated from protobuf field <code>uint64 sequenceNumber = 3;</code>
     * @param int|string $var
     * @return $this
     */
    public function setSequenceNumber($var)
    {
        GPBUtil::checkUint64($var);
        $this->sequenceNumber = $var;

        return $this;
    }

    /**
     **
     * An expiration time for this topic, in seconds since the epoch.
     * <p>
     * For this purpose, `epoch` SHALL be the UNIX epoch
     * with 0 at `1970-01-01T00:00:00.000Z`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 4;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExpirationTime()
    {
        return $this->expirationTime;
    }

    public function hasExpirationTime()
    {
        return isset($this->expirationTime);
    }

    public function clearExpirationTime()
    {
        unset($this->expirationTime);
    }

    /**
     **
     * An expiration time for this topic, in seconds since the epoch.
     * <p>
     * For this purpose, `epoch` SHALL be the UNIX epoch
     * with 0 at `1970-01-01T00:00:00.000Z`.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 4;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExpirationTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->expirationTime = $var;

        return $this;
    }

    /**
     **
     * A key that MUST sign any transaction to update or delete this topic.
     * <p>
     * If this value is not set (null) then the topic CANNOT be deleted,
     * modified, or updated.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 5;</code>
     * @return \Proto\Key|null
     */
    public function getAdminKey()
    {
        return $this->adminKey;
    }

    public function hasAdminKey()
    {
        return isset($this->adminKey);
    }

    public function clearAdminKey()
    {
        unset($this->adminKey);
    }

    /**
     **
     * A key that MUST sign any transaction to update or delete this topic.
     * <p>
     * If this value is not set (null) then the topic CANNOT be deleted,
     * modified, or updated.
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 5;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setAdminKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->adminKey = $var;

        return $this;
    }

    /**
     **
     * A key that MUST sign any transaction to submit a message to this topic.
     * <p>
     * If this value is not set (null) then any account MAY submit messages to
     * this topic.
     *
     * Generated from protobuf field <code>.proto.Key submitKey = 6;</code>
     * @return \Proto\Key|null
     */
    public function getSubmitKey()
    {
        return $this->submitKey;
    }

    public function hasSubmitKey()
    {
        return isset($this->submitKey);
    }

    public function clearSubmitKey()
    {
        unset($this->submitKey);
    }

    /**
     **
     * A key that MUST sign any transaction to submit a message to this topic.
     * <p>
     * If this value is not set (null) then any account MAY submit messages to
     * this topic.
     *
     * Generated from protobuf field <code>.proto.Key submitKey = 6;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setSubmitKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->submitKey = $var;

        return $this;
    }

    /**
     **
     * A duration, in seconds, to extend the `expirationTime` value when
     * this topic is automatically renewed.
     * <p>
     * If the `autoRenewAccount` value for this topic is set to a valid account
     * with sufficient HBAR balance to pay renewal fees when this topic
     * expires, the system SHALL automatically renew this topic, extending the
     * `expirationTime` value by the number of seconds described here.<br/>
     * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
     * to pay renewal fees when this topic expires, this topic SHALL be
     * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
     * configuration value.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 7;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->autoRenewPeriod;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->autoRenewPeriod);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->autoRenewPeriod);
    }

    /**
     **
     * A duration, in seconds, to extend the `expirationTime` value when
     * this topic is automatically renewed.
     * <p>
     * If the `autoRenewAccount` value for this topic is set to a valid account
     * with sufficient HBAR balance to pay renewal fees when this topic
     * expires, the system SHALL automatically renew this topic, extending the
     * `expirationTime` value by the number of seconds described here.<br/>
     * If, however, the `autoRenewAccount` lacks sufficient HBAR balance
     * to pay renewal fees when this topic expires, this topic SHALL be
     * deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
     * configuration value.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 7;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->autoRenewPeriod = $var;

        return $this;
    }

    /**
     **
     * An account that is designated to pay automatic renewal fees.
     * <p>
     * If this value is a valid account ID when this topic expires,
     * this account SHALL be charged the renewal fees for this topic,
     * if it holds sufficient HBAR balance. If the account does not hold
     * sufficient HBAR balance to pay renewal fees when necessary, then
     * this topic SHALL be deleted.<br/>
     * If this value is not set (null), or is not a valid account ID, when
     * this topic expires, then this topic SHALL be deleted after the time
     * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
     *
     * Generated from protobuf field <code>.proto.AccountID autoRenewAccount = 8;</code>
     * @return \Proto\AccountID|null
     */
    public function getAutoRenewAccount()
    {
        return $this->autoRenewAccount;
    }

    public function hasAutoRenewAccount()
    {
        return isset($this->autoRenewAccount);
    }

    public function clearAutoRenewAccount()
    {
        unset($this->autoRenewAccount);
    }

    /**
     **
     * An account that is designated to pay automatic renewal fees.
     * <p>
     * If this value is a valid account ID when this topic expires,
     * this account SHALL be charged the renewal fees for this topic,
     * if it holds sufficient HBAR balance. If the account does not hold
     * sufficient HBAR balance to pay renewal fees when necessary, then
     * this topic SHALL be deleted.<br/>
     * If this value is not set (null), or is not a valid account ID, when
     * this topic expires, then this topic SHALL be deleted after the time
     * period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
     *
     * Generated from protobuf field <code>.proto.AccountID autoRenewAccount = 8;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAutoRenewAccount($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->autoRenewAccount = $var;

        return $this;
    }

    /**
     **
     * A ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 9;</code>
     * @return string
     */
    public function getLedgerId()
    {
        return $this->ledger_id;
    }

    /**
     **
     * A ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 9;</code>
     * @param string $var
     * @return $this
     */
    public function setLedgerId($var)
    {
        GPBUtil::checkString($var, False);
        $this->ledger_id = $var;

        return $this;
    }

    /**
     **
     * Access control for update/delete of custom fees.
     * <p>
     * If unset, custom fees CANNOT be set for this topic.<br/>
     * If not set when the topic is created, this field CANNOT be set via
     * update.<br/>
     * If set when the topic is created, this field MAY be changed via update.
     *
     * Generated from protobuf field <code>.proto.Key fee_schedule_key = 10;</code>
     * @return \Proto\Key|null
     */
    public function getFeeScheduleKey()
    {
        return $this->fee_schedule_key;
    }

    public function hasFeeScheduleKey()
    {
        return isset($this->fee_schedule_key);
    }

    public function clearFeeScheduleKey()
    {
        unset($this->fee_schedule_key);
    }

    /**
     **
     * Access control for update/delete of custom fees.
     * <p>
     * If unset, custom fees CANNOT be set for this topic.<br/>
     * If not set when the topic is created, this field CANNOT be set via
     * update.<br/>
     * If set when the topic is created, this field MAY be changed via update.
     *
     * Generated from protobuf field <code>.proto.Key fee_schedule_key = 10;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setFeeScheduleKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->fee_schedule_key = $var;

        return $this;
    }

    /**
     **
     * A set of keys.<br/>
     * Keys in this list are permitted to submit messages to this topic without
     * paying custom fees associated with this topic.
     * <p>
     * If a topic submit message is signed by _any_ key included in this set,
     * custom fees SHALL NOT be charged for that transaction.<br/>
     * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
     * deleted, or non-existent.<br/>
     * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
     * following keys SHALL NOT be implicitly or automatically added to this
     * list: `adminKey`, `submitKey`, `fee_schedule_key`.
     * A `fee_exempt_key_list` MUST NOT contain more than
     * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
     * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
     *
     * Generated from protobuf field <code>repeated .proto.Key fee_exempt_key_list = 11;</code>
     * @return RepeatedField<\Proto\Key>
     */
    public function getFeeExemptKeyList()
    {
        return $this->fee_exempt_key_list;
    }

    /**
     **
     * A set of keys.<br/>
     * Keys in this list are permitted to submit messages to this topic without
     * paying custom fees associated with this topic.
     * <p>
     * If a topic submit message is signed by _any_ key included in this set,
     * custom fees SHALL NOT be charged for that transaction.<br/>
     * `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
     * deleted, or non-existent.<br/>
     * If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
     * following keys SHALL NOT be implicitly or automatically added to this
     * list: `adminKey`, `submitKey`, `fee_schedule_key`.
     * A `fee_exempt_key_list` MUST NOT contain more than
     * `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
     * A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
     *
     * Generated from protobuf field <code>repeated .proto.Key fee_exempt_key_list = 11;</code>
     * @param \Proto\Key[] $var
     * @return $this
     */
    public function setFeeExemptKeyList($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\Key::class);
        $this->fee_exempt_key_list = $arr;

        return $this;
    }

    /**
     **
     * A set of custom fee definitions.<br/>
     * These are fees to be assessed for each submit to this topic.
     * <p>
     * Each fee defined in this set SHALL be evaluated for
     * each message submitted to this topic, and the resultant
     * total assessed fees SHALL be charged.<br/>
     * Custom fees defined here SHALL be assessed in addition to the base
     * network and node fees.
     *
     * Generated from protobuf field <code>repeated .proto.FixedCustomFee custom_fees = 12;</code>
     * @return RepeatedField<\Proto\FixedCustomFee>
     */
    public function getCustomFees()
    {
        return $this->custom_fees;
    }

    /**
     **
     * A set of custom fee definitions.<br/>
     * These are fees to be assessed for each submit to this topic.
     * <p>
     * Each fee defined in this set SHALL be evaluated for
     * each message submitted to this topic, and the resultant
     * total assessed fees SHALL be charged.<br/>
     * Custom fees defined here SHALL be assessed in addition to the base
     * network and node fees.
     *
     * Generated from protobuf field <code>repeated .proto.FixedCustomFee custom_fees = 12;</code>
     * @param \Proto\FixedCustomFee[] $var
     * @return $this
     */
    public function setCustomFees($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\FixedCustomFee::class);
        $this->custom_fees = $arr;

        return $this;
    }

}

