<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: crypto_get_info.proto

namespace Proto\CryptoGetInfoResponse;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Information describing A single Account in the Hedera distributed ledger.
 * #### Attributes
 * Each Account may have a unique three-part identifier, a Key, and one or
 * more token balances. Accounts also have an alias, which has multiple
 * forms, and may be set automatically. Several additional items are
 * associated with the Account to enable full functionality.
 * #### Expiration
 * Accounts, as most items in the network, have an expiration time, recorded
 * as a `Timestamp`, and must be "renewed" for a small fee at expiration.
 * This helps to reduce the amount of inactive accounts retained in state.
 * Another account may be designated to pay any renewal fees and
 * automatically renew the account for (by default) 30-90 days at a time as
 * a means to optionally ensure important accounts remain active.
 * ### Staking
 * Accounts may participate in securing the network by "staking" the account
 * balances to a particular network node, and receive a portion of network
 * fees as a reward. An account may optionally decline these rewards but
 * still stake its balances.
 * #### Transfer Restrictions
 * An account may optionally require that inbound transfer transactions be
 * signed by that account as receiver (in addition to any other signatures
 * required, including sender).
 *
 * Generated from protobuf message <code>proto.CryptoGetInfoResponse.AccountInfo</code>
 */
class AccountInfo extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * a unique identifier for this account.
     * <p>
     * An account identifier, when assigned to this field, SHALL be of
     * the form `shard.realm.number`.
     *
     * Generated from protobuf field <code>.proto.AccountID accountID = 1;</code>
     */
    protected $accountID = null;
    /**
     **
     * A Solidity ID.
     * <p>
     * This SHALL be populated if this account is a smart contract, and
     * SHALL NOT be populated otherwise.<br/>
     * This SHALL be formatted as a string according to Solidity ID
     * standards.
     *
     * Generated from protobuf field <code>string contractAccountID = 2;</code>
     */
    protected $contractAccountID = '';
    /**
     **
     * A boolean indicating that this account is deleted.
     * <p>
     * Any transaction involving a deleted account SHALL fail.
     *
     * Generated from protobuf field <code>bool deleted = 3;</code>
     */
    protected $deleted = false;
    /**
     **
     * Replaced by StakingInfo.<br/>
     * ID of the account to which this account is staking its balances. If
     * this account is not currently staking its balances, then this field,
     * if set, SHALL be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 4 [deprecated = true];</code>
     * @deprecated
     */
    protected $proxyAccountID = null;
    /**
     **
     * Replaced by StakingInfo.<br/>
     * The total amount of tinybar proxy staked to this account.
     *
     * Generated from protobuf field <code>int64 proxyReceived = 6 [deprecated = true];</code>
     * @deprecated
     */
    protected $proxyReceived = 0;
    /**
     **
     * The key to be used to sign transactions from this account, if any.
     * <p>
     * This key SHALL NOT be set for hollow accounts until the account
     * is finalized.<br/>
     * This key SHALL be set on all other accounts, except for certain
     * immutable accounts (0.0.800 and 0.0.801) necessary for network
     * function and otherwise secured by the governing council.
     *
     * Generated from protobuf field <code>.proto.Key key = 7;</code>
     */
    protected $key = null;
    /**
     **
     * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     * <p>
     * This value SHALL always be a whole number.
     *
     * Generated from protobuf field <code>uint64 balance = 8;</code>
     */
    protected $balance = 0;
    /**
     **
     * Obsolete and unused.<br/>
     * The threshold amount, in tinybars, at which a record was created for
     * any transaction that decreased the balance of this account.
     *
     * Generated from protobuf field <code>uint64 generateSendRecordThreshold = 9 [deprecated = true];</code>
     * @deprecated
     */
    protected $generateSendRecordThreshold = 0;
    /**
     **
     * Obsolete and unused.<br/>
     * The threshold amount, in tinybars, at which a record was created for
     * any transaction that increased the balance of this account.
     *
     * Generated from protobuf field <code>uint64 generateReceiveRecordThreshold = 10 [deprecated = true];</code>
     * @deprecated
     */
    protected $generateReceiveRecordThreshold = 0;
    /**
     **
     * A boolean indicating that the account requires a receiver signature
     * for inbound token transfer transactions.
     * <p>
     * If this value is `true` then a transaction to transfer tokens to this
     * account SHALL NOT succeed unless this account has signed the
     * transfer transaction.
     *
     * Generated from protobuf field <code>bool receiverSigRequired = 11;</code>
     */
    protected $receiverSigRequired = false;
    /**
     **
     * The current expiration time for this account.
     * <p>
     * This account SHALL be due standard renewal fees when the network
     * consensus time exceeds this time.<br/>
     * If rent and expiration are enabled for the network, and automatic
     * renewal is enabled for this account, renewal fees SHALL be charged
     * after this time, and, if charged, the expiration time SHALL be
     * extended for another renewal period.<br/>
     * This account MAY be expired and removed from state at any point
     * after this time if not renewed.<br/>
     * An account holder MAY extend this time by submitting an account
     * update transaction to modify expiration time, subject to the current
     * maximum expiration time for the network.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 12;</code>
     */
    protected $expirationTime = null;
    /**
     **
     * A duration to extend this account's expiration.
     * <p>
     * The network SHALL extend the account's expiration by this
     * duration, if funds are available, upon automatic renewal.<br/>
     * This SHALL NOT apply if the account is already deleted
     * upon expiration.<br/>
     * If this is not provided in an allowed range on account creation, the
     * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     * values for the minimum period and maximum period are currently
     * 30 days and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 13;</code>
     */
    protected $autoRenewPeriod = null;
    /**
     **
     * All of the livehashes attached to the account (each of which is a
     * hash along with the keys that authorized it and can delete it)
     *
     * Generated from protobuf field <code>repeated .proto.LiveHash liveHashes = 14;</code>
     */
    private $liveHashes;
    /**
     **
     * As of `HIP-367`, which enabled unlimited token associations, the
     * potential scale for this value requires that users consult a mirror
     * node for this information.
     *
     * Generated from protobuf field <code>repeated .proto.TokenRelationship tokenRelationships = 15 [deprecated = true];</code>
     * @deprecated
     */
    private $tokenRelationships;
    /**
     **
     * A short description of this account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 16;</code>
     */
    protected $memo = '';
    /**
     **
     * The total number of non-fungible/unique tokens owned by this account.
     *
     * Generated from protobuf field <code>int64 ownedNfts = 17;</code>
     */
    protected $ownedNfts = 0;
    /**
     **
     * The maximum number of tokens that can be auto-associated with the
     * account.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0),
     * then this account MUST manually associate with a token before
     * transacting in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no
     * limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 18;</code>
     */
    protected $max_automatic_token_associations = 0;
    /**
     **
     * An account alias.<br/>
     * This is a value used in some contexts to reference an account when
     * the tripartite account identifier is not available.
     * <p>
     * This field, when set to a non-default value, is immutable and
     * SHALL NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 19;</code>
     */
    protected $alias = '';
    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 20;</code>
     */
    protected $ledger_id = '';
    /**
     **
     * The ethereum transaction nonce associated with this account.
     *
     * Generated from protobuf field <code>int64 ethereum_nonce = 21;</code>
     */
    protected $ethereum_nonce = 0;
    /**
     **
     * Staking information for this account.
     *
     * Generated from protobuf field <code>.proto.StakingInfo staking_info = 22;</code>
     */
    protected $staking_info = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\AccountID $accountID
     *          *
     *           a unique identifier for this account.
     *           <p>
     *           An account identifier, when assigned to this field, SHALL be of
     *           the form `shard.realm.number`.
     *     @type string $contractAccountID
     *          *
     *           A Solidity ID.
     *           <p>
     *           This SHALL be populated if this account is a smart contract, and
     *           SHALL NOT be populated otherwise.<br/>
     *           This SHALL be formatted as a string according to Solidity ID
     *           standards.
     *     @type bool $deleted
     *          *
     *           A boolean indicating that this account is deleted.
     *           <p>
     *           Any transaction involving a deleted account SHALL fail.
     *     @type \Proto\AccountID $proxyAccountID
     *          *
     *           Replaced by StakingInfo.<br/>
     *           ID of the account to which this account is staking its balances. If
     *           this account is not currently staking its balances, then this field,
     *           if set, SHALL be the sentinel value of `0.0.0`.
     *     @type int|string $proxyReceived
     *          *
     *           Replaced by StakingInfo.<br/>
     *           The total amount of tinybar proxy staked to this account.
     *     @type \Proto\Key $key
     *          *
     *           The key to be used to sign transactions from this account, if any.
     *           <p>
     *           This key SHALL NOT be set for hollow accounts until the account
     *           is finalized.<br/>
     *           This key SHALL be set on all other accounts, except for certain
     *           immutable accounts (0.0.800 and 0.0.801) necessary for network
     *           function and otherwise secured by the governing council.
     *     @type int|string $balance
     *          *
     *           The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     *           <p>
     *           This value SHALL always be a whole number.
     *     @type int|string $generateSendRecordThreshold
     *          *
     *           Obsolete and unused.<br/>
     *           The threshold amount, in tinybars, at which a record was created for
     *           any transaction that decreased the balance of this account.
     *     @type int|string $generateReceiveRecordThreshold
     *          *
     *           Obsolete and unused.<br/>
     *           The threshold amount, in tinybars, at which a record was created for
     *           any transaction that increased the balance of this account.
     *     @type bool $receiverSigRequired
     *          *
     *           A boolean indicating that the account requires a receiver signature
     *           for inbound token transfer transactions.
     *           <p>
     *           If this value is `true` then a transaction to transfer tokens to this
     *           account SHALL NOT succeed unless this account has signed the
     *           transfer transaction.
     *     @type \Proto\Timestamp $expirationTime
     *          *
     *           The current expiration time for this account.
     *           <p>
     *           This account SHALL be due standard renewal fees when the network
     *           consensus time exceeds this time.<br/>
     *           If rent and expiration are enabled for the network, and automatic
     *           renewal is enabled for this account, renewal fees SHALL be charged
     *           after this time, and, if charged, the expiration time SHALL be
     *           extended for another renewal period.<br/>
     *           This account MAY be expired and removed from state at any point
     *           after this time if not renewed.<br/>
     *           An account holder MAY extend this time by submitting an account
     *           update transaction to modify expiration time, subject to the current
     *           maximum expiration time for the network.
     *     @type \Proto\Duration $autoRenewPeriod
     *          *
     *           A duration to extend this account's expiration.
     *           <p>
     *           The network SHALL extend the account's expiration by this
     *           duration, if funds are available, upon automatic renewal.<br/>
     *           This SHALL NOT apply if the account is already deleted
     *           upon expiration.<br/>
     *           If this is not provided in an allowed range on account creation, the
     *           transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     *           values for the minimum period and maximum period are currently
     *           30 days and 90 days, respectively.
     *     @type \Proto\LiveHash[] $liveHashes
     *          *
     *           All of the livehashes attached to the account (each of which is a
     *           hash along with the keys that authorized it and can delete it)
     *     @type \Proto\TokenRelationship[] $tokenRelationships
     *          *
     *           As of `HIP-367`, which enabled unlimited token associations, the
     *           potential scale for this value requires that users consult a mirror
     *           node for this information.
     *     @type string $memo
     *          *
     *           A short description of this account.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type int|string $ownedNfts
     *          *
     *           The total number of non-fungible/unique tokens owned by this account.
     *     @type int $max_automatic_token_associations
     *          *
     *           The maximum number of tokens that can be auto-associated with the
     *           account.
     *           <p>
     *           If this is less than or equal to `used_auto_associations` (or 0),
     *           then this account MUST manually associate with a token before
     *           transacting in that token.<br/>
     *           Following HIP-904 This value may also be `-1` to indicate no
     *           limit.<br/>
     *           This value MUST NOT be less than `-1`.
     *     @type string $alias
     *          *
     *           An account alias.<br/>
     *           This is a value used in some contexts to reference an account when
     *           the tripartite account identifier is not available.
     *           <p>
     *           This field, when set to a non-default value, is immutable and
     *           SHALL NOT be changed.
     *     @type string $ledger_id
     *          *
     *           The ledger ID of the network that generated this response.
     *           <p>
     *           This value SHALL identify the distributed ledger that responded to
     *           this query.
     *     @type int|string $ethereum_nonce
     *          *
     *           The ethereum transaction nonce associated with this account.
     *     @type \Proto\StakingInfo $staking_info
     *          *
     *           Staking information for this account.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\CryptoGetInfo::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * a unique identifier for this account.
     * <p>
     * An account identifier, when assigned to this field, SHALL be of
     * the form `shard.realm.number`.
     *
     * Generated from protobuf field <code>.proto.AccountID accountID = 1;</code>
     * @return \Proto\AccountID|null
     */
    public function getAccountID()
    {
        return $this->accountID;
    }

    public function hasAccountID()
    {
        return isset($this->accountID);
    }

    public function clearAccountID()
    {
        unset($this->accountID);
    }

    /**
     **
     * a unique identifier for this account.
     * <p>
     * An account identifier, when assigned to this field, SHALL be of
     * the form `shard.realm.number`.
     *
     * Generated from protobuf field <code>.proto.AccountID accountID = 1;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAccountID($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->accountID = $var;

        return $this;
    }

    /**
     **
     * A Solidity ID.
     * <p>
     * This SHALL be populated if this account is a smart contract, and
     * SHALL NOT be populated otherwise.<br/>
     * This SHALL be formatted as a string according to Solidity ID
     * standards.
     *
     * Generated from protobuf field <code>string contractAccountID = 2;</code>
     * @return string
     */
    public function getContractAccountID()
    {
        return $this->contractAccountID;
    }

    /**
     **
     * A Solidity ID.
     * <p>
     * This SHALL be populated if this account is a smart contract, and
     * SHALL NOT be populated otherwise.<br/>
     * This SHALL be formatted as a string according to Solidity ID
     * standards.
     *
     * Generated from protobuf field <code>string contractAccountID = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setContractAccountID($var)
    {
        GPBUtil::checkString($var, True);
        $this->contractAccountID = $var;

        return $this;
    }

    /**
     **
     * A boolean indicating that this account is deleted.
     * <p>
     * Any transaction involving a deleted account SHALL fail.
     *
     * Generated from protobuf field <code>bool deleted = 3;</code>
     * @return bool
     */
    public function getDeleted()
    {
        return $this->deleted;
    }

    /**
     **
     * A boolean indicating that this account is deleted.
     * <p>
     * Any transaction involving a deleted account SHALL fail.
     *
     * Generated from protobuf field <code>bool deleted = 3;</code>
     * @param bool $var
     * @return $this
     */
    public function setDeleted($var)
    {
        GPBUtil::checkBool($var);
        $this->deleted = $var;

        return $this;
    }

    /**
     **
     * Replaced by StakingInfo.<br/>
     * ID of the account to which this account is staking its balances. If
     * this account is not currently staking its balances, then this field,
     * if set, SHALL be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 4 [deprecated = true];</code>
     * @return \Proto\AccountID|null
     * @deprecated
     */
    public function getProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return $this->proxyAccountID;
    }

    public function hasProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->proxyAccountID);
    }

    public function clearProxyAccountID()
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        unset($this->proxyAccountID);
    }

    /**
     **
     * Replaced by StakingInfo.<br/>
     * ID of the account to which this account is staking its balances. If
     * this account is not currently staking its balances, then this field,
     * if set, SHALL be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 4 [deprecated = true];</code>
     * @param \Proto\AccountID $var
     * @return $this
     * @deprecated
     */
    public function setProxyAccountID($var)
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->proxyAccountID = $var;

        return $this;
    }

    /**
     **
     * Replaced by StakingInfo.<br/>
     * The total amount of tinybar proxy staked to this account.
     *
     * Generated from protobuf field <code>int64 proxyReceived = 6 [deprecated = true];</code>
     * @return int|string
     * @deprecated
     */
    public function getProxyReceived()
    {
        if ($this->proxyReceived !== 0) {
            @trigger_error('proxyReceived is deprecated.', E_USER_DEPRECATED);
        }
        return $this->proxyReceived;
    }

    /**
     **
     * Replaced by StakingInfo.<br/>
     * The total amount of tinybar proxy staked to this account.
     *
     * Generated from protobuf field <code>int64 proxyReceived = 6 [deprecated = true];</code>
     * @param int|string $var
     * @return $this
     * @deprecated
     */
    public function setProxyReceived($var)
    {
        @trigger_error('proxyReceived is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkInt64($var);
        $this->proxyReceived = $var;

        return $this;
    }

    /**
     **
     * The key to be used to sign transactions from this account, if any.
     * <p>
     * This key SHALL NOT be set for hollow accounts until the account
     * is finalized.<br/>
     * This key SHALL be set on all other accounts, except for certain
     * immutable accounts (0.0.800 and 0.0.801) necessary for network
     * function and otherwise secured by the governing council.
     *
     * Generated from protobuf field <code>.proto.Key key = 7;</code>
     * @return \Proto\Key|null
     */
    public function getKey()
    {
        return $this->key;
    }

    public function hasKey()
    {
        return isset($this->key);
    }

    public function clearKey()
    {
        unset($this->key);
    }

    /**
     **
     * The key to be used to sign transactions from this account, if any.
     * <p>
     * This key SHALL NOT be set for hollow accounts until the account
     * is finalized.<br/>
     * This key SHALL be set on all other accounts, except for certain
     * immutable accounts (0.0.800 and 0.0.801) necessary for network
     * function and otherwise secured by the governing council.
     *
     * Generated from protobuf field <code>.proto.Key key = 7;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->key = $var;

        return $this;
    }

    /**
     **
     * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     * <p>
     * This value SHALL always be a whole number.
     *
     * Generated from protobuf field <code>uint64 balance = 8;</code>
     * @return int|string
     */
    public function getBalance()
    {
        return $this->balance;
    }

    /**
     **
     * The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
     * <p>
     * This value SHALL always be a whole number.
     *
     * Generated from protobuf field <code>uint64 balance = 8;</code>
     * @param int|string $var
     * @return $this
     */
    public function setBalance($var)
    {
        GPBUtil::checkUint64($var);
        $this->balance = $var;

        return $this;
    }

    /**
     **
     * Obsolete and unused.<br/>
     * The threshold amount, in tinybars, at which a record was created for
     * any transaction that decreased the balance of this account.
     *
     * Generated from protobuf field <code>uint64 generateSendRecordThreshold = 9 [deprecated = true];</code>
     * @return int|string
     * @deprecated
     */
    public function getGenerateSendRecordThreshold()
    {
        if ($this->generateSendRecordThreshold !== 0) {
            @trigger_error('generateSendRecordThreshold is deprecated.', E_USER_DEPRECATED);
        }
        return $this->generateSendRecordThreshold;
    }

    /**
     **
     * Obsolete and unused.<br/>
     * The threshold amount, in tinybars, at which a record was created for
     * any transaction that decreased the balance of this account.
     *
     * Generated from protobuf field <code>uint64 generateSendRecordThreshold = 9 [deprecated = true];</code>
     * @param int|string $var
     * @return $this
     * @deprecated
     */
    public function setGenerateSendRecordThreshold($var)
    {
        @trigger_error('generateSendRecordThreshold is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkUint64($var);
        $this->generateSendRecordThreshold = $var;

        return $this;
    }

    /**
     **
     * Obsolete and unused.<br/>
     * The threshold amount, in tinybars, at which a record was created for
     * any transaction that increased the balance of this account.
     *
     * Generated from protobuf field <code>uint64 generateReceiveRecordThreshold = 10 [deprecated = true];</code>
     * @return int|string
     * @deprecated
     */
    public function getGenerateReceiveRecordThreshold()
    {
        if ($this->generateReceiveRecordThreshold !== 0) {
            @trigger_error('generateReceiveRecordThreshold is deprecated.', E_USER_DEPRECATED);
        }
        return $this->generateReceiveRecordThreshold;
    }

    /**
     **
     * Obsolete and unused.<br/>
     * The threshold amount, in tinybars, at which a record was created for
     * any transaction that increased the balance of this account.
     *
     * Generated from protobuf field <code>uint64 generateReceiveRecordThreshold = 10 [deprecated = true];</code>
     * @param int|string $var
     * @return $this
     * @deprecated
     */
    public function setGenerateReceiveRecordThreshold($var)
    {
        @trigger_error('generateReceiveRecordThreshold is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkUint64($var);
        $this->generateReceiveRecordThreshold = $var;

        return $this;
    }

    /**
     **
     * A boolean indicating that the account requires a receiver signature
     * for inbound token transfer transactions.
     * <p>
     * If this value is `true` then a transaction to transfer tokens to this
     * account SHALL NOT succeed unless this account has signed the
     * transfer transaction.
     *
     * Generated from protobuf field <code>bool receiverSigRequired = 11;</code>
     * @return bool
     */
    public function getReceiverSigRequired()
    {
        return $this->receiverSigRequired;
    }

    /**
     **
     * A boolean indicating that the account requires a receiver signature
     * for inbound token transfer transactions.
     * <p>
     * If this value is `true` then a transaction to transfer tokens to this
     * account SHALL NOT succeed unless this account has signed the
     * transfer transaction.
     *
     * Generated from protobuf field <code>bool receiverSigRequired = 11;</code>
     * @param bool $var
     * @return $this
     */
    public function setReceiverSigRequired($var)
    {
        GPBUtil::checkBool($var);
        $this->receiverSigRequired = $var;

        return $this;
    }

    /**
     **
     * The current expiration time for this account.
     * <p>
     * This account SHALL be due standard renewal fees when the network
     * consensus time exceeds this time.<br/>
     * If rent and expiration are enabled for the network, and automatic
     * renewal is enabled for this account, renewal fees SHALL be charged
     * after this time, and, if charged, the expiration time SHALL be
     * extended for another renewal period.<br/>
     * This account MAY be expired and removed from state at any point
     * after this time if not renewed.<br/>
     * An account holder MAY extend this time by submitting an account
     * update transaction to modify expiration time, subject to the current
     * maximum expiration time for the network.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 12;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExpirationTime()
    {
        return $this->expirationTime;
    }

    public function hasExpirationTime()
    {
        return isset($this->expirationTime);
    }

    public function clearExpirationTime()
    {
        unset($this->expirationTime);
    }

    /**
     **
     * The current expiration time for this account.
     * <p>
     * This account SHALL be due standard renewal fees when the network
     * consensus time exceeds this time.<br/>
     * If rent and expiration are enabled for the network, and automatic
     * renewal is enabled for this account, renewal fees SHALL be charged
     * after this time, and, if charged, the expiration time SHALL be
     * extended for another renewal period.<br/>
     * This account MAY be expired and removed from state at any point
     * after this time if not renewed.<br/>
     * An account holder MAY extend this time by submitting an account
     * update transaction to modify expiration time, subject to the current
     * maximum expiration time for the network.
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 12;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExpirationTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->expirationTime = $var;

        return $this;
    }

    /**
     **
     * A duration to extend this account's expiration.
     * <p>
     * The network SHALL extend the account's expiration by this
     * duration, if funds are available, upon automatic renewal.<br/>
     * This SHALL NOT apply if the account is already deleted
     * upon expiration.<br/>
     * If this is not provided in an allowed range on account creation, the
     * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     * values for the minimum period and maximum period are currently
     * 30 days and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 13;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->autoRenewPeriod;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->autoRenewPeriod);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->autoRenewPeriod);
    }

    /**
     **
     * A duration to extend this account's expiration.
     * <p>
     * The network SHALL extend the account's expiration by this
     * duration, if funds are available, upon automatic renewal.<br/>
     * This SHALL NOT apply if the account is already deleted
     * upon expiration.<br/>
     * If this is not provided in an allowed range on account creation, the
     * transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
     * values for the minimum period and maximum period are currently
     * 30 days and 90 days, respectively.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 13;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->autoRenewPeriod = $var;

        return $this;
    }

    /**
     **
     * All of the livehashes attached to the account (each of which is a
     * hash along with the keys that authorized it and can delete it)
     *
     * Generated from protobuf field <code>repeated .proto.LiveHash liveHashes = 14;</code>
     * @return RepeatedField<\Proto\LiveHash>
     */
    public function getLiveHashes()
    {
        return $this->liveHashes;
    }

    /**
     **
     * All of the livehashes attached to the account (each of which is a
     * hash along with the keys that authorized it and can delete it)
     *
     * Generated from protobuf field <code>repeated .proto.LiveHash liveHashes = 14;</code>
     * @param \Proto\LiveHash[] $var
     * @return $this
     */
    public function setLiveHashes($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\LiveHash::class);
        $this->liveHashes = $arr;

        return $this;
    }

    /**
     **
     * As of `HIP-367`, which enabled unlimited token associations, the
     * potential scale for this value requires that users consult a mirror
     * node for this information.
     *
     * Generated from protobuf field <code>repeated .proto.TokenRelationship tokenRelationships = 15 [deprecated = true];</code>
     * @return RepeatedField<\Proto\TokenRelationship>
     * @deprecated
     */
    public function getTokenRelationships()
    {
        if ($this->tokenRelationships->count() !== 0) {
            @trigger_error('tokenRelationships is deprecated.', E_USER_DEPRECATED);
        }
        return $this->tokenRelationships;
    }

    /**
     **
     * As of `HIP-367`, which enabled unlimited token associations, the
     * potential scale for this value requires that users consult a mirror
     * node for this information.
     *
     * Generated from protobuf field <code>repeated .proto.TokenRelationship tokenRelationships = 15 [deprecated = true];</code>
     * @param \Proto\TokenRelationship[] $var
     * @return $this
     * @deprecated
     */
    public function setTokenRelationships($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\TokenRelationship::class);
        if ($arr->count() !== 0) {
            @trigger_error('tokenRelationships is deprecated.', E_USER_DEPRECATED);
        }
        $this->tokenRelationships = $arr;

        return $this;
    }

    /**
     **
     * A short description of this account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 16;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description of this account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 16;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * The total number of non-fungible/unique tokens owned by this account.
     *
     * Generated from protobuf field <code>int64 ownedNfts = 17;</code>
     * @return int|string
     */
    public function getOwnedNfts()
    {
        return $this->ownedNfts;
    }

    /**
     **
     * The total number of non-fungible/unique tokens owned by this account.
     *
     * Generated from protobuf field <code>int64 ownedNfts = 17;</code>
     * @param int|string $var
     * @return $this
     */
    public function setOwnedNfts($var)
    {
        GPBUtil::checkInt64($var);
        $this->ownedNfts = $var;

        return $this;
    }

    /**
     **
     * The maximum number of tokens that can be auto-associated with the
     * account.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0),
     * then this account MUST manually associate with a token before
     * transacting in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no
     * limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 18;</code>
     * @return int
     */
    public function getMaxAutomaticTokenAssociations()
    {
        return $this->max_automatic_token_associations;
    }

    /**
     **
     * The maximum number of tokens that can be auto-associated with the
     * account.
     * <p>
     * If this is less than or equal to `used_auto_associations` (or 0),
     * then this account MUST manually associate with a token before
     * transacting in that token.<br/>
     * Following HIP-904 This value may also be `-1` to indicate no
     * limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 18;</code>
     * @param int $var
     * @return $this
     */
    public function setMaxAutomaticTokenAssociations($var)
    {
        GPBUtil::checkInt32($var);
        $this->max_automatic_token_associations = $var;

        return $this;
    }

    /**
     **
     * An account alias.<br/>
     * This is a value used in some contexts to reference an account when
     * the tripartite account identifier is not available.
     * <p>
     * This field, when set to a non-default value, is immutable and
     * SHALL NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 19;</code>
     * @return string
     */
    public function getAlias()
    {
        return $this->alias;
    }

    /**
     **
     * An account alias.<br/>
     * This is a value used in some contexts to reference an account when
     * the tripartite account identifier is not available.
     * <p>
     * This field, when set to a non-default value, is immutable and
     * SHALL NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 19;</code>
     * @param string $var
     * @return $this
     */
    public function setAlias($var)
    {
        GPBUtil::checkString($var, False);
        $this->alias = $var;

        return $this;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 20;</code>
     * @return string
     */
    public function getLedgerId()
    {
        return $this->ledger_id;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 20;</code>
     * @param string $var
     * @return $this
     */
    public function setLedgerId($var)
    {
        GPBUtil::checkString($var, False);
        $this->ledger_id = $var;

        return $this;
    }

    /**
     **
     * The ethereum transaction nonce associated with this account.
     *
     * Generated from protobuf field <code>int64 ethereum_nonce = 21;</code>
     * @return int|string
     */
    public function getEthereumNonce()
    {
        return $this->ethereum_nonce;
    }

    /**
     **
     * The ethereum transaction nonce associated with this account.
     *
     * Generated from protobuf field <code>int64 ethereum_nonce = 21;</code>
     * @param int|string $var
     * @return $this
     */
    public function setEthereumNonce($var)
    {
        GPBUtil::checkInt64($var);
        $this->ethereum_nonce = $var;

        return $this;
    }

    /**
     **
     * Staking information for this account.
     *
     * Generated from protobuf field <code>.proto.StakingInfo staking_info = 22;</code>
     * @return \Proto\StakingInfo|null
     */
    public function getStakingInfo()
    {
        return $this->staking_info;
    }

    public function hasStakingInfo()
    {
        return isset($this->staking_info);
    }

    public function clearStakingInfo()
    {
        unset($this->staking_info);
    }

    /**
     **
     * Staking information for this account.
     *
     * Generated from protobuf field <code>.proto.StakingInfo staking_info = 22;</code>
     * @param \Proto\StakingInfo $var
     * @return $this
     */
    public function setStakingInfo($var)
    {
        GPBUtil::checkMessage($var, \Proto\StakingInfo::class);
        $this->staking_info = $var;

        return $this;
    }

}

