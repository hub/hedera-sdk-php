<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: crypto_create.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 * Create a new account.
 * If the auto_renew_account field is set, the key of the referenced account
 * MUST sign this transaction.<br/>
 * Current limitations REQUIRE that `shardID` and `realmID` both MUST be `0`.
 * This is expected to change in the future.
 * ### Block Stream Effects
 * The newly created account SHALL be included in State Changes.
 *
 * Generated from protobuf message <code>proto.CryptoCreateTransactionBody</code>
 */
class CryptoCreateTransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * The identifying key for this account.
     * This key represents the account owner, and is required for most actions
     * involving this account that do not modify the account itself. This key
     * may also identify the account for smart contracts.
     * <p>
     * This field is REQUIRED.
     * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
     * "primitive" (i.e. cryptographic) key value.
     *
     * Generated from protobuf field <code>.proto.Key key = 1;</code>
     */
    protected $key = null;
    /**
     **
     * An amount, in tinybar, to deposit to the newly created account.
     * <p>
     * The deposited amount SHALL be debited to the "payer" account for this
     * transaction.
     *
     * Generated from protobuf field <code>uint64 initialBalance = 2;</code>
     */
    protected $initialBalance = 0;
    /**
     **
     * Use `staked_id` instead.<br/>
     * An account identifier for a staking proxy.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 3 [deprecated = true];</code>
     * @deprecated
     */
    protected $proxyAccountID = null;
    /**
     **
     * Removed prior to the first available history, and may be related to an
     * early design dead-end.<br/>
     * An amount below which record stream records would not be created for
     * a transaction that reduces this account balance.
     *
     * Generated from protobuf field <code>uint64 sendRecordThreshold = 6 [deprecated = true];</code>
     * @deprecated
     */
    protected $sendRecordThreshold = 0;
    /**
     **
     * Removed prior to the first available history, and may be related to an
     * early design dead-end.<br/>
     * An amount below which record stream records would not be created for
     * a transaction that increases this account balance.
     *
     * Generated from protobuf field <code>uint64 receiveRecordThreshold = 7 [deprecated = true];</code>
     * @deprecated
     */
    protected $receiveRecordThreshold = 0;
    /**
     **
     * A flag indicating the account holder must authorize all incoming
     * token transfers.
     * <p>
     * If this flag is set then any transaction that would result in adding
     * hbar or other tokens to this account balance MUST be signed by the
     * identifying key of this account (that is, the `key` field).<br/>
     * If this flag is set, then the account key (`key` field) MUST sign
     * this create transaction, in addition to the transaction payer.
     *
     * Generated from protobuf field <code>bool receiverSigRequired = 8;</code>
     */
    protected $receiverSigRequired = false;
    /**
     **
     * The duration between account automatic renewals.<br/>
     * All entities in state may be charged "rent" occasionally (typically
     * every 90 days) to prevent unnecessary growth of the ledger. This value
     * sets the interval between such events for this account.
     * <p>
     * If the account balance (in HBAR) is insufficient to pay the full renewal
     * fee, the entire HBAR balance SHALL be consumed and the expiration for
     * the account SHALL be extended as far as the available balance can
     * support.<br/>
     * If the account HBAR balance is `0` when the account must be renewed, then
     * the account SHALL be deleted, and subsequently removed from state.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 9;</code>
     */
    protected $autoRenewPeriod = null;
    /**
     **
     * The shard in which this account is created
     * <p>
     * Currently, this MUST be `0`.<br/>
     * If the desired shard is `0`, this SHOULD NOT be set.
     *
     * Generated from protobuf field <code>.proto.ShardID shardID = 10;</code>
     */
    protected $shardID = null;
    /**
     **
     * The realm in which this account is created.
     * <p>
     * The shard number for this realm MUST match the value in `shardID`.<br/>
     * Currently, this MUST be `0` for both fields.<br/>
     * If the desired realm is `0`, this SHOULD NOT be set.
     *
     * Generated from protobuf field <code>.proto.RealmID realmID = 11;</code>
     */
    protected $realmID = null;
    /**
     **
     * This field was never actually used or enabled, and is not expected to
     * ever be used in the future.<br/>
     *
     * Generated from protobuf field <code>.proto.Key newRealmAdminKey = 12 [deprecated = true];</code>
     * @deprecated
     */
    protected $newRealmAdminKey = null;
    /**
     **
     * A short description of this Account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 13;</code>
     */
    protected $memo = '';
    /**
     **
     * A maximum number of tokens that can be auto-associated
     * with this account.<br/>
     * By default this value is 0 for all accounts except for automatically
     * created accounts (e.g. smart contracts), which default to -1.
     * <p>
     * If this value is `0`, then this account MUST manually associate to
     * a token before holding or transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     */
    protected $max_automatic_token_associations = 0;
    /**
     **
     * A boolean indicating that this account has chosen to decline rewards for
     * staking its balances.
     * <p>
     * This account MAY still stake its balances, but SHALL NOT receive reward
     * payments for doing so, if this value is set.
     *
     * Generated from protobuf field <code>bool decline_reward = 17;</code>
     */
    protected $decline_reward = false;
    /**
     **
     * Bytes to be used as the account's alias.
     * <p>
     * This value, if set, MUST be one of the following values<br/>
     * <ul>
     *   <li>The 32-byte serialized form of the ED25519 account key.</li>
     *   <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
     *       account key.</li>
     *   <li>The 20-byte EVM address derived from a keccak-256 hash of the
     *       ECDSA(secp256k1) account key</li>
     * </ul>
     * All aliases within the network MUST be unique. If this value matches an
     * existing account alias, this `create` transaction SHALL fail.<br/>
     * If an account exists with a particular alias value, any transaction to
     * transfer value _to_ that alias SHALL deposit the transferred value in
     * the existing account, and SHALL NOT assess an account creation fee.<br/>
     * Once set, an account alias is immutable and MUST NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 18;</code>
     */
    protected $alias = '';
    protected $staked_id;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\Key $key
     *          *
     *           The identifying key for this account.
     *           This key represents the account owner, and is required for most actions
     *           involving this account that do not modify the account itself. This key
     *           may also identify the account for smart contracts.
     *           <p>
     *           This field is REQUIRED.
     *           This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
     *           "primitive" (i.e. cryptographic) key value.
     *     @type int|string $initialBalance
     *          *
     *           An amount, in tinybar, to deposit to the newly created account.
     *           <p>
     *           The deposited amount SHALL be debited to the "payer" account for this
     *           transaction.
     *     @type \Proto\AccountID $proxyAccountID
     *          *
     *           Use `staked_id` instead.<br/>
     *           An account identifier for a staking proxy.
     *     @type int|string $sendRecordThreshold
     *          *
     *           Removed prior to the first available history, and may be related to an
     *           early design dead-end.<br/>
     *           An amount below which record stream records would not be created for
     *           a transaction that reduces this account balance.
     *     @type int|string $receiveRecordThreshold
     *          *
     *           Removed prior to the first available history, and may be related to an
     *           early design dead-end.<br/>
     *           An amount below which record stream records would not be created for
     *           a transaction that increases this account balance.
     *     @type bool $receiverSigRequired
     *          *
     *           A flag indicating the account holder must authorize all incoming
     *           token transfers.
     *           <p>
     *           If this flag is set then any transaction that would result in adding
     *           hbar or other tokens to this account balance MUST be signed by the
     *           identifying key of this account (that is, the `key` field).<br/>
     *           If this flag is set, then the account key (`key` field) MUST sign
     *           this create transaction, in addition to the transaction payer.
     *     @type \Proto\Duration $autoRenewPeriod
     *          *
     *           The duration between account automatic renewals.<br/>
     *           All entities in state may be charged "rent" occasionally (typically
     *           every 90 days) to prevent unnecessary growth of the ledger. This value
     *           sets the interval between such events for this account.
     *           <p>
     *           If the account balance (in HBAR) is insufficient to pay the full renewal
     *           fee, the entire HBAR balance SHALL be consumed and the expiration for
     *           the account SHALL be extended as far as the available balance can
     *           support.<br/>
     *           If the account HBAR balance is `0` when the account must be renewed, then
     *           the account SHALL be deleted, and subsequently removed from state.
     *     @type \Proto\ShardID $shardID
     *          *
     *           The shard in which this account is created
     *           <p>
     *           Currently, this MUST be `0`.<br/>
     *           If the desired shard is `0`, this SHOULD NOT be set.
     *     @type \Proto\RealmID $realmID
     *          *
     *           The realm in which this account is created.
     *           <p>
     *           The shard number for this realm MUST match the value in `shardID`.<br/>
     *           Currently, this MUST be `0` for both fields.<br/>
     *           If the desired realm is `0`, this SHOULD NOT be set.
     *     @type \Proto\Key $newRealmAdminKey
     *          *
     *           This field was never actually used or enabled, and is not expected to
     *           ever be used in the future.<br/>
     *     @type string $memo
     *          *
     *           A short description of this Account.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type int $max_automatic_token_associations
     *          *
     *           A maximum number of tokens that can be auto-associated
     *           with this account.<br/>
     *           By default this value is 0 for all accounts except for automatically
     *           created accounts (e.g. smart contracts), which default to -1.
     *           <p>
     *           If this value is `0`, then this account MUST manually associate to
     *           a token before holding or transacting in that token.<br/>
     *           This value MAY also be `-1` to indicate no limit.<br/>
     *           This value MUST NOT be less than `-1`.
     *     @type \Proto\AccountID $staked_account_id
     *          *
     *           ID of the account to which this account is staking its balances.
     *           <p>
     *           If this account is not currently staking its balances, then this
     *           field, if set, MUST be the sentinel value of `0.0.0`.
     *     @type int|string $staked_node_id
     *          *
     *           ID of the node this account is staked to.
     *           <p>
     *           If this account is not currently staking its balances, then this
     *           field, if set, SHALL be the sentinel value of `-1`.<br/>
     *           Wallet software SHOULD surface staking issues to users and provide a
     *           simple mechanism to update staking to a new node ID in the event the
     *           prior staked node ID ceases to be valid.
     *     @type bool $decline_reward
     *          *
     *           A boolean indicating that this account has chosen to decline rewards for
     *           staking its balances.
     *           <p>
     *           This account MAY still stake its balances, but SHALL NOT receive reward
     *           payments for doing so, if this value is set.
     *     @type string $alias
     *          *
     *           Bytes to be used as the account's alias.
     *           <p>
     *           This value, if set, MUST be one of the following values<br/>
     *           <ul>
     *             <li>The 32-byte serialized form of the ED25519 account key.</li>
     *             <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
     *                 account key.</li>
     *             <li>The 20-byte EVM address derived from a keccak-256 hash of the
     *                 ECDSA(secp256k1) account key</li>
     *           </ul>
     *           All aliases within the network MUST be unique. If this value matches an
     *           existing account alias, this `create` transaction SHALL fail.<br/>
     *           If an account exists with a particular alias value, any transaction to
     *           transfer value _to_ that alias SHALL deposit the transferred value in
     *           the existing account, and SHALL NOT assess an account creation fee.<br/>
     *           Once set, an account alias is immutable and MUST NOT be changed.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\CryptoCreate::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * The identifying key for this account.
     * This key represents the account owner, and is required for most actions
     * involving this account that do not modify the account itself. This key
     * may also identify the account for smart contracts.
     * <p>
     * This field is REQUIRED.
     * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
     * "primitive" (i.e. cryptographic) key value.
     *
     * Generated from protobuf field <code>.proto.Key key = 1;</code>
     * @return \Proto\Key|null
     */
    public function getKey()
    {
        return $this->key;
    }

    public function hasKey()
    {
        return isset($this->key);
    }

    public function clearKey()
    {
        unset($this->key);
    }

    /**
     **
     * The identifying key for this account.
     * This key represents the account owner, and is required for most actions
     * involving this account that do not modify the account itself. This key
     * may also identify the account for smart contracts.
     * <p>
     * This field is REQUIRED.
     * This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
     * "primitive" (i.e. cryptographic) key value.
     *
     * Generated from protobuf field <code>.proto.Key key = 1;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->key = $var;

        return $this;
    }

    /**
     **
     * An amount, in tinybar, to deposit to the newly created account.
     * <p>
     * The deposited amount SHALL be debited to the "payer" account for this
     * transaction.
     *
     * Generated from protobuf field <code>uint64 initialBalance = 2;</code>
     * @return int|string
     */
    public function getInitialBalance()
    {
        return $this->initialBalance;
    }

    /**
     **
     * An amount, in tinybar, to deposit to the newly created account.
     * <p>
     * The deposited amount SHALL be debited to the "payer" account for this
     * transaction.
     *
     * Generated from protobuf field <code>uint64 initialBalance = 2;</code>
     * @param int|string $var
     * @return $this
     */
    public function setInitialBalance($var)
    {
        GPBUtil::checkUint64($var);
        $this->initialBalance = $var;

        return $this;
    }

    /**
     **
     * Use `staked_id` instead.<br/>
     * An account identifier for a staking proxy.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 3 [deprecated = true];</code>
     * @return \Proto\AccountID|null
     * @deprecated
     */
    public function getProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return $this->proxyAccountID;
    }

    public function hasProxyAccountID()
    {
        if (isset($this->proxyAccountID)) {
            @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->proxyAccountID);
    }

    public function clearProxyAccountID()
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        unset($this->proxyAccountID);
    }

    /**
     **
     * Use `staked_id` instead.<br/>
     * An account identifier for a staking proxy.
     *
     * Generated from protobuf field <code>.proto.AccountID proxyAccountID = 3 [deprecated = true];</code>
     * @param \Proto\AccountID $var
     * @return $this
     * @deprecated
     */
    public function setProxyAccountID($var)
    {
        @trigger_error('proxyAccountID is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->proxyAccountID = $var;

        return $this;
    }

    /**
     **
     * Removed prior to the first available history, and may be related to an
     * early design dead-end.<br/>
     * An amount below which record stream records would not be created for
     * a transaction that reduces this account balance.
     *
     * Generated from protobuf field <code>uint64 sendRecordThreshold = 6 [deprecated = true];</code>
     * @return int|string
     * @deprecated
     */
    public function getSendRecordThreshold()
    {
        if ($this->sendRecordThreshold !== 0) {
            @trigger_error('sendRecordThreshold is deprecated.', E_USER_DEPRECATED);
        }
        return $this->sendRecordThreshold;
    }

    /**
     **
     * Removed prior to the first available history, and may be related to an
     * early design dead-end.<br/>
     * An amount below which record stream records would not be created for
     * a transaction that reduces this account balance.
     *
     * Generated from protobuf field <code>uint64 sendRecordThreshold = 6 [deprecated = true];</code>
     * @param int|string $var
     * @return $this
     * @deprecated
     */
    public function setSendRecordThreshold($var)
    {
        @trigger_error('sendRecordThreshold is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkUint64($var);
        $this->sendRecordThreshold = $var;

        return $this;
    }

    /**
     **
     * Removed prior to the first available history, and may be related to an
     * early design dead-end.<br/>
     * An amount below which record stream records would not be created for
     * a transaction that increases this account balance.
     *
     * Generated from protobuf field <code>uint64 receiveRecordThreshold = 7 [deprecated = true];</code>
     * @return int|string
     * @deprecated
     */
    public function getReceiveRecordThreshold()
    {
        if ($this->receiveRecordThreshold !== 0) {
            @trigger_error('receiveRecordThreshold is deprecated.', E_USER_DEPRECATED);
        }
        return $this->receiveRecordThreshold;
    }

    /**
     **
     * Removed prior to the first available history, and may be related to an
     * early design dead-end.<br/>
     * An amount below which record stream records would not be created for
     * a transaction that increases this account balance.
     *
     * Generated from protobuf field <code>uint64 receiveRecordThreshold = 7 [deprecated = true];</code>
     * @param int|string $var
     * @return $this
     * @deprecated
     */
    public function setReceiveRecordThreshold($var)
    {
        @trigger_error('receiveRecordThreshold is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkUint64($var);
        $this->receiveRecordThreshold = $var;

        return $this;
    }

    /**
     **
     * A flag indicating the account holder must authorize all incoming
     * token transfers.
     * <p>
     * If this flag is set then any transaction that would result in adding
     * hbar or other tokens to this account balance MUST be signed by the
     * identifying key of this account (that is, the `key` field).<br/>
     * If this flag is set, then the account key (`key` field) MUST sign
     * this create transaction, in addition to the transaction payer.
     *
     * Generated from protobuf field <code>bool receiverSigRequired = 8;</code>
     * @return bool
     */
    public function getReceiverSigRequired()
    {
        return $this->receiverSigRequired;
    }

    /**
     **
     * A flag indicating the account holder must authorize all incoming
     * token transfers.
     * <p>
     * If this flag is set then any transaction that would result in adding
     * hbar or other tokens to this account balance MUST be signed by the
     * identifying key of this account (that is, the `key` field).<br/>
     * If this flag is set, then the account key (`key` field) MUST sign
     * this create transaction, in addition to the transaction payer.
     *
     * Generated from protobuf field <code>bool receiverSigRequired = 8;</code>
     * @param bool $var
     * @return $this
     */
    public function setReceiverSigRequired($var)
    {
        GPBUtil::checkBool($var);
        $this->receiverSigRequired = $var;

        return $this;
    }

    /**
     **
     * The duration between account automatic renewals.<br/>
     * All entities in state may be charged "rent" occasionally (typically
     * every 90 days) to prevent unnecessary growth of the ledger. This value
     * sets the interval between such events for this account.
     * <p>
     * If the account balance (in HBAR) is insufficient to pay the full renewal
     * fee, the entire HBAR balance SHALL be consumed and the expiration for
     * the account SHALL be extended as far as the available balance can
     * support.<br/>
     * If the account HBAR balance is `0` when the account must be renewed, then
     * the account SHALL be deleted, and subsequently removed from state.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 9;</code>
     * @return \Proto\Duration|null
     */
    public function getAutoRenewPeriod()
    {
        return $this->autoRenewPeriod;
    }

    public function hasAutoRenewPeriod()
    {
        return isset($this->autoRenewPeriod);
    }

    public function clearAutoRenewPeriod()
    {
        unset($this->autoRenewPeriod);
    }

    /**
     **
     * The duration between account automatic renewals.<br/>
     * All entities in state may be charged "rent" occasionally (typically
     * every 90 days) to prevent unnecessary growth of the ledger. This value
     * sets the interval between such events for this account.
     * <p>
     * If the account balance (in HBAR) is insufficient to pay the full renewal
     * fee, the entire HBAR balance SHALL be consumed and the expiration for
     * the account SHALL be extended as far as the available balance can
     * support.<br/>
     * If the account HBAR balance is `0` when the account must be renewed, then
     * the account SHALL be deleted, and subsequently removed from state.
     *
     * Generated from protobuf field <code>.proto.Duration autoRenewPeriod = 9;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setAutoRenewPeriod($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->autoRenewPeriod = $var;

        return $this;
    }

    /**
     **
     * The shard in which this account is created
     * <p>
     * Currently, this MUST be `0`.<br/>
     * If the desired shard is `0`, this SHOULD NOT be set.
     *
     * Generated from protobuf field <code>.proto.ShardID shardID = 10;</code>
     * @return \Proto\ShardID|null
     */
    public function getShardID()
    {
        return $this->shardID;
    }

    public function hasShardID()
    {
        return isset($this->shardID);
    }

    public function clearShardID()
    {
        unset($this->shardID);
    }

    /**
     **
     * The shard in which this account is created
     * <p>
     * Currently, this MUST be `0`.<br/>
     * If the desired shard is `0`, this SHOULD NOT be set.
     *
     * Generated from protobuf field <code>.proto.ShardID shardID = 10;</code>
     * @param \Proto\ShardID $var
     * @return $this
     */
    public function setShardID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ShardID::class);
        $this->shardID = $var;

        return $this;
    }

    /**
     **
     * The realm in which this account is created.
     * <p>
     * The shard number for this realm MUST match the value in `shardID`.<br/>
     * Currently, this MUST be `0` for both fields.<br/>
     * If the desired realm is `0`, this SHOULD NOT be set.
     *
     * Generated from protobuf field <code>.proto.RealmID realmID = 11;</code>
     * @return \Proto\RealmID|null
     */
    public function getRealmID()
    {
        return $this->realmID;
    }

    public function hasRealmID()
    {
        return isset($this->realmID);
    }

    public function clearRealmID()
    {
        unset($this->realmID);
    }

    /**
     **
     * The realm in which this account is created.
     * <p>
     * The shard number for this realm MUST match the value in `shardID`.<br/>
     * Currently, this MUST be `0` for both fields.<br/>
     * If the desired realm is `0`, this SHOULD NOT be set.
     *
     * Generated from protobuf field <code>.proto.RealmID realmID = 11;</code>
     * @param \Proto\RealmID $var
     * @return $this
     */
    public function setRealmID($var)
    {
        GPBUtil::checkMessage($var, \Proto\RealmID::class);
        $this->realmID = $var;

        return $this;
    }

    /**
     **
     * This field was never actually used or enabled, and is not expected to
     * ever be used in the future.<br/>
     *
     * Generated from protobuf field <code>.proto.Key newRealmAdminKey = 12 [deprecated = true];</code>
     * @return \Proto\Key|null
     * @deprecated
     */
    public function getNewRealmAdminKey()
    {
        if (isset($this->newRealmAdminKey)) {
            @trigger_error('newRealmAdminKey is deprecated.', E_USER_DEPRECATED);
        }
        return $this->newRealmAdminKey;
    }

    public function hasNewRealmAdminKey()
    {
        if (isset($this->newRealmAdminKey)) {
            @trigger_error('newRealmAdminKey is deprecated.', E_USER_DEPRECATED);
        }
        return isset($this->newRealmAdminKey);
    }

    public function clearNewRealmAdminKey()
    {
        @trigger_error('newRealmAdminKey is deprecated.', E_USER_DEPRECATED);
        unset($this->newRealmAdminKey);
    }

    /**
     **
     * This field was never actually used or enabled, and is not expected to
     * ever be used in the future.<br/>
     *
     * Generated from protobuf field <code>.proto.Key newRealmAdminKey = 12 [deprecated = true];</code>
     * @param \Proto\Key $var
     * @return $this
     * @deprecated
     */
    public function setNewRealmAdminKey($var)
    {
        @trigger_error('newRealmAdminKey is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->newRealmAdminKey = $var;

        return $this;
    }

    /**
     **
     * A short description of this Account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 13;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description of this Account.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 13;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * A maximum number of tokens that can be auto-associated
     * with this account.<br/>
     * By default this value is 0 for all accounts except for automatically
     * created accounts (e.g. smart contracts), which default to -1.
     * <p>
     * If this value is `0`, then this account MUST manually associate to
     * a token before holding or transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     * @return int
     */
    public function getMaxAutomaticTokenAssociations()
    {
        return $this->max_automatic_token_associations;
    }

    /**
     **
     * A maximum number of tokens that can be auto-associated
     * with this account.<br/>
     * By default this value is 0 for all accounts except for automatically
     * created accounts (e.g. smart contracts), which default to -1.
     * <p>
     * If this value is `0`, then this account MUST manually associate to
     * a token before holding or transacting in that token.<br/>
     * This value MAY also be `-1` to indicate no limit.<br/>
     * This value MUST NOT be less than `-1`.
     *
     * Generated from protobuf field <code>int32 max_automatic_token_associations = 14;</code>
     * @param int $var
     * @return $this
     */
    public function setMaxAutomaticTokenAssociations($var)
    {
        GPBUtil::checkInt32($var);
        $this->max_automatic_token_associations = $var;

        return $this;
    }

    /**
     **
     * ID of the account to which this account is staking its balances.
     * <p>
     * If this account is not currently staking its balances, then this
     * field, if set, MUST be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID staked_account_id = 15;</code>
     * @return \Proto\AccountID|null
     */
    public function getStakedAccountId()
    {
        return $this->readOneof(15);
    }

    public function hasStakedAccountId()
    {
        return $this->hasOneof(15);
    }

    /**
     **
     * ID of the account to which this account is staking its balances.
     * <p>
     * If this account is not currently staking its balances, then this
     * field, if set, MUST be the sentinel value of `0.0.0`.
     *
     * Generated from protobuf field <code>.proto.AccountID staked_account_id = 15;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setStakedAccountId($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->writeOneof(15, $var);

        return $this;
    }

    /**
     **
     * ID of the node this account is staked to.
     * <p>
     * If this account is not currently staking its balances, then this
     * field, if set, SHALL be the sentinel value of `-1`.<br/>
     * Wallet software SHOULD surface staking issues to users and provide a
     * simple mechanism to update staking to a new node ID in the event the
     * prior staked node ID ceases to be valid.
     *
     * Generated from protobuf field <code>int64 staked_node_id = 16;</code>
     * @return int|string
     */
    public function getStakedNodeId()
    {
        return $this->readOneof(16);
    }

    public function hasStakedNodeId()
    {
        return $this->hasOneof(16);
    }

    /**
     **
     * ID of the node this account is staked to.
     * <p>
     * If this account is not currently staking its balances, then this
     * field, if set, SHALL be the sentinel value of `-1`.<br/>
     * Wallet software SHOULD surface staking issues to users and provide a
     * simple mechanism to update staking to a new node ID in the event the
     * prior staked node ID ceases to be valid.
     *
     * Generated from protobuf field <code>int64 staked_node_id = 16;</code>
     * @param int|string $var
     * @return $this
     */
    public function setStakedNodeId($var)
    {
        GPBUtil::checkInt64($var);
        $this->writeOneof(16, $var);

        return $this;
    }

    /**
     **
     * A boolean indicating that this account has chosen to decline rewards for
     * staking its balances.
     * <p>
     * This account MAY still stake its balances, but SHALL NOT receive reward
     * payments for doing so, if this value is set.
     *
     * Generated from protobuf field <code>bool decline_reward = 17;</code>
     * @return bool
     */
    public function getDeclineReward()
    {
        return $this->decline_reward;
    }

    /**
     **
     * A boolean indicating that this account has chosen to decline rewards for
     * staking its balances.
     * <p>
     * This account MAY still stake its balances, but SHALL NOT receive reward
     * payments for doing so, if this value is set.
     *
     * Generated from protobuf field <code>bool decline_reward = 17;</code>
     * @param bool $var
     * @return $this
     */
    public function setDeclineReward($var)
    {
        GPBUtil::checkBool($var);
        $this->decline_reward = $var;

        return $this;
    }

    /**
     **
     * Bytes to be used as the account's alias.
     * <p>
     * This value, if set, MUST be one of the following values<br/>
     * <ul>
     *   <li>The 32-byte serialized form of the ED25519 account key.</li>
     *   <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
     *       account key.</li>
     *   <li>The 20-byte EVM address derived from a keccak-256 hash of the
     *       ECDSA(secp256k1) account key</li>
     * </ul>
     * All aliases within the network MUST be unique. If this value matches an
     * existing account alias, this `create` transaction SHALL fail.<br/>
     * If an account exists with a particular alias value, any transaction to
     * transfer value _to_ that alias SHALL deposit the transferred value in
     * the existing account, and SHALL NOT assess an account creation fee.<br/>
     * Once set, an account alias is immutable and MUST NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 18;</code>
     * @return string
     */
    public function getAlias()
    {
        return $this->alias;
    }

    /**
     **
     * Bytes to be used as the account's alias.
     * <p>
     * This value, if set, MUST be one of the following values<br/>
     * <ul>
     *   <li>The 32-byte serialized form of the ED25519 account key.</li>
     *   <li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
     *       account key.</li>
     *   <li>The 20-byte EVM address derived from a keccak-256 hash of the
     *       ECDSA(secp256k1) account key</li>
     * </ul>
     * All aliases within the network MUST be unique. If this value matches an
     * existing account alias, this `create` transaction SHALL fail.<br/>
     * If an account exists with a particular alias value, any transaction to
     * transfer value _to_ that alias SHALL deposit the transferred value in
     * the existing account, and SHALL NOT assess an account creation fee.<br/>
     * Once set, an account alias is immutable and MUST NOT be changed.
     *
     * Generated from protobuf field <code>bytes alias = 18;</code>
     * @param string $var
     * @return $this
     */
    public function setAlias($var)
    {
        GPBUtil::checkString($var, False);
        $this->alias = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getStakedId()
    {
        return $this->whichOneof("staked_id");
    }

}

