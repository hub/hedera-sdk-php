<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: transaction_receipt.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * The summary of a transaction's result so far.<br/>
 * If the transaction has not reached consensus, this result will
 * be necessarily incomplete.
 * Most items in this object are only set for specific transactions.
 * Those values SHALL be unset for all other transactions.
 *
 * Generated from protobuf message <code>proto.TransactionReceipt</code>
 */
class TransactionReceipt extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * The consensus status of the transaction.
     * <p>
     * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
     * This SHALL be `UNKNOWN` if the associated transaction did not have
     * a valid payer signature.
     *
     * Generated from protobuf field <code>.proto.ResponseCodeEnum status = 1;</code>
     */
    protected $status = 0;
    /**
     **
     * In the receipt of a `CryptoCreate`, the id of the newly created account.
     *
     * Generated from protobuf field <code>.proto.AccountID accountID = 2;</code>
     */
    protected $accountID = null;
    /**
     **
     * In the receipt of a `FileCreate`, the id of the newly created file.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 3;</code>
     */
    protected $fileID = null;
    /**
     **
     * In the receipt of a `ContractCreate`, the id of the newly created
     * contract.
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 4;</code>
     */
    protected $contractID = null;
    /**
     **
     * The exchange rates in effect when the transaction reached consensus.
     *
     * Generated from protobuf field <code>.proto.ExchangeRateSet exchangeRate = 5;</code>
     */
    protected $exchangeRate = null;
    /**
     **
     * In the receipt of a `ConsensusCreateTopic`, the id of the newly
     * created topic.
     *
     * Generated from protobuf field <code>.proto.TopicID topicID = 6;</code>
     */
    protected $topicID = null;
    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the new sequence
     * number for the topic that received the message.
     *
     * Generated from protobuf field <code>uint64 topicSequenceNumber = 7;</code>
     */
    protected $topicSequenceNumber = 0;
    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the new running hash of
     * the topic that received the message.<br/>
     * <p>
     * The inputs to the topic running hash have changed over time.<br/>
     * This 48-byte field is the output of a SHA-384 digest with input data
     * determined by the value of the `topicRunningHashVersion` field.<br/>
     * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
     * The bytes of each uint64 or uint32 encoded for the hash input MUST be
     * in Big-Endian format.
     * <p>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The most recent version is denoted by `topicRunningHashVersion = 3`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The `topic_running_hash_version` field (8 bytes)</li>
     *  <li>The payer account's shard (8 bytes)</li>
     *  <li>The payer account's realm (8 bytes)</li>
     *  <li>The payer account's number (8 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The output of a SHA-384 digest of the message bytes from the
     *      `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The next older version is denoted by `topicRunningHashVersion = 2`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The `topic_running_hash_version` field (8 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The output of a SHA-384 digest of the message bytes from the
     *      `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The original version, used at genesis, is denoted
     * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The message bytes from the `ConsensusSubmitMessage`
     *      (variable)</li>
     * </ol>
     *
     * Generated from protobuf field <code>bytes topicRunningHash = 8;</code>
     */
    protected $topicRunningHash = '';
    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the version of the
     * SHA-384 digest inputs used to update the running hash.
     *
     * Generated from protobuf field <code>uint64 topicRunningHashVersion = 9;</code>
     */
    protected $topicRunningHashVersion = 0;
    /**
     **
     * In the receipt of a `CreateToken`, the id of the newly created token
     *
     * Generated from protobuf field <code>.proto.TokenID tokenID = 10;</code>
     */
    protected $tokenID = null;
    /**
     **
     * In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
     * For non-unique tokens, the current total supply of that token.<br/>
     * For unique tokens,the total number of NFTs issued for that token.
     *
     * Generated from protobuf field <code>uint64 newTotalSupply = 11;</code>
     */
    protected $newTotalSupply = 0;
    /**
     **
     * In the receipt of a `ScheduleCreate`, the id of the newly created
     * Scheduled Entity
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleID = 12;</code>
     */
    protected $scheduleID = null;
    /**
     **
     * In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
     * scheduled transaction to execute immediately, the `TransactionID` that
     * should be used to query for the receipt or record of the scheduled
     * transaction that was executed.
     *
     * Generated from protobuf field <code>.proto.TransactionID scheduledTransactionID = 13;</code>
     */
    protected $scheduledTransactionID = null;
    /**
     **
     * In the receipt of a `TokenMint` for non-fungible/unique tokens,
     * the serial numbers of the newly created tokens.
     *
     * Generated from protobuf field <code>repeated int64 serialNumbers = 14;</code>
     */
    private $serialNumbers;
    /**
     **
     * An affected node identifier.<br/>
     * In the receipt of a NodeCreate, the id of the newly created node.
     * <p>
     * This value SHALL be set following a `createNode` transaction.<br/>
     * This value SHALL NOT be set following any other transaction.
     *
     * Generated from protobuf field <code>uint64 node_id = 15;</code>
     */
    protected $node_id = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int $status
     *          *
     *           The consensus status of the transaction.
     *           <p>
     *           This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
     *           This SHALL be `UNKNOWN` if the associated transaction did not have
     *           a valid payer signature.
     *     @type \Proto\AccountID $accountID
     *          *
     *           In the receipt of a `CryptoCreate`, the id of the newly created account.
     *     @type \Proto\FileID $fileID
     *          *
     *           In the receipt of a `FileCreate`, the id of the newly created file.
     *     @type \Proto\ContractID $contractID
     *          *
     *           In the receipt of a `ContractCreate`, the id of the newly created
     *           contract.
     *     @type \Proto\ExchangeRateSet $exchangeRate
     *          *
     *           The exchange rates in effect when the transaction reached consensus.
     *     @type \Proto\TopicID $topicID
     *          *
     *           In the receipt of a `ConsensusCreateTopic`, the id of the newly
     *           created topic.
     *     @type int|string $topicSequenceNumber
     *          *
     *           In the receipt of a `ConsensusSubmitMessage`, the new sequence
     *           number for the topic that received the message.
     *     @type string $topicRunningHash
     *          *
     *           In the receipt of a `ConsensusSubmitMessage`, the new running hash of
     *           the topic that received the message.<br/>
     *           <p>
     *           The inputs to the topic running hash have changed over time.<br/>
     *           This 48-byte field is the output of a SHA-384 digest with input data
     *           determined by the value of the `topicRunningHashVersion` field.<br/>
     *           All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
     *           The bytes of each uint64 or uint32 encoded for the hash input MUST be
     *           in Big-Endian format.
     *           <p>
     *           <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     *           <p>
     *           The most recent version is denoted by `topicRunningHashVersion = 3`.
     *           <p>
     *           This version SHALL include, in order
     *           <ol>
     *            <li>The previous running hash of the topic (48 bytes)</li>
     *            <li>The `topic_running_hash_version` field (8 bytes)</li>
     *            <li>The payer account's shard (8 bytes)</li>
     *            <li>The payer account's realm (8 bytes)</li>
     *            <li>The payer account's number (8 bytes)</li>
     *            <li>The topic's shard (8 bytes)</li>
     *            <li>The topic's realm (8 bytes)</li>
     *            <li>The topic's number (8 bytes)</li>
     *            <li>The number of seconds since the epoch when the
     *                `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *            <li>The number of nanoseconds within the second when the
     *                `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *            <li>The `topic_sequence_number` field (8 bytes)</li>
     *            <li>The output of a SHA-384 digest of the message bytes from the
     *                `ConsensusSubmitMessage` (48 bytes)</li>
     *           </ol>
     *           <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     *           <p>
     *           The next older version is denoted by `topicRunningHashVersion = 2`.
     *           <p>
     *           This version SHALL include, in order
     *           <ol>
     *            <li>The previous running hash of the topic (48 bytes)</li>
     *            <li>The `topic_running_hash_version` field (8 bytes)</li>
     *            <li>The topic's shard (8 bytes)</li>
     *            <li>The topic's realm (8 bytes)</li>
     *            <li>The topic's number (8 bytes)</li>
     *            <li>The number of seconds since the epoch when the
     *                `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *            <li>The number of nanoseconds within the second when the
     *                `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *            <li>The `topic_sequence_number` field (8 bytes)</li>
     *            <li>The output of a SHA-384 digest of the message bytes from the
     *                `ConsensusSubmitMessage` (48 bytes)</li>
     *           </ol>
     *           <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     *           <p>
     *           The original version, used at genesis, is denoted
     *           by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
     *           <p>
     *           This version SHALL include, in order
     *           <ol>
     *            <li>The previous running hash of the topic (48 bytes)</li>
     *            <li>The topic's shard (8 bytes)</li>
     *            <li>The topic's realm (8 bytes)</li>
     *            <li>The topic's number (8 bytes)</li>
     *            <li>The number of seconds since the epoch when the
     *                `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *            <li>The number of nanoseconds within the second when the
     *                `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *            <li>The `topic_sequence_number` field (8 bytes)</li>
     *            <li>The message bytes from the `ConsensusSubmitMessage`
     *                (variable)</li>
     *           </ol>
     *     @type int|string $topicRunningHashVersion
     *          *
     *           In the receipt of a `ConsensusSubmitMessage`, the version of the
     *           SHA-384 digest inputs used to update the running hash.
     *     @type \Proto\TokenID $tokenID
     *          *
     *           In the receipt of a `CreateToken`, the id of the newly created token
     *     @type int|string $newTotalSupply
     *          *
     *           In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
     *           For non-unique tokens, the current total supply of that token.<br/>
     *           For unique tokens,the total number of NFTs issued for that token.
     *     @type \Proto\ScheduleID $scheduleID
     *          *
     *           In the receipt of a `ScheduleCreate`, the id of the newly created
     *           Scheduled Entity
     *     @type \Proto\TransactionID $scheduledTransactionID
     *          *
     *           In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
     *           scheduled transaction to execute immediately, the `TransactionID` that
     *           should be used to query for the receipt or record of the scheduled
     *           transaction that was executed.
     *     @type int[]|string[] $serialNumbers
     *          *
     *           In the receipt of a `TokenMint` for non-fungible/unique tokens,
     *           the serial numbers of the newly created tokens.
     *     @type int|string $node_id
     *          *
     *           An affected node identifier.<br/>
     *           In the receipt of a NodeCreate, the id of the newly created node.
     *           <p>
     *           This value SHALL be set following a `createNode` transaction.<br/>
     *           This value SHALL NOT be set following any other transaction.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\TransactionReceipt::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * The consensus status of the transaction.
     * <p>
     * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
     * This SHALL be `UNKNOWN` if the associated transaction did not have
     * a valid payer signature.
     *
     * Generated from protobuf field <code>.proto.ResponseCodeEnum status = 1;</code>
     * @return int
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     **
     * The consensus status of the transaction.
     * <p>
     * This SHALL be `UNKNOWN` if consensus has not been reached.<br/>
     * This SHALL be `UNKNOWN` if the associated transaction did not have
     * a valid payer signature.
     *
     * Generated from protobuf field <code>.proto.ResponseCodeEnum status = 1;</code>
     * @param int $var
     * @return $this
     */
    public function setStatus($var)
    {
        GPBUtil::checkEnum($var, \Proto\ResponseCodeEnum::class);
        $this->status = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `CryptoCreate`, the id of the newly created account.
     *
     * Generated from protobuf field <code>.proto.AccountID accountID = 2;</code>
     * @return \Proto\AccountID|null
     */
    public function getAccountID()
    {
        return $this->accountID;
    }

    public function hasAccountID()
    {
        return isset($this->accountID);
    }

    public function clearAccountID()
    {
        unset($this->accountID);
    }

    /**
     **
     * In the receipt of a `CryptoCreate`, the id of the newly created account.
     *
     * Generated from protobuf field <code>.proto.AccountID accountID = 2;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setAccountID($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->accountID = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `FileCreate`, the id of the newly created file.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 3;</code>
     * @return \Proto\FileID|null
     */
    public function getFileID()
    {
        return $this->fileID;
    }

    public function hasFileID()
    {
        return isset($this->fileID);
    }

    public function clearFileID()
    {
        unset($this->fileID);
    }

    /**
     **
     * In the receipt of a `FileCreate`, the id of the newly created file.
     *
     * Generated from protobuf field <code>.proto.FileID fileID = 3;</code>
     * @param \Proto\FileID $var
     * @return $this
     */
    public function setFileID($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileID::class);
        $this->fileID = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ContractCreate`, the id of the newly created
     * contract.
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 4;</code>
     * @return \Proto\ContractID|null
     */
    public function getContractID()
    {
        return $this->contractID;
    }

    public function hasContractID()
    {
        return isset($this->contractID);
    }

    public function clearContractID()
    {
        unset($this->contractID);
    }

    /**
     **
     * In the receipt of a `ContractCreate`, the id of the newly created
     * contract.
     *
     * Generated from protobuf field <code>.proto.ContractID contractID = 4;</code>
     * @param \Proto\ContractID $var
     * @return $this
     */
    public function setContractID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractID::class);
        $this->contractID = $var;

        return $this;
    }

    /**
     **
     * The exchange rates in effect when the transaction reached consensus.
     *
     * Generated from protobuf field <code>.proto.ExchangeRateSet exchangeRate = 5;</code>
     * @return \Proto\ExchangeRateSet|null
     */
    public function getExchangeRate()
    {
        return $this->exchangeRate;
    }

    public function hasExchangeRate()
    {
        return isset($this->exchangeRate);
    }

    public function clearExchangeRate()
    {
        unset($this->exchangeRate);
    }

    /**
     **
     * The exchange rates in effect when the transaction reached consensus.
     *
     * Generated from protobuf field <code>.proto.ExchangeRateSet exchangeRate = 5;</code>
     * @param \Proto\ExchangeRateSet $var
     * @return $this
     */
    public function setExchangeRate($var)
    {
        GPBUtil::checkMessage($var, \Proto\ExchangeRateSet::class);
        $this->exchangeRate = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ConsensusCreateTopic`, the id of the newly
     * created topic.
     *
     * Generated from protobuf field <code>.proto.TopicID topicID = 6;</code>
     * @return \Proto\TopicID|null
     */
    public function getTopicID()
    {
        return $this->topicID;
    }

    public function hasTopicID()
    {
        return isset($this->topicID);
    }

    public function clearTopicID()
    {
        unset($this->topicID);
    }

    /**
     **
     * In the receipt of a `ConsensusCreateTopic`, the id of the newly
     * created topic.
     *
     * Generated from protobuf field <code>.proto.TopicID topicID = 6;</code>
     * @param \Proto\TopicID $var
     * @return $this
     */
    public function setTopicID($var)
    {
        GPBUtil::checkMessage($var, \Proto\TopicID::class);
        $this->topicID = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the new sequence
     * number for the topic that received the message.
     *
     * Generated from protobuf field <code>uint64 topicSequenceNumber = 7;</code>
     * @return int|string
     */
    public function getTopicSequenceNumber()
    {
        return $this->topicSequenceNumber;
    }

    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the new sequence
     * number for the topic that received the message.
     *
     * Generated from protobuf field <code>uint64 topicSequenceNumber = 7;</code>
     * @param int|string $var
     * @return $this
     */
    public function setTopicSequenceNumber($var)
    {
        GPBUtil::checkUint64($var);
        $this->topicSequenceNumber = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the new running hash of
     * the topic that received the message.<br/>
     * <p>
     * The inputs to the topic running hash have changed over time.<br/>
     * This 48-byte field is the output of a SHA-384 digest with input data
     * determined by the value of the `topicRunningHashVersion` field.<br/>
     * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
     * The bytes of each uint64 or uint32 encoded for the hash input MUST be
     * in Big-Endian format.
     * <p>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The most recent version is denoted by `topicRunningHashVersion = 3`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The `topic_running_hash_version` field (8 bytes)</li>
     *  <li>The payer account's shard (8 bytes)</li>
     *  <li>The payer account's realm (8 bytes)</li>
     *  <li>The payer account's number (8 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The output of a SHA-384 digest of the message bytes from the
     *      `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The next older version is denoted by `topicRunningHashVersion = 2`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The `topic_running_hash_version` field (8 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The output of a SHA-384 digest of the message bytes from the
     *      `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The original version, used at genesis, is denoted
     * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The message bytes from the `ConsensusSubmitMessage`
     *      (variable)</li>
     * </ol>
     *
     * Generated from protobuf field <code>bytes topicRunningHash = 8;</code>
     * @return string
     */
    public function getTopicRunningHash()
    {
        return $this->topicRunningHash;
    }

    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the new running hash of
     * the topic that received the message.<br/>
     * <p>
     * The inputs to the topic running hash have changed over time.<br/>
     * This 48-byte field is the output of a SHA-384 digest with input data
     * determined by the value of the `topicRunningHashVersion` field.<br/>
     * All new transactions SHALL use `topicRunningHashVersion` `3`.<br/>
     * The bytes of each uint64 or uint32 encoded for the hash input MUST be
     * in Big-Endian format.
     * <p>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The most recent version is denoted by `topicRunningHashVersion = 3`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The `topic_running_hash_version` field (8 bytes)</li>
     *  <li>The payer account's shard (8 bytes)</li>
     *  <li>The payer account's realm (8 bytes)</li>
     *  <li>The payer account's number (8 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The output of a SHA-384 digest of the message bytes from the
     *      `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The next older version is denoted by `topicRunningHashVersion = 2`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The `topic_running_hash_version` field (8 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The output of a SHA-384 digest of the message bytes from the
     *      `ConsensusSubmitMessage` (48 bytes)</li>
     * </ol>
     * <hr style="margin: 0.2em 5em 0.2em 5em; height: 0.5em; border-style: solid none solid none; border-width: 2px;"/>
     * <p>
     * The original version, used at genesis, is denoted
     * by `topicRunningHashVersion = 1` or `topicRunningHashVersion = 0`.
     * <p>
     * This version SHALL include, in order
     * <ol>
     *  <li>The previous running hash of the topic (48 bytes)</li>
     *  <li>The topic's shard (8 bytes)</li>
     *  <li>The topic's realm (8 bytes)</li>
     *  <li>The topic's number (8 bytes)</li>
     *  <li>The number of seconds since the epoch when the
     *      `ConsensusSubmitMessage` reached consensus (8 bytes)</li>
     *  <li>The number of nanoseconds within the second when the
     *      `ConsensusSubmitMessage` reached consensus (4 bytes)</li>
     *  <li>The `topic_sequence_number` field (8 bytes)</li>
     *  <li>The message bytes from the `ConsensusSubmitMessage`
     *      (variable)</li>
     * </ol>
     *
     * Generated from protobuf field <code>bytes topicRunningHash = 8;</code>
     * @param string $var
     * @return $this
     */
    public function setTopicRunningHash($var)
    {
        GPBUtil::checkString($var, False);
        $this->topicRunningHash = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the version of the
     * SHA-384 digest inputs used to update the running hash.
     *
     * Generated from protobuf field <code>uint64 topicRunningHashVersion = 9;</code>
     * @return int|string
     */
    public function getTopicRunningHashVersion()
    {
        return $this->topicRunningHashVersion;
    }

    /**
     **
     * In the receipt of a `ConsensusSubmitMessage`, the version of the
     * SHA-384 digest inputs used to update the running hash.
     *
     * Generated from protobuf field <code>uint64 topicRunningHashVersion = 9;</code>
     * @param int|string $var
     * @return $this
     */
    public function setTopicRunningHashVersion($var)
    {
        GPBUtil::checkUint64($var);
        $this->topicRunningHashVersion = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `CreateToken`, the id of the newly created token
     *
     * Generated from protobuf field <code>.proto.TokenID tokenID = 10;</code>
     * @return \Proto\TokenID|null
     */
    public function getTokenID()
    {
        return $this->tokenID;
    }

    public function hasTokenID()
    {
        return isset($this->tokenID);
    }

    public function clearTokenID()
    {
        unset($this->tokenID);
    }

    /**
     **
     * In the receipt of a `CreateToken`, the id of the newly created token
     *
     * Generated from protobuf field <code>.proto.TokenID tokenID = 10;</code>
     * @param \Proto\TokenID $var
     * @return $this
     */
    public function setTokenID($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenID::class);
        $this->tokenID = $var;

        return $this;
    }

    /**
     **
     * In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
     * For non-unique tokens, the current total supply of that token.<br/>
     * For unique tokens,the total number of NFTs issued for that token.
     *
     * Generated from protobuf field <code>uint64 newTotalSupply = 11;</code>
     * @return int|string
     */
    public function getNewTotalSupply()
    {
        return $this->newTotalSupply;
    }

    /**
     **
     * In the receipt of `TokenMint`, `TokenWipe`, or `TokenBurn`.<br/>
     * For non-unique tokens, the current total supply of that token.<br/>
     * For unique tokens,the total number of NFTs issued for that token.
     *
     * Generated from protobuf field <code>uint64 newTotalSupply = 11;</code>
     * @param int|string $var
     * @return $this
     */
    public function setNewTotalSupply($var)
    {
        GPBUtil::checkUint64($var);
        $this->newTotalSupply = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ScheduleCreate`, the id of the newly created
     * Scheduled Entity
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleID = 12;</code>
     * @return \Proto\ScheduleID|null
     */
    public function getScheduleID()
    {
        return $this->scheduleID;
    }

    public function hasScheduleID()
    {
        return isset($this->scheduleID);
    }

    public function clearScheduleID()
    {
        unset($this->scheduleID);
    }

    /**
     **
     * In the receipt of a `ScheduleCreate`, the id of the newly created
     * Scheduled Entity
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleID = 12;</code>
     * @param \Proto\ScheduleID $var
     * @return $this
     */
    public function setScheduleID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleID::class);
        $this->scheduleID = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
     * scheduled transaction to execute immediately, the `TransactionID` that
     * should be used to query for the receipt or record of the scheduled
     * transaction that was executed.
     *
     * Generated from protobuf field <code>.proto.TransactionID scheduledTransactionID = 13;</code>
     * @return \Proto\TransactionID|null
     */
    public function getScheduledTransactionID()
    {
        return $this->scheduledTransactionID;
    }

    public function hasScheduledTransactionID()
    {
        return isset($this->scheduledTransactionID);
    }

    public function clearScheduledTransactionID()
    {
        unset($this->scheduledTransactionID);
    }

    /**
     **
     * In the receipt of a `ScheduleCreate` or `ScheduleSign` that enables the
     * scheduled transaction to execute immediately, the `TransactionID` that
     * should be used to query for the receipt or record of the scheduled
     * transaction that was executed.
     *
     * Generated from protobuf field <code>.proto.TransactionID scheduledTransactionID = 13;</code>
     * @param \Proto\TransactionID $var
     * @return $this
     */
    public function setScheduledTransactionID($var)
    {
        GPBUtil::checkMessage($var, \Proto\TransactionID::class);
        $this->scheduledTransactionID = $var;

        return $this;
    }

    /**
     **
     * In the receipt of a `TokenMint` for non-fungible/unique tokens,
     * the serial numbers of the newly created tokens.
     *
     * Generated from protobuf field <code>repeated int64 serialNumbers = 14;</code>
     * @return RepeatedField<int>|RepeatedField<string>
     */
    public function getSerialNumbers()
    {
        return $this->serialNumbers;
    }

    /**
     **
     * In the receipt of a `TokenMint` for non-fungible/unique tokens,
     * the serial numbers of the newly created tokens.
     *
     * Generated from protobuf field <code>repeated int64 serialNumbers = 14;</code>
     * @param int[]|string[] $var
     * @return $this
     */
    public function setSerialNumbers($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::INT64);
        $this->serialNumbers = $arr;

        return $this;
    }

    /**
     **
     * An affected node identifier.<br/>
     * In the receipt of a NodeCreate, the id of the newly created node.
     * <p>
     * This value SHALL be set following a `createNode` transaction.<br/>
     * This value SHALL NOT be set following any other transaction.
     *
     * Generated from protobuf field <code>uint64 node_id = 15;</code>
     * @return int|string
     */
    public function getNodeId()
    {
        return $this->node_id;
    }

    /**
     **
     * An affected node identifier.<br/>
     * In the receipt of a NodeCreate, the id of the newly created node.
     * <p>
     * This value SHALL be set following a `createNode` transaction.<br/>
     * This value SHALL NOT be set following any other transaction.
     *
     * Generated from protobuf field <code>uint64 node_id = 15;</code>
     * @param int|string $var
     * @return $this
     */
    public function setNodeId($var)
    {
        GPBUtil::checkUint64($var);
        $this->node_id = $var;

        return $this;
    }

}

