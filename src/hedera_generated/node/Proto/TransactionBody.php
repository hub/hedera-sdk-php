<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: transaction.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A transaction body.
 * Every transaction is structured as a signed byte array. That byte array
 * is a serialized `TransactionBody`.  The transaction body contains the full
 * content of the transaction, while the `SignedTransaction` includes a
 * signature map for signatures authenticating that byte array, and that is
 * serialized and transmitted wrapped in a `Transaction` message.<br/>
 * The bulk of this message is a `oneof` block which offers the option for
 * any one of the transaction messages for the network.
 * This message also includes several additional fields to specify
 * various parameters required to process a transaction.
 *
 * Generated from protobuf message <code>proto.TransactionBody</code>
 */
class TransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A transaction identifier.<br/>
     * Each transaction is uniquely identified by its transaction
     * identifier.
     * <p>
     * Each transaction identifier MUST be unique.<br/>
     * Multiple transactions MAY be submitted with the same transaction
     * identifier, but all except the first SHALL be rejected as duplicate
     * transactions.<br/>
     * This identifier MUST specify a `payer` account to be charged
     * all fees associated with the transaction.<br/>
     * This identifier MUST specify a "valid start time".<br/>
     * The "valid start time" MUST be strictly _earlier_ than the current
     * network consensus time.<br/>
     * The "valid start time" MUST NOT be more than the current network
     * configuration value for `transaction.maxValidDuration` seconds
     * before the current network consensus time.<br/>
     * This identifier MUST NOT set the `scheduled` flag.<br/>
     * This identifier MUST NOT set a nonce value.
     *
     * Generated from protobuf field <code>.proto.TransactionID transactionID = 1;</code>
     */
    protected $transactionID = null;
    /**
     **
     * A node account identifier.
     * <p>
     * This MUST identify the account of the consensus node to which
     * this transaction is submitted.
     *
     * Generated from protobuf field <code>.proto.AccountID nodeAccountID = 2;</code>
     */
    protected $nodeAccountID = null;
    /**
     **
     * A maximum transaction fee, in tinybar.
     * <p>
     * The network SHALL NOT charge a transaction fee that exceeds this
     * amount.<br/>
     * The network MAY charge up to this amount, and reject the transaction,
     * if the amount offered is insufficient to cover the required fees.<br/>
     * The network MAY charge a minimum fee equal to 80% of the amount offered
     * if the amount offered is much larger than the required fees.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 3;</code>
     */
    protected $transactionFee = 0;
    /**
     **
     * A maximum duration in which to execute this transaction.
     * <p>
     * This transaction SHALL be rejected as expired if the valid start time,
     * extended by this duration, is less than the current network consensus
     * time when the transaction is submitted.<br/>
     * This transaction SHALL be rejected with an invalid duration if this
     * value is greater than the current network configuration value for
     * `transaction.maxValidDuration`.
     *
     * Generated from protobuf field <code>.proto.Duration transactionValidDuration = 4;</code>
     */
    protected $transactionValidDuration = null;
    /**
     **
     * Records are always generated.<br/>
     * Obsolete option to not generate a record.
     * <p>
     * This flag SHALL be ignored. Every transaction SHALL generate a record,
     * or block stream equivalent.
     *
     * Generated from protobuf field <code>bool generateRecord = 5 [deprecated = true];</code>
     * @deprecated
     */
    protected $generateRecord = false;
    /**
     **
     * A short description for this transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 6;</code>
     */
    protected $memo = '';
    /**
     **
     * The <b>public key</b> of the trusted batch assembler.
     *
     * Generated from protobuf field <code>.proto.Key batch_key = 73;</code>
     */
    protected $batch_key = null;
    /**
     **
     * A list of maximum custom fees that the users are willing to pay.
     * <p>
     * This field is OPTIONAL.<br/>
     * If left empty, the users are accepting to pay any custom fee.<br/>
     * If used with a transaction type that does not support custom fee limits, the transaction will fail.
     *
     * Generated from protobuf field <code>repeated .proto.CustomFeeLimit max_custom_fees = 1001;</code>
     */
    private $max_custom_fees;
    protected $data;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\TransactionID $transactionID
     *          *
     *           A transaction identifier.<br/>
     *           Each transaction is uniquely identified by its transaction
     *           identifier.
     *           <p>
     *           Each transaction identifier MUST be unique.<br/>
     *           Multiple transactions MAY be submitted with the same transaction
     *           identifier, but all except the first SHALL be rejected as duplicate
     *           transactions.<br/>
     *           This identifier MUST specify a `payer` account to be charged
     *           all fees associated with the transaction.<br/>
     *           This identifier MUST specify a "valid start time".<br/>
     *           The "valid start time" MUST be strictly _earlier_ than the current
     *           network consensus time.<br/>
     *           The "valid start time" MUST NOT be more than the current network
     *           configuration value for `transaction.maxValidDuration` seconds
     *           before the current network consensus time.<br/>
     *           This identifier MUST NOT set the `scheduled` flag.<br/>
     *           This identifier MUST NOT set a nonce value.
     *     @type \Proto\AccountID $nodeAccountID
     *          *
     *           A node account identifier.
     *           <p>
     *           This MUST identify the account of the consensus node to which
     *           this transaction is submitted.
     *     @type int|string $transactionFee
     *          *
     *           A maximum transaction fee, in tinybar.
     *           <p>
     *           The network SHALL NOT charge a transaction fee that exceeds this
     *           amount.<br/>
     *           The network MAY charge up to this amount, and reject the transaction,
     *           if the amount offered is insufficient to cover the required fees.<br/>
     *           The network MAY charge a minimum fee equal to 80% of the amount offered
     *           if the amount offered is much larger than the required fees.
     *     @type \Proto\Duration $transactionValidDuration
     *          *
     *           A maximum duration in which to execute this transaction.
     *           <p>
     *           This transaction SHALL be rejected as expired if the valid start time,
     *           extended by this duration, is less than the current network consensus
     *           time when the transaction is submitted.<br/>
     *           This transaction SHALL be rejected with an invalid duration if this
     *           value is greater than the current network configuration value for
     *           `transaction.maxValidDuration`.
     *     @type bool $generateRecord
     *          *
     *           Records are always generated.<br/>
     *           Obsolete option to not generate a record.
     *           <p>
     *           This flag SHALL be ignored. Every transaction SHALL generate a record,
     *           or block stream equivalent.
     *     @type string $memo
     *          *
     *           A short description for this transaction.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type \Proto\Key $batch_key
     *          *
     *           The <b>public key</b> of the trusted batch assembler.
     *     @type \Proto\ContractCallTransactionBody $contractCall
     *          *
     *           Call a function defined on a smart contract.
     *     @type \Proto\ContractCreateTransactionBody $contractCreateInstance
     *          *
     *           Create a smart contract.
     *     @type \Proto\ContractUpdateTransactionBody $contractUpdateInstance
     *          *
     *           Update a smart contract.
     *     @type \Proto\CryptoAddLiveHashTransactionBody $cryptoAddLiveHash
     *          *
     *           An obsolete, and unsupported, operation to add a "live hash" to
     *           an account.
     *     @type \Proto\CryptoCreateTransactionBody $cryptoCreateAccount
     *          *
     *           Create a new Hedera account.
     *     @type \Proto\CryptoDeleteTransactionBody $cryptoDelete
     *          *
     *           Delete an Hedera account.<br/>
     *           This will mark the account as deleted, and transfer all remaining
     *           HBAR to a receiver account.
     *     @type \Proto\CryptoDeleteLiveHashTransactionBody $cryptoDeleteLiveHash
     *          *
     *           An obsolete, and unsupported, operation to remove a "live hash" from
     *           an account.
     *     @type \Proto\CryptoTransferTransactionBody $cryptoTransfer
     *          *
     *           Transfer HBAR between accounts.
     *     @type \Proto\CryptoUpdateTransactionBody $cryptoUpdateAccount
     *          *
     *           Modify an Hedera account.
     *     @type \Proto\FileAppendTransactionBody $fileAppend
     *          *
     *           Append data to the end of a file.
     *     @type \Proto\FileCreateTransactionBody $fileCreate
     *          *
     *           Create a new file.
     *     @type \Proto\FileDeleteTransactionBody $fileDelete
     *          *
     *           Delete a file.<br/>
     *           This will remove the content of the file, and mark the file as
     *           deleted.
     *     @type \Proto\FileUpdateTransactionBody $fileUpdate
     *          *
     *           Modify a file.<br/>
     *           This may modify any metadata, and/or _replace_ the content.
     *     @type \Proto\SystemDeleteTransactionBody $systemDelete
     *          *
     *           Delete a file as an Hedera administrative function.<br/>
     *           This is a privileged operation.
     *     @type \Proto\SystemUndeleteTransactionBody $systemUndelete
     *          *
     *           Restore a file deleted via `systemDelete`.<br/>
     *           This is a privileged operation.
     *     @type \Proto\ContractDeleteTransactionBody $contractDeleteInstance
     *          *
     *           Delete a smart contract and transfer remaining balance
     *           to a specified account.
     *     @type \Proto\FreezeTransactionBody $freeze
     *          *
     *           Freeze the network.<br/>
     *           This is actually several possible operations, and the caller
     *           should examine the "freeze service" for more detail.<br/>
     *           This is a privileged operation.
     *     @type \Proto\ConsensusCreateTopicTransactionBody $consensusCreateTopic
     *          *
     *           Create a topic.
     *     @type \Proto\ConsensusUpdateTopicTransactionBody $consensusUpdateTopic
     *          *
     *           Update a topic.
     *     @type \Proto\ConsensusDeleteTopicTransactionBody $consensusDeleteTopic
     *          *
     *           Delete a topic.
     *     @type \Proto\ConsensusSubmitMessageTransactionBody $consensusSubmitMessage
     *          *
     *           Submit a message to a topic.<br/>
     *           A message may be "chunked", and submitted in parts, if the total
     *           message size exceeds the limit for a single transaction.
     *     @type \Proto\UncheckedSubmitBody $uncheckedSubmit
     *          *
     *           Unsupported system transaction.
     *           <p>
     *           This transaction MAY be implemented in testing networks, but
     *           SHALL NOT be enabled or supported in production environments.<br/>
     *           Clients MUST NOT call this method, and any such transaction SHALL
     *           be rejected.<br/>
     *           A network MAY choose to charge punitive fees for attempting to
     *           execute an `uncheckedSubmit`.
     *     @type \Proto\TokenCreateTransactionBody $tokenCreation
     *          *
     *           Create a new Hedera token.
     *     @type \Proto\TokenFreezeAccountTransactionBody $tokenFreeze
     *          *
     *           Freeze an account with respect to a token.<br/>
     *           A frozen account cannot transact in that token until unfrozen.
     *     @type \Proto\TokenUnfreezeAccountTransactionBody $tokenUnfreeze
     *          *
     *           Unfreeze an account with respect to a token.
     *     @type \Proto\TokenGrantKycTransactionBody $tokenGrantKyc
     *          *
     *           Grant KYC to an account with respect to a token.<br/>
     *           KYC is generally a "know your customer" assertion that a
     *           responsible entity has sufficient information to positively
     *           identify the account holder to relevant authorities.
     *     @type \Proto\TokenRevokeKycTransactionBody $tokenRevokeKyc
     *          *
     *           Revoke KYC from an account with respect to a token.
     *     @type \Proto\TokenDeleteTransactionBody $tokenDeletion
     *          *
     *           Delete an Hedera token.<br/>
     *           The token will be marked deleted.
     *     @type \Proto\TokenUpdateTransactionBody $tokenUpdate
     *          *
     *           Update an Hedera token.<br/>
     *           Depending on what fields are to be modified, the signature
     *           requirements will vary. See `TokenUpdateTransactionBody` for
     *           further detail.
     *     @type \Proto\TokenMintTransactionBody $tokenMint
     *          *
     *           Mint new tokens.<br/>
     *           All minted tokens will be delivered to the treasury account for
     *           the token type. The "mint key" for the token must sign this
     *           transaction.
     *     @type \Proto\TokenBurnTransactionBody $tokenBurn
     *          *
     *           Burn tokens from the treasury account.<br/>
     *           The "burn key" for the token must sign this transaction.
     *     @type \Proto\TokenWipeAccountTransactionBody $tokenWipe
     *          *
     *           Wipe tokens from an account.<br/>
     *           This will remove a specified amount of fungible/common tokens or
     *           a specified list of non-fungible/unique serial numbered tokens
     *           of a given token type from an Hedera account. The removed tokens
     *           are _burned_ as if by a `tokenBurn` transaction.<br/>
     *           The "wipe key" for the token must sign this transaction.
     *     @type \Proto\TokenAssociateTransactionBody $tokenAssociate
     *          *
     *           Associate tokens to an account.
     *     @type \Proto\TokenDissociateTransactionBody $tokenDissociate
     *          *
     *           Dissociate tokens from an account.
     *     @type \Proto\ScheduleCreateTransactionBody $scheduleCreate
     *          *
     *           Create a schedule.<br/>
     *           A schedule is a request to execute a specific transaction, included
     *           in the create body, in the future. The scheduled transaction may
     *           execute as soon as all signature requirements are met with the
     *           schedule create or a subsequent schedule sign transaction.
     *           A schedule may, alternatively, execute on expiration if
     *           long-term schedules are enabled and the schedule meets signature
     *           requirements at that time.
     *     @type \Proto\ScheduleDeleteTransactionBody $scheduleDelete
     *          *
     *           Delete a schedule.<br/>
     *           The schedule will be marked as deleted.
     *     @type \Proto\ScheduleSignTransactionBody $scheduleSign
     *          *
     *           Sign a schedule.<br/>
     *           Add one or more cryptographic keys to the list of keys that have
     *           signed a schedule, and which may serve to meet the signature
     *           requirements for the scheduled transaction.
     *     @type \Proto\TokenFeeScheduleUpdateTransactionBody $token_fee_schedule_update
     *          *
     *           Update the custom fee schedule for a token.<br/>
     *           This transaction must be signed by the "fee schedule key"
     *           for the token.
     *     @type \Proto\TokenPauseTransactionBody $token_pause
     *          *
     *           Pause a Token.
     *           <p>
     *           This transaction MUST be signed by the "pause key" for the token.
     *     @type \Proto\TokenUnpauseTransactionBody $token_unpause
     *          *
     *           Unpause a Token.
     *           <p>
     *           This transaction MUST be signed by the "pause key" for the token.
     *     @type \Proto\CryptoApproveAllowanceTransactionBody $cryptoApproveAllowance
     *          *
     *           Add one or more approved allowances for spenders to transfer the
     *           paying account's hbar or tokens.
     *     @type \Proto\CryptoDeleteAllowanceTransactionBody $cryptoDeleteAllowance
     *          *
     *           Delete one or more approvals for spenders to transfer the
     *           paying account's hbar or tokens.
     *     @type \Proto\EthereumTransactionBody $ethereumTransaction
     *          *
     *           Perform an Ethereum encoded transaction.
     *     @type \Proto\NodeStakeUpdateTransactionBody $node_stake_update
     *          *
     *           Update the staking information.<br/>
     *           This internal transaction is performed at the end of a staking
     *           period to complete staking calculations and indicate that new
     *           staking period has started.
     *     @type \Proto\UtilPrngTransactionBody $util_prng
     *          *
     *           Provide a deterministic pseudorandom number based on network state.
     *     @type \Proto\TokenUpdateNftsTransactionBody $token_update_nfts
     *          *
     *           Update one or more non-fungible/unique tokens.<br/>
     *           This will update metadata for one or more serial numbers within
     *           a collection (token type).
     *     @type \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody $nodeCreate
     *          *
     *           Create a new node in the network address book.<br/>
     *           This is a privileged operation.
     *           <p>
     *           This transaction SHALL create a new consensus node record and add
     *           that record to the network address book.
     *     @type \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody $nodeUpdate
     *          *
     *           Update a node in the network address book.<br/>
     *           This is a privileged operation.
     *           <p>
     *           This transaction SHALL update an existing consensus node record in
     *           the network address book.
     *     @type \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody $nodeDelete
     *          *
     *           Delete a node from the network address book.<br/>
     *           This is a privileged operation.
     *           <p>
     *           This transaction SHALL mark an existing consensus node record as
     *           deleted and remove that node from the network address book.
     *     @type \Proto\TokenRejectTransactionBody $tokenReject
     *          *
     *           Reject and return a token to treasury.<br/>
     *           This transaction will transfer one or more tokens or token
     *           balances held by the requesting account to the treasury
     *           for each token type.
     *           <p>
     *           Each transfer MUST be one of the following:
     *           <ul>
     *             <li>A single non-fungible/unique token.</li>
     *             <li>The full balance held for a fungible/common
     *                 token type.</li>
     *           </ul>
     *           When complete, the requesting account SHALL NOT hold the
     *           rejected tokens.<br/>
     *           Custom fees and royalties defined for the tokens rejected
     *           SHALL NOT be charged for this transaction.
     *     @type \Proto\TokenAirdropTransactionBody $tokenAirdrop
     *          *
     *           "Airdrop" tokens.<br/>
     *           This transaction sends tokens from one or more "sender" accounts
     *           to one or more "recipient" accounts.
     *           <p>
     *           If a recipient account cannot immediately receive the token(s) sent,
     *           a "pending" airdrop SHALL be created and MUST be claimed.
     *     @type \Proto\TokenCancelAirdropTransactionBody $tokenCancelAirdrop
     *          *
     *           Cancel one or more "pending" airdrops that are not yet claimed.
     *     @type \Proto\TokenClaimAirdropTransactionBody $tokenClaimAirdrop
     *          *
     *           Claim one or more "pending" airdrops.
     *     @type \Com\Hedera\Hapi\Platform\Event\StateSignatureTransaction $state_signature_transaction
     *          *
     *           A transaction body for signature of a state root hash gossiped to other nodes
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPreprocessingVoteTransactionBody $hints_preprocessing_vote
     *          *
     *           A transaction body for voting on hinTS aggregation keys.
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsKeyPublicationTransactionBody $hints_key_publication
     *          *
     *           A transaction body for publishing a node's hintTS key.
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPartialSignatureTransactionBody $hints_partial_signature
     *          *
     *           A transaction body for broadcasting a node's hintTS partial signature on a message.
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofSignatureTransactionBody $history_proof_signature
     *          *
     *           A transaction body for contributed a signature with a node's proof key to a history proof.
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofKeyPublicationTransactionBody $history_proof_key_publication
     *          *
     *           A transaction body for publishing a node's metadata proof key.
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofVoteTransactionBody $history_proof_vote
     *          *
     *           A transaction body for voting on a metadata proof descending from the ledger id.
     *     @type \Com\Hedera\Hapi\Services\Auxiliary\Hints\CrsPublicationTransactionBody $crs_publication
     *          *
     *           A transaction body for broadcasting a node's crs publication
     *     @type \Proto\AtomicBatchTransactionBody $atomic_batch
     *          *
     *           A transaction body for handling a set of transactions atomically.
     *     @type \Proto\CustomFeeLimit[] $max_custom_fees
     *          *
     *           A list of maximum custom fees that the users are willing to pay.
     *           <p>
     *           This field is OPTIONAL.<br/>
     *           If left empty, the users are accepting to pay any custom fee.<br/>
     *           If used with a transaction type that does not support custom fee limits, the transaction will fail.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Transaction::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A transaction identifier.<br/>
     * Each transaction is uniquely identified by its transaction
     * identifier.
     * <p>
     * Each transaction identifier MUST be unique.<br/>
     * Multiple transactions MAY be submitted with the same transaction
     * identifier, but all except the first SHALL be rejected as duplicate
     * transactions.<br/>
     * This identifier MUST specify a `payer` account to be charged
     * all fees associated with the transaction.<br/>
     * This identifier MUST specify a "valid start time".<br/>
     * The "valid start time" MUST be strictly _earlier_ than the current
     * network consensus time.<br/>
     * The "valid start time" MUST NOT be more than the current network
     * configuration value for `transaction.maxValidDuration` seconds
     * before the current network consensus time.<br/>
     * This identifier MUST NOT set the `scheduled` flag.<br/>
     * This identifier MUST NOT set a nonce value.
     *
     * Generated from protobuf field <code>.proto.TransactionID transactionID = 1;</code>
     * @return \Proto\TransactionID|null
     */
    public function getTransactionID()
    {
        return $this->transactionID;
    }

    public function hasTransactionID()
    {
        return isset($this->transactionID);
    }

    public function clearTransactionID()
    {
        unset($this->transactionID);
    }

    /**
     **
     * A transaction identifier.<br/>
     * Each transaction is uniquely identified by its transaction
     * identifier.
     * <p>
     * Each transaction identifier MUST be unique.<br/>
     * Multiple transactions MAY be submitted with the same transaction
     * identifier, but all except the first SHALL be rejected as duplicate
     * transactions.<br/>
     * This identifier MUST specify a `payer` account to be charged
     * all fees associated with the transaction.<br/>
     * This identifier MUST specify a "valid start time".<br/>
     * The "valid start time" MUST be strictly _earlier_ than the current
     * network consensus time.<br/>
     * The "valid start time" MUST NOT be more than the current network
     * configuration value for `transaction.maxValidDuration` seconds
     * before the current network consensus time.<br/>
     * This identifier MUST NOT set the `scheduled` flag.<br/>
     * This identifier MUST NOT set a nonce value.
     *
     * Generated from protobuf field <code>.proto.TransactionID transactionID = 1;</code>
     * @param \Proto\TransactionID $var
     * @return $this
     */
    public function setTransactionID($var)
    {
        GPBUtil::checkMessage($var, \Proto\TransactionID::class);
        $this->transactionID = $var;

        return $this;
    }

    /**
     **
     * A node account identifier.
     * <p>
     * This MUST identify the account of the consensus node to which
     * this transaction is submitted.
     *
     * Generated from protobuf field <code>.proto.AccountID nodeAccountID = 2;</code>
     * @return \Proto\AccountID|null
     */
    public function getNodeAccountID()
    {
        return $this->nodeAccountID;
    }

    public function hasNodeAccountID()
    {
        return isset($this->nodeAccountID);
    }

    public function clearNodeAccountID()
    {
        unset($this->nodeAccountID);
    }

    /**
     **
     * A node account identifier.
     * <p>
     * This MUST identify the account of the consensus node to which
     * this transaction is submitted.
     *
     * Generated from protobuf field <code>.proto.AccountID nodeAccountID = 2;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setNodeAccountID($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->nodeAccountID = $var;

        return $this;
    }

    /**
     **
     * A maximum transaction fee, in tinybar.
     * <p>
     * The network SHALL NOT charge a transaction fee that exceeds this
     * amount.<br/>
     * The network MAY charge up to this amount, and reject the transaction,
     * if the amount offered is insufficient to cover the required fees.<br/>
     * The network MAY charge a minimum fee equal to 80% of the amount offered
     * if the amount offered is much larger than the required fees.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 3;</code>
     * @return int|string
     */
    public function getTransactionFee()
    {
        return $this->transactionFee;
    }

    /**
     **
     * A maximum transaction fee, in tinybar.
     * <p>
     * The network SHALL NOT charge a transaction fee that exceeds this
     * amount.<br/>
     * The network MAY charge up to this amount, and reject the transaction,
     * if the amount offered is insufficient to cover the required fees.<br/>
     * The network MAY charge a minimum fee equal to 80% of the amount offered
     * if the amount offered is much larger than the required fees.
     *
     * Generated from protobuf field <code>uint64 transactionFee = 3;</code>
     * @param int|string $var
     * @return $this
     */
    public function setTransactionFee($var)
    {
        GPBUtil::checkUint64($var);
        $this->transactionFee = $var;

        return $this;
    }

    /**
     **
     * A maximum duration in which to execute this transaction.
     * <p>
     * This transaction SHALL be rejected as expired if the valid start time,
     * extended by this duration, is less than the current network consensus
     * time when the transaction is submitted.<br/>
     * This transaction SHALL be rejected with an invalid duration if this
     * value is greater than the current network configuration value for
     * `transaction.maxValidDuration`.
     *
     * Generated from protobuf field <code>.proto.Duration transactionValidDuration = 4;</code>
     * @return \Proto\Duration|null
     */
    public function getTransactionValidDuration()
    {
        return $this->transactionValidDuration;
    }

    public function hasTransactionValidDuration()
    {
        return isset($this->transactionValidDuration);
    }

    public function clearTransactionValidDuration()
    {
        unset($this->transactionValidDuration);
    }

    /**
     **
     * A maximum duration in which to execute this transaction.
     * <p>
     * This transaction SHALL be rejected as expired if the valid start time,
     * extended by this duration, is less than the current network consensus
     * time when the transaction is submitted.<br/>
     * This transaction SHALL be rejected with an invalid duration if this
     * value is greater than the current network configuration value for
     * `transaction.maxValidDuration`.
     *
     * Generated from protobuf field <code>.proto.Duration transactionValidDuration = 4;</code>
     * @param \Proto\Duration $var
     * @return $this
     */
    public function setTransactionValidDuration($var)
    {
        GPBUtil::checkMessage($var, \Proto\Duration::class);
        $this->transactionValidDuration = $var;

        return $this;
    }

    /**
     **
     * Records are always generated.<br/>
     * Obsolete option to not generate a record.
     * <p>
     * This flag SHALL be ignored. Every transaction SHALL generate a record,
     * or block stream equivalent.
     *
     * Generated from protobuf field <code>bool generateRecord = 5 [deprecated = true];</code>
     * @return bool
     * @deprecated
     */
    public function getGenerateRecord()
    {
        if ($this->generateRecord !== false) {
            @trigger_error('generateRecord is deprecated.', E_USER_DEPRECATED);
        }
        return $this->generateRecord;
    }

    /**
     **
     * Records are always generated.<br/>
     * Obsolete option to not generate a record.
     * <p>
     * This flag SHALL be ignored. Every transaction SHALL generate a record,
     * or block stream equivalent.
     *
     * Generated from protobuf field <code>bool generateRecord = 5 [deprecated = true];</code>
     * @param bool $var
     * @return $this
     * @deprecated
     */
    public function setGenerateRecord($var)
    {
        @trigger_error('generateRecord is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkBool($var);
        $this->generateRecord = $var;

        return $this;
    }

    /**
     **
     * A short description for this transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 6;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description for this transaction.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 6;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * The <b>public key</b> of the trusted batch assembler.
     *
     * Generated from protobuf field <code>.proto.Key batch_key = 73;</code>
     * @return \Proto\Key|null
     */
    public function getBatchKey()
    {
        return $this->batch_key;
    }

    public function hasBatchKey()
    {
        return isset($this->batch_key);
    }

    public function clearBatchKey()
    {
        unset($this->batch_key);
    }

    /**
     **
     * The <b>public key</b> of the trusted batch assembler.
     *
     * Generated from protobuf field <code>.proto.Key batch_key = 73;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setBatchKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->batch_key = $var;

        return $this;
    }

    /**
     **
     * Call a function defined on a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCallTransactionBody contractCall = 7;</code>
     * @return \Proto\ContractCallTransactionBody|null
     */
    public function getContractCall()
    {
        return $this->readOneof(7);
    }

    public function hasContractCall()
    {
        return $this->hasOneof(7);
    }

    /**
     **
     * Call a function defined on a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCallTransactionBody contractCall = 7;</code>
     * @param \Proto\ContractCallTransactionBody $var
     * @return $this
     */
    public function setContractCall($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractCallTransactionBody::class);
        $this->writeOneof(7, $var);

        return $this;
    }

    /**
     **
     * Create a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCreateTransactionBody contractCreateInstance = 8;</code>
     * @return \Proto\ContractCreateTransactionBody|null
     */
    public function getContractCreateInstance()
    {
        return $this->readOneof(8);
    }

    public function hasContractCreateInstance()
    {
        return $this->hasOneof(8);
    }

    /**
     **
     * Create a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractCreateTransactionBody contractCreateInstance = 8;</code>
     * @param \Proto\ContractCreateTransactionBody $var
     * @return $this
     */
    public function setContractCreateInstance($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractCreateTransactionBody::class);
        $this->writeOneof(8, $var);

        return $this;
    }

    /**
     **
     * Update a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractUpdateTransactionBody contractUpdateInstance = 9;</code>
     * @return \Proto\ContractUpdateTransactionBody|null
     */
    public function getContractUpdateInstance()
    {
        return $this->readOneof(9);
    }

    public function hasContractUpdateInstance()
    {
        return $this->hasOneof(9);
    }

    /**
     **
     * Update a smart contract.
     *
     * Generated from protobuf field <code>.proto.ContractUpdateTransactionBody contractUpdateInstance = 9;</code>
     * @param \Proto\ContractUpdateTransactionBody $var
     * @return $this
     */
    public function setContractUpdateInstance($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractUpdateTransactionBody::class);
        $this->writeOneof(9, $var);

        return $this;
    }

    /**
     **
     * An obsolete, and unsupported, operation to add a "live hash" to
     * an account.
     *
     * Generated from protobuf field <code>.proto.CryptoAddLiveHashTransactionBody cryptoAddLiveHash = 10 [deprecated = true];</code>
     * @return \Proto\CryptoAddLiveHashTransactionBody|null
     * @deprecated
     */
    public function getCryptoAddLiveHash()
    {
        if ($this->hasOneof(10)) {
            @trigger_error('cryptoAddLiveHash is deprecated.', E_USER_DEPRECATED);
        }
        return $this->readOneof(10);
    }

    public function hasCryptoAddLiveHash()
    {
        if ($this->hasOneof(10)) {
            @trigger_error('cryptoAddLiveHash is deprecated.', E_USER_DEPRECATED);
        }
        return $this->hasOneof(10);
    }

    /**
     **
     * An obsolete, and unsupported, operation to add a "live hash" to
     * an account.
     *
     * Generated from protobuf field <code>.proto.CryptoAddLiveHashTransactionBody cryptoAddLiveHash = 10 [deprecated = true];</code>
     * @param \Proto\CryptoAddLiveHashTransactionBody $var
     * @return $this
     * @deprecated
     */
    public function setCryptoAddLiveHash($var)
    {
        @trigger_error('cryptoAddLiveHash is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\CryptoAddLiveHashTransactionBody::class);
        $this->writeOneof(10, $var);

        return $this;
    }

    /**
     **
     * Create a new Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoCreateTransactionBody cryptoCreateAccount = 11;</code>
     * @return \Proto\CryptoCreateTransactionBody|null
     */
    public function getCryptoCreateAccount()
    {
        return $this->readOneof(11);
    }

    public function hasCryptoCreateAccount()
    {
        return $this->hasOneof(11);
    }

    /**
     **
     * Create a new Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoCreateTransactionBody cryptoCreateAccount = 11;</code>
     * @param \Proto\CryptoCreateTransactionBody $var
     * @return $this
     */
    public function setCryptoCreateAccount($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoCreateTransactionBody::class);
        $this->writeOneof(11, $var);

        return $this;
    }

    /**
     **
     * Delete an Hedera account.<br/>
     * This will mark the account as deleted, and transfer all remaining
     * HBAR to a receiver account.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteTransactionBody cryptoDelete = 12;</code>
     * @return \Proto\CryptoDeleteTransactionBody|null
     */
    public function getCryptoDelete()
    {
        return $this->readOneof(12);
    }

    public function hasCryptoDelete()
    {
        return $this->hasOneof(12);
    }

    /**
     **
     * Delete an Hedera account.<br/>
     * This will mark the account as deleted, and transfer all remaining
     * HBAR to a receiver account.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteTransactionBody cryptoDelete = 12;</code>
     * @param \Proto\CryptoDeleteTransactionBody $var
     * @return $this
     */
    public function setCryptoDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoDeleteTransactionBody::class);
        $this->writeOneof(12, $var);

        return $this;
    }

    /**
     **
     * An obsolete, and unsupported, operation to remove a "live hash" from
     * an account.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteLiveHashTransactionBody cryptoDeleteLiveHash = 13 [deprecated = true];</code>
     * @return \Proto\CryptoDeleteLiveHashTransactionBody|null
     * @deprecated
     */
    public function getCryptoDeleteLiveHash()
    {
        if ($this->hasOneof(13)) {
            @trigger_error('cryptoDeleteLiveHash is deprecated.', E_USER_DEPRECATED);
        }
        return $this->readOneof(13);
    }

    public function hasCryptoDeleteLiveHash()
    {
        if ($this->hasOneof(13)) {
            @trigger_error('cryptoDeleteLiveHash is deprecated.', E_USER_DEPRECATED);
        }
        return $this->hasOneof(13);
    }

    /**
     **
     * An obsolete, and unsupported, operation to remove a "live hash" from
     * an account.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteLiveHashTransactionBody cryptoDeleteLiveHash = 13 [deprecated = true];</code>
     * @param \Proto\CryptoDeleteLiveHashTransactionBody $var
     * @return $this
     * @deprecated
     */
    public function setCryptoDeleteLiveHash($var)
    {
        @trigger_error('cryptoDeleteLiveHash is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkMessage($var, \Proto\CryptoDeleteLiveHashTransactionBody::class);
        $this->writeOneof(13, $var);

        return $this;
    }

    /**
     **
     * Transfer HBAR between accounts.
     *
     * Generated from protobuf field <code>.proto.CryptoTransferTransactionBody cryptoTransfer = 14;</code>
     * @return \Proto\CryptoTransferTransactionBody|null
     */
    public function getCryptoTransfer()
    {
        return $this->readOneof(14);
    }

    public function hasCryptoTransfer()
    {
        return $this->hasOneof(14);
    }

    /**
     **
     * Transfer HBAR between accounts.
     *
     * Generated from protobuf field <code>.proto.CryptoTransferTransactionBody cryptoTransfer = 14;</code>
     * @param \Proto\CryptoTransferTransactionBody $var
     * @return $this
     */
    public function setCryptoTransfer($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoTransferTransactionBody::class);
        $this->writeOneof(14, $var);

        return $this;
    }

    /**
     **
     * Modify an Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 15;</code>
     * @return \Proto\CryptoUpdateTransactionBody|null
     */
    public function getCryptoUpdateAccount()
    {
        return $this->readOneof(15);
    }

    public function hasCryptoUpdateAccount()
    {
        return $this->hasOneof(15);
    }

    /**
     **
     * Modify an Hedera account.
     *
     * Generated from protobuf field <code>.proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 15;</code>
     * @param \Proto\CryptoUpdateTransactionBody $var
     * @return $this
     */
    public function setCryptoUpdateAccount($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoUpdateTransactionBody::class);
        $this->writeOneof(15, $var);

        return $this;
    }

    /**
     **
     * Append data to the end of a file.
     *
     * Generated from protobuf field <code>.proto.FileAppendTransactionBody fileAppend = 16;</code>
     * @return \Proto\FileAppendTransactionBody|null
     */
    public function getFileAppend()
    {
        return $this->readOneof(16);
    }

    public function hasFileAppend()
    {
        return $this->hasOneof(16);
    }

    /**
     **
     * Append data to the end of a file.
     *
     * Generated from protobuf field <code>.proto.FileAppendTransactionBody fileAppend = 16;</code>
     * @param \Proto\FileAppendTransactionBody $var
     * @return $this
     */
    public function setFileAppend($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileAppendTransactionBody::class);
        $this->writeOneof(16, $var);

        return $this;
    }

    /**
     **
     * Create a new file.
     *
     * Generated from protobuf field <code>.proto.FileCreateTransactionBody fileCreate = 17;</code>
     * @return \Proto\FileCreateTransactionBody|null
     */
    public function getFileCreate()
    {
        return $this->readOneof(17);
    }

    public function hasFileCreate()
    {
        return $this->hasOneof(17);
    }

    /**
     **
     * Create a new file.
     *
     * Generated from protobuf field <code>.proto.FileCreateTransactionBody fileCreate = 17;</code>
     * @param \Proto\FileCreateTransactionBody $var
     * @return $this
     */
    public function setFileCreate($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileCreateTransactionBody::class);
        $this->writeOneof(17, $var);

        return $this;
    }

    /**
     **
     * Delete a file.<br/>
     * This will remove the content of the file, and mark the file as
     * deleted.
     *
     * Generated from protobuf field <code>.proto.FileDeleteTransactionBody fileDelete = 18;</code>
     * @return \Proto\FileDeleteTransactionBody|null
     */
    public function getFileDelete()
    {
        return $this->readOneof(18);
    }

    public function hasFileDelete()
    {
        return $this->hasOneof(18);
    }

    /**
     **
     * Delete a file.<br/>
     * This will remove the content of the file, and mark the file as
     * deleted.
     *
     * Generated from protobuf field <code>.proto.FileDeleteTransactionBody fileDelete = 18;</code>
     * @param \Proto\FileDeleteTransactionBody $var
     * @return $this
     */
    public function setFileDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileDeleteTransactionBody::class);
        $this->writeOneof(18, $var);

        return $this;
    }

    /**
     **
     * Modify a file.<br/>
     * This may modify any metadata, and/or _replace_ the content.
     *
     * Generated from protobuf field <code>.proto.FileUpdateTransactionBody fileUpdate = 19;</code>
     * @return \Proto\FileUpdateTransactionBody|null
     */
    public function getFileUpdate()
    {
        return $this->readOneof(19);
    }

    public function hasFileUpdate()
    {
        return $this->hasOneof(19);
    }

    /**
     **
     * Modify a file.<br/>
     * This may modify any metadata, and/or _replace_ the content.
     *
     * Generated from protobuf field <code>.proto.FileUpdateTransactionBody fileUpdate = 19;</code>
     * @param \Proto\FileUpdateTransactionBody $var
     * @return $this
     */
    public function setFileUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileUpdateTransactionBody::class);
        $this->writeOneof(19, $var);

        return $this;
    }

    /**
     **
     * Delete a file as an Hedera administrative function.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemDeleteTransactionBody systemDelete = 20;</code>
     * @return \Proto\SystemDeleteTransactionBody|null
     */
    public function getSystemDelete()
    {
        return $this->readOneof(20);
    }

    public function hasSystemDelete()
    {
        return $this->hasOneof(20);
    }

    /**
     **
     * Delete a file as an Hedera administrative function.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemDeleteTransactionBody systemDelete = 20;</code>
     * @param \Proto\SystemDeleteTransactionBody $var
     * @return $this
     */
    public function setSystemDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\SystemDeleteTransactionBody::class);
        $this->writeOneof(20, $var);

        return $this;
    }

    /**
     **
     * Restore a file deleted via `systemDelete`.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemUndeleteTransactionBody systemUndelete = 21;</code>
     * @return \Proto\SystemUndeleteTransactionBody|null
     */
    public function getSystemUndelete()
    {
        return $this->readOneof(21);
    }

    public function hasSystemUndelete()
    {
        return $this->hasOneof(21);
    }

    /**
     **
     * Restore a file deleted via `systemDelete`.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.SystemUndeleteTransactionBody systemUndelete = 21;</code>
     * @param \Proto\SystemUndeleteTransactionBody $var
     * @return $this
     */
    public function setSystemUndelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\SystemUndeleteTransactionBody::class);
        $this->writeOneof(21, $var);

        return $this;
    }

    /**
     **
     * Delete a smart contract and transfer remaining balance
     * to a specified account.
     *
     * Generated from protobuf field <code>.proto.ContractDeleteTransactionBody contractDeleteInstance = 22;</code>
     * @return \Proto\ContractDeleteTransactionBody|null
     */
    public function getContractDeleteInstance()
    {
        return $this->readOneof(22);
    }

    public function hasContractDeleteInstance()
    {
        return $this->hasOneof(22);
    }

    /**
     **
     * Delete a smart contract and transfer remaining balance
     * to a specified account.
     *
     * Generated from protobuf field <code>.proto.ContractDeleteTransactionBody contractDeleteInstance = 22;</code>
     * @param \Proto\ContractDeleteTransactionBody $var
     * @return $this
     */
    public function setContractDeleteInstance($var)
    {
        GPBUtil::checkMessage($var, \Proto\ContractDeleteTransactionBody::class);
        $this->writeOneof(22, $var);

        return $this;
    }

    /**
     **
     * Freeze the network.<br/>
     * This is actually several possible operations, and the caller
     * should examine the "freeze service" for more detail.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.FreezeTransactionBody freeze = 23;</code>
     * @return \Proto\FreezeTransactionBody|null
     */
    public function getFreeze()
    {
        return $this->readOneof(23);
    }

    public function hasFreeze()
    {
        return $this->hasOneof(23);
    }

    /**
     **
     * Freeze the network.<br/>
     * This is actually several possible operations, and the caller
     * should examine the "freeze service" for more detail.<br/>
     * This is a privileged operation.
     *
     * Generated from protobuf field <code>.proto.FreezeTransactionBody freeze = 23;</code>
     * @param \Proto\FreezeTransactionBody $var
     * @return $this
     */
    public function setFreeze($var)
    {
        GPBUtil::checkMessage($var, \Proto\FreezeTransactionBody::class);
        $this->writeOneof(23, $var);

        return $this;
    }

    /**
     **
     * Create a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 24;</code>
     * @return \Proto\ConsensusCreateTopicTransactionBody|null
     */
    public function getConsensusCreateTopic()
    {
        return $this->readOneof(24);
    }

    public function hasConsensusCreateTopic()
    {
        return $this->hasOneof(24);
    }

    /**
     **
     * Create a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 24;</code>
     * @param \Proto\ConsensusCreateTopicTransactionBody $var
     * @return $this
     */
    public function setConsensusCreateTopic($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusCreateTopicTransactionBody::class);
        $this->writeOneof(24, $var);

        return $this;
    }

    /**
     **
     * Update a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 25;</code>
     * @return \Proto\ConsensusUpdateTopicTransactionBody|null
     */
    public function getConsensusUpdateTopic()
    {
        return $this->readOneof(25);
    }

    public function hasConsensusUpdateTopic()
    {
        return $this->hasOneof(25);
    }

    /**
     **
     * Update a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 25;</code>
     * @param \Proto\ConsensusUpdateTopicTransactionBody $var
     * @return $this
     */
    public function setConsensusUpdateTopic($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusUpdateTopicTransactionBody::class);
        $this->writeOneof(25, $var);

        return $this;
    }

    /**
     **
     * Delete a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 26;</code>
     * @return \Proto\ConsensusDeleteTopicTransactionBody|null
     */
    public function getConsensusDeleteTopic()
    {
        return $this->readOneof(26);
    }

    public function hasConsensusDeleteTopic()
    {
        return $this->hasOneof(26);
    }

    /**
     **
     * Delete a topic.
     *
     * Generated from protobuf field <code>.proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 26;</code>
     * @param \Proto\ConsensusDeleteTopicTransactionBody $var
     * @return $this
     */
    public function setConsensusDeleteTopic($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusDeleteTopicTransactionBody::class);
        $this->writeOneof(26, $var);

        return $this;
    }

    /**
     **
     * Submit a message to a topic.<br/>
     * A message may be "chunked", and submitted in parts, if the total
     * message size exceeds the limit for a single transaction.
     *
     * Generated from protobuf field <code>.proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 27;</code>
     * @return \Proto\ConsensusSubmitMessageTransactionBody|null
     */
    public function getConsensusSubmitMessage()
    {
        return $this->readOneof(27);
    }

    public function hasConsensusSubmitMessage()
    {
        return $this->hasOneof(27);
    }

    /**
     **
     * Submit a message to a topic.<br/>
     * A message may be "chunked", and submitted in parts, if the total
     * message size exceeds the limit for a single transaction.
     *
     * Generated from protobuf field <code>.proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 27;</code>
     * @param \Proto\ConsensusSubmitMessageTransactionBody $var
     * @return $this
     */
    public function setConsensusSubmitMessage($var)
    {
        GPBUtil::checkMessage($var, \Proto\ConsensusSubmitMessageTransactionBody::class);
        $this->writeOneof(27, $var);

        return $this;
    }

    /**
     **
     * Unsupported system transaction.
     * <p>
     * This transaction MAY be implemented in testing networks, but
     * SHALL NOT be enabled or supported in production environments.<br/>
     * Clients MUST NOT call this method, and any such transaction SHALL
     * be rejected.<br/>
     * A network MAY choose to charge punitive fees for attempting to
     * execute an `uncheckedSubmit`.
     *
     * Generated from protobuf field <code>.proto.UncheckedSubmitBody uncheckedSubmit = 28;</code>
     * @return \Proto\UncheckedSubmitBody|null
     */
    public function getUncheckedSubmit()
    {
        return $this->readOneof(28);
    }

    public function hasUncheckedSubmit()
    {
        return $this->hasOneof(28);
    }

    /**
     **
     * Unsupported system transaction.
     * <p>
     * This transaction MAY be implemented in testing networks, but
     * SHALL NOT be enabled or supported in production environments.<br/>
     * Clients MUST NOT call this method, and any such transaction SHALL
     * be rejected.<br/>
     * A network MAY choose to charge punitive fees for attempting to
     * execute an `uncheckedSubmit`.
     *
     * Generated from protobuf field <code>.proto.UncheckedSubmitBody uncheckedSubmit = 28;</code>
     * @param \Proto\UncheckedSubmitBody $var
     * @return $this
     */
    public function setUncheckedSubmit($var)
    {
        GPBUtil::checkMessage($var, \Proto\UncheckedSubmitBody::class);
        $this->writeOneof(28, $var);

        return $this;
    }

    /**
     **
     * Create a new Hedera token.
     *
     * Generated from protobuf field <code>.proto.TokenCreateTransactionBody tokenCreation = 29;</code>
     * @return \Proto\TokenCreateTransactionBody|null
     */
    public function getTokenCreation()
    {
        return $this->readOneof(29);
    }

    public function hasTokenCreation()
    {
        return $this->hasOneof(29);
    }

    /**
     **
     * Create a new Hedera token.
     *
     * Generated from protobuf field <code>.proto.TokenCreateTransactionBody tokenCreation = 29;</code>
     * @param \Proto\TokenCreateTransactionBody $var
     * @return $this
     */
    public function setTokenCreation($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenCreateTransactionBody::class);
        $this->writeOneof(29, $var);

        return $this;
    }

    /**
     **
     * Freeze an account with respect to a token.<br/>
     * A frozen account cannot transact in that token until unfrozen.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeAccountTransactionBody tokenFreeze = 31;</code>
     * @return \Proto\TokenFreezeAccountTransactionBody|null
     */
    public function getTokenFreeze()
    {
        return $this->readOneof(31);
    }

    public function hasTokenFreeze()
    {
        return $this->hasOneof(31);
    }

    /**
     **
     * Freeze an account with respect to a token.<br/>
     * A frozen account cannot transact in that token until unfrozen.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeAccountTransactionBody tokenFreeze = 31;</code>
     * @param \Proto\TokenFreezeAccountTransactionBody $var
     * @return $this
     */
    public function setTokenFreeze($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenFreezeAccountTransactionBody::class);
        $this->writeOneof(31, $var);

        return $this;
    }

    /**
     **
     * Unfreeze an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 32;</code>
     * @return \Proto\TokenUnfreezeAccountTransactionBody|null
     */
    public function getTokenUnfreeze()
    {
        return $this->readOneof(32);
    }

    public function hasTokenUnfreeze()
    {
        return $this->hasOneof(32);
    }

    /**
     **
     * Unfreeze an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 32;</code>
     * @param \Proto\TokenUnfreezeAccountTransactionBody $var
     * @return $this
     */
    public function setTokenUnfreeze($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUnfreezeAccountTransactionBody::class);
        $this->writeOneof(32, $var);

        return $this;
    }

    /**
     **
     * Grant KYC to an account with respect to a token.<br/>
     * KYC is generally a "know your customer" assertion that a
     * responsible entity has sufficient information to positively
     * identify the account holder to relevant authorities.
     *
     * Generated from protobuf field <code>.proto.TokenGrantKycTransactionBody tokenGrantKyc = 33;</code>
     * @return \Proto\TokenGrantKycTransactionBody|null
     */
    public function getTokenGrantKyc()
    {
        return $this->readOneof(33);
    }

    public function hasTokenGrantKyc()
    {
        return $this->hasOneof(33);
    }

    /**
     **
     * Grant KYC to an account with respect to a token.<br/>
     * KYC is generally a "know your customer" assertion that a
     * responsible entity has sufficient information to positively
     * identify the account holder to relevant authorities.
     *
     * Generated from protobuf field <code>.proto.TokenGrantKycTransactionBody tokenGrantKyc = 33;</code>
     * @param \Proto\TokenGrantKycTransactionBody $var
     * @return $this
     */
    public function setTokenGrantKyc($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenGrantKycTransactionBody::class);
        $this->writeOneof(33, $var);

        return $this;
    }

    /**
     **
     * Revoke KYC from an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 34;</code>
     * @return \Proto\TokenRevokeKycTransactionBody|null
     */
    public function getTokenRevokeKyc()
    {
        return $this->readOneof(34);
    }

    public function hasTokenRevokeKyc()
    {
        return $this->hasOneof(34);
    }

    /**
     **
     * Revoke KYC from an account with respect to a token.
     *
     * Generated from protobuf field <code>.proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 34;</code>
     * @param \Proto\TokenRevokeKycTransactionBody $var
     * @return $this
     */
    public function setTokenRevokeKyc($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenRevokeKycTransactionBody::class);
        $this->writeOneof(34, $var);

        return $this;
    }

    /**
     **
     * Delete an Hedera token.<br/>
     * The token will be marked deleted.
     *
     * Generated from protobuf field <code>.proto.TokenDeleteTransactionBody tokenDeletion = 35;</code>
     * @return \Proto\TokenDeleteTransactionBody|null
     */
    public function getTokenDeletion()
    {
        return $this->readOneof(35);
    }

    public function hasTokenDeletion()
    {
        return $this->hasOneof(35);
    }

    /**
     **
     * Delete an Hedera token.<br/>
     * The token will be marked deleted.
     *
     * Generated from protobuf field <code>.proto.TokenDeleteTransactionBody tokenDeletion = 35;</code>
     * @param \Proto\TokenDeleteTransactionBody $var
     * @return $this
     */
    public function setTokenDeletion($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenDeleteTransactionBody::class);
        $this->writeOneof(35, $var);

        return $this;
    }

    /**
     **
     * Update an Hedera token.<br/>
     * Depending on what fields are to be modified, the signature
     * requirements will vary. See `TokenUpdateTransactionBody` for
     * further detail.
     *
     * Generated from protobuf field <code>.proto.TokenUpdateTransactionBody tokenUpdate = 36;</code>
     * @return \Proto\TokenUpdateTransactionBody|null
     */
    public function getTokenUpdate()
    {
        return $this->readOneof(36);
    }

    public function hasTokenUpdate()
    {
        return $this->hasOneof(36);
    }

    /**
     **
     * Update an Hedera token.<br/>
     * Depending on what fields are to be modified, the signature
     * requirements will vary. See `TokenUpdateTransactionBody` for
     * further detail.
     *
     * Generated from protobuf field <code>.proto.TokenUpdateTransactionBody tokenUpdate = 36;</code>
     * @param \Proto\TokenUpdateTransactionBody $var
     * @return $this
     */
    public function setTokenUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUpdateTransactionBody::class);
        $this->writeOneof(36, $var);

        return $this;
    }

    /**
     **
     * Mint new tokens.<br/>
     * All minted tokens will be delivered to the treasury account for
     * the token type. The "mint key" for the token must sign this
     * transaction.
     *
     * Generated from protobuf field <code>.proto.TokenMintTransactionBody tokenMint = 37;</code>
     * @return \Proto\TokenMintTransactionBody|null
     */
    public function getTokenMint()
    {
        return $this->readOneof(37);
    }

    public function hasTokenMint()
    {
        return $this->hasOneof(37);
    }

    /**
     **
     * Mint new tokens.<br/>
     * All minted tokens will be delivered to the treasury account for
     * the token type. The "mint key" for the token must sign this
     * transaction.
     *
     * Generated from protobuf field <code>.proto.TokenMintTransactionBody tokenMint = 37;</code>
     * @param \Proto\TokenMintTransactionBody $var
     * @return $this
     */
    public function setTokenMint($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenMintTransactionBody::class);
        $this->writeOneof(37, $var);

        return $this;
    }

    /**
     **
     * Burn tokens from the treasury account.<br/>
     * The "burn key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenBurnTransactionBody tokenBurn = 38;</code>
     * @return \Proto\TokenBurnTransactionBody|null
     */
    public function getTokenBurn()
    {
        return $this->readOneof(38);
    }

    public function hasTokenBurn()
    {
        return $this->hasOneof(38);
    }

    /**
     **
     * Burn tokens from the treasury account.<br/>
     * The "burn key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenBurnTransactionBody tokenBurn = 38;</code>
     * @param \Proto\TokenBurnTransactionBody $var
     * @return $this
     */
    public function setTokenBurn($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenBurnTransactionBody::class);
        $this->writeOneof(38, $var);

        return $this;
    }

    /**
     **
     * Wipe tokens from an account.<br/>
     * This will remove a specified amount of fungible/common tokens or
     * a specified list of non-fungible/unique serial numbered tokens
     * of a given token type from an Hedera account. The removed tokens
     * are _burned_ as if by a `tokenBurn` transaction.<br/>
     * The "wipe key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenWipeAccountTransactionBody tokenWipe = 39;</code>
     * @return \Proto\TokenWipeAccountTransactionBody|null
     */
    public function getTokenWipe()
    {
        return $this->readOneof(39);
    }

    public function hasTokenWipe()
    {
        return $this->hasOneof(39);
    }

    /**
     **
     * Wipe tokens from an account.<br/>
     * This will remove a specified amount of fungible/common tokens or
     * a specified list of non-fungible/unique serial numbered tokens
     * of a given token type from an Hedera account. The removed tokens
     * are _burned_ as if by a `tokenBurn` transaction.<br/>
     * The "wipe key" for the token must sign this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenWipeAccountTransactionBody tokenWipe = 39;</code>
     * @param \Proto\TokenWipeAccountTransactionBody $var
     * @return $this
     */
    public function setTokenWipe($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenWipeAccountTransactionBody::class);
        $this->writeOneof(39, $var);

        return $this;
    }

    /**
     **
     * Associate tokens to an account.
     *
     * Generated from protobuf field <code>.proto.TokenAssociateTransactionBody tokenAssociate = 40;</code>
     * @return \Proto\TokenAssociateTransactionBody|null
     */
    public function getTokenAssociate()
    {
        return $this->readOneof(40);
    }

    public function hasTokenAssociate()
    {
        return $this->hasOneof(40);
    }

    /**
     **
     * Associate tokens to an account.
     *
     * Generated from protobuf field <code>.proto.TokenAssociateTransactionBody tokenAssociate = 40;</code>
     * @param \Proto\TokenAssociateTransactionBody $var
     * @return $this
     */
    public function setTokenAssociate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenAssociateTransactionBody::class);
        $this->writeOneof(40, $var);

        return $this;
    }

    /**
     **
     * Dissociate tokens from an account.
     *
     * Generated from protobuf field <code>.proto.TokenDissociateTransactionBody tokenDissociate = 41;</code>
     * @return \Proto\TokenDissociateTransactionBody|null
     */
    public function getTokenDissociate()
    {
        return $this->readOneof(41);
    }

    public function hasTokenDissociate()
    {
        return $this->hasOneof(41);
    }

    /**
     **
     * Dissociate tokens from an account.
     *
     * Generated from protobuf field <code>.proto.TokenDissociateTransactionBody tokenDissociate = 41;</code>
     * @param \Proto\TokenDissociateTransactionBody $var
     * @return $this
     */
    public function setTokenDissociate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenDissociateTransactionBody::class);
        $this->writeOneof(41, $var);

        return $this;
    }

    /**
     **
     * Create a schedule.<br/>
     * A schedule is a request to execute a specific transaction, included
     * in the create body, in the future. The scheduled transaction may
     * execute as soon as all signature requirements are met with the
     * schedule create or a subsequent schedule sign transaction.
     * A schedule may, alternatively, execute on expiration if
     * long-term schedules are enabled and the schedule meets signature
     * requirements at that time.
     *
     * Generated from protobuf field <code>.proto.ScheduleCreateTransactionBody scheduleCreate = 42;</code>
     * @return \Proto\ScheduleCreateTransactionBody|null
     */
    public function getScheduleCreate()
    {
        return $this->readOneof(42);
    }

    public function hasScheduleCreate()
    {
        return $this->hasOneof(42);
    }

    /**
     **
     * Create a schedule.<br/>
     * A schedule is a request to execute a specific transaction, included
     * in the create body, in the future. The scheduled transaction may
     * execute as soon as all signature requirements are met with the
     * schedule create or a subsequent schedule sign transaction.
     * A schedule may, alternatively, execute on expiration if
     * long-term schedules are enabled and the schedule meets signature
     * requirements at that time.
     *
     * Generated from protobuf field <code>.proto.ScheduleCreateTransactionBody scheduleCreate = 42;</code>
     * @param \Proto\ScheduleCreateTransactionBody $var
     * @return $this
     */
    public function setScheduleCreate($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleCreateTransactionBody::class);
        $this->writeOneof(42, $var);

        return $this;
    }

    /**
     **
     * Delete a schedule.<br/>
     * The schedule will be marked as deleted.
     *
     * Generated from protobuf field <code>.proto.ScheduleDeleteTransactionBody scheduleDelete = 43;</code>
     * @return \Proto\ScheduleDeleteTransactionBody|null
     */
    public function getScheduleDelete()
    {
        return $this->readOneof(43);
    }

    public function hasScheduleDelete()
    {
        return $this->hasOneof(43);
    }

    /**
     **
     * Delete a schedule.<br/>
     * The schedule will be marked as deleted.
     *
     * Generated from protobuf field <code>.proto.ScheduleDeleteTransactionBody scheduleDelete = 43;</code>
     * @param \Proto\ScheduleDeleteTransactionBody $var
     * @return $this
     */
    public function setScheduleDelete($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleDeleteTransactionBody::class);
        $this->writeOneof(43, $var);

        return $this;
    }

    /**
     **
     * Sign a schedule.<br/>
     * Add one or more cryptographic keys to the list of keys that have
     * signed a schedule, and which may serve to meet the signature
     * requirements for the scheduled transaction.
     *
     * Generated from protobuf field <code>.proto.ScheduleSignTransactionBody scheduleSign = 44;</code>
     * @return \Proto\ScheduleSignTransactionBody|null
     */
    public function getScheduleSign()
    {
        return $this->readOneof(44);
    }

    public function hasScheduleSign()
    {
        return $this->hasOneof(44);
    }

    /**
     **
     * Sign a schedule.<br/>
     * Add one or more cryptographic keys to the list of keys that have
     * signed a schedule, and which may serve to meet the signature
     * requirements for the scheduled transaction.
     *
     * Generated from protobuf field <code>.proto.ScheduleSignTransactionBody scheduleSign = 44;</code>
     * @param \Proto\ScheduleSignTransactionBody $var
     * @return $this
     */
    public function setScheduleSign($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleSignTransactionBody::class);
        $this->writeOneof(44, $var);

        return $this;
    }

    /**
     **
     * Update the custom fee schedule for a token.<br/>
     * This transaction must be signed by the "fee schedule key"
     * for the token.
     *
     * Generated from protobuf field <code>.proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 45;</code>
     * @return \Proto\TokenFeeScheduleUpdateTransactionBody|null
     */
    public function getTokenFeeScheduleUpdate()
    {
        return $this->readOneof(45);
    }

    public function hasTokenFeeScheduleUpdate()
    {
        return $this->hasOneof(45);
    }

    /**
     **
     * Update the custom fee schedule for a token.<br/>
     * This transaction must be signed by the "fee schedule key"
     * for the token.
     *
     * Generated from protobuf field <code>.proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 45;</code>
     * @param \Proto\TokenFeeScheduleUpdateTransactionBody $var
     * @return $this
     */
    public function setTokenFeeScheduleUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenFeeScheduleUpdateTransactionBody::class);
        $this->writeOneof(45, $var);

        return $this;
    }

    /**
     **
     * Pause a Token.
     * <p>
     * This transaction MUST be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenPauseTransactionBody token_pause = 46;</code>
     * @return \Proto\TokenPauseTransactionBody|null
     */
    public function getTokenPause()
    {
        return $this->readOneof(46);
    }

    public function hasTokenPause()
    {
        return $this->hasOneof(46);
    }

    /**
     **
     * Pause a Token.
     * <p>
     * This transaction MUST be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenPauseTransactionBody token_pause = 46;</code>
     * @param \Proto\TokenPauseTransactionBody $var
     * @return $this
     */
    public function setTokenPause($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenPauseTransactionBody::class);
        $this->writeOneof(46, $var);

        return $this;
    }

    /**
     **
     * Unpause a Token.
     * <p>
     * This transaction MUST be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenUnpauseTransactionBody token_unpause = 47;</code>
     * @return \Proto\TokenUnpauseTransactionBody|null
     */
    public function getTokenUnpause()
    {
        return $this->readOneof(47);
    }

    public function hasTokenUnpause()
    {
        return $this->hasOneof(47);
    }

    /**
     **
     * Unpause a Token.
     * <p>
     * This transaction MUST be signed by the "pause key" for the token.
     *
     * Generated from protobuf field <code>.proto.TokenUnpauseTransactionBody token_unpause = 47;</code>
     * @param \Proto\TokenUnpauseTransactionBody $var
     * @return $this
     */
    public function setTokenUnpause($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUnpauseTransactionBody::class);
        $this->writeOneof(47, $var);

        return $this;
    }

    /**
     **
     * Add one or more approved allowances for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 48;</code>
     * @return \Proto\CryptoApproveAllowanceTransactionBody|null
     */
    public function getCryptoApproveAllowance()
    {
        return $this->readOneof(48);
    }

    public function hasCryptoApproveAllowance()
    {
        return $this->hasOneof(48);
    }

    /**
     **
     * Add one or more approved allowances for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 48;</code>
     * @param \Proto\CryptoApproveAllowanceTransactionBody $var
     * @return $this
     */
    public function setCryptoApproveAllowance($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoApproveAllowanceTransactionBody::class);
        $this->writeOneof(48, $var);

        return $this;
    }

    /**
     **
     * Delete one or more approvals for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 49;</code>
     * @return \Proto\CryptoDeleteAllowanceTransactionBody|null
     */
    public function getCryptoDeleteAllowance()
    {
        return $this->readOneof(49);
    }

    public function hasCryptoDeleteAllowance()
    {
        return $this->hasOneof(49);
    }

    /**
     **
     * Delete one or more approvals for spenders to transfer the
     * paying account's hbar or tokens.
     *
     * Generated from protobuf field <code>.proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 49;</code>
     * @param \Proto\CryptoDeleteAllowanceTransactionBody $var
     * @return $this
     */
    public function setCryptoDeleteAllowance($var)
    {
        GPBUtil::checkMessage($var, \Proto\CryptoDeleteAllowanceTransactionBody::class);
        $this->writeOneof(49, $var);

        return $this;
    }

    /**
     **
     * Perform an Ethereum encoded transaction.
     *
     * Generated from protobuf field <code>.proto.EthereumTransactionBody ethereumTransaction = 50;</code>
     * @return \Proto\EthereumTransactionBody|null
     */
    public function getEthereumTransaction()
    {
        return $this->readOneof(50);
    }

    public function hasEthereumTransaction()
    {
        return $this->hasOneof(50);
    }

    /**
     **
     * Perform an Ethereum encoded transaction.
     *
     * Generated from protobuf field <code>.proto.EthereumTransactionBody ethereumTransaction = 50;</code>
     * @param \Proto\EthereumTransactionBody $var
     * @return $this
     */
    public function setEthereumTransaction($var)
    {
        GPBUtil::checkMessage($var, \Proto\EthereumTransactionBody::class);
        $this->writeOneof(50, $var);

        return $this;
    }

    /**
     **
     * Update the staking information.<br/>
     * This internal transaction is performed at the end of a staking
     * period to complete staking calculations and indicate that new
     * staking period has started.
     *
     * Generated from protobuf field <code>.proto.NodeStakeUpdateTransactionBody node_stake_update = 51;</code>
     * @return \Proto\NodeStakeUpdateTransactionBody|null
     */
    public function getNodeStakeUpdate()
    {
        return $this->readOneof(51);
    }

    public function hasNodeStakeUpdate()
    {
        return $this->hasOneof(51);
    }

    /**
     **
     * Update the staking information.<br/>
     * This internal transaction is performed at the end of a staking
     * period to complete staking calculations and indicate that new
     * staking period has started.
     *
     * Generated from protobuf field <code>.proto.NodeStakeUpdateTransactionBody node_stake_update = 51;</code>
     * @param \Proto\NodeStakeUpdateTransactionBody $var
     * @return $this
     */
    public function setNodeStakeUpdate($var)
    {
        GPBUtil::checkMessage($var, \Proto\NodeStakeUpdateTransactionBody::class);
        $this->writeOneof(51, $var);

        return $this;
    }

    /**
     **
     * Provide a deterministic pseudorandom number based on network state.
     *
     * Generated from protobuf field <code>.proto.UtilPrngTransactionBody util_prng = 52;</code>
     * @return \Proto\UtilPrngTransactionBody|null
     */
    public function getUtilPrng()
    {
        return $this->readOneof(52);
    }

    public function hasUtilPrng()
    {
        return $this->hasOneof(52);
    }

    /**
     **
     * Provide a deterministic pseudorandom number based on network state.
     *
     * Generated from protobuf field <code>.proto.UtilPrngTransactionBody util_prng = 52;</code>
     * @param \Proto\UtilPrngTransactionBody $var
     * @return $this
     */
    public function setUtilPrng($var)
    {
        GPBUtil::checkMessage($var, \Proto\UtilPrngTransactionBody::class);
        $this->writeOneof(52, $var);

        return $this;
    }

    /**
     **
     * Update one or more non-fungible/unique tokens.<br/>
     * This will update metadata for one or more serial numbers within
     * a collection (token type).
     *
     * Generated from protobuf field <code>.proto.TokenUpdateNftsTransactionBody token_update_nfts = 53;</code>
     * @return \Proto\TokenUpdateNftsTransactionBody|null
     */
    public function getTokenUpdateNfts()
    {
        return $this->readOneof(53);
    }

    public function hasTokenUpdateNfts()
    {
        return $this->hasOneof(53);
    }

    /**
     **
     * Update one or more non-fungible/unique tokens.<br/>
     * This will update metadata for one or more serial numbers within
     * a collection (token type).
     *
     * Generated from protobuf field <code>.proto.TokenUpdateNftsTransactionBody token_update_nfts = 53;</code>
     * @param \Proto\TokenUpdateNftsTransactionBody $var
     * @return $this
     */
    public function setTokenUpdateNfts($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenUpdateNftsTransactionBody::class);
        $this->writeOneof(53, $var);

        return $this;
    }

    /**
     **
     * Create a new node in the network address book.<br/>
     * This is a privileged operation.
     * <p>
     * This transaction SHALL create a new consensus node record and add
     * that record to the network address book.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody nodeCreate = 54;</code>
     * @return \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody|null
     */
    public function getNodeCreate()
    {
        return $this->readOneof(54);
    }

    public function hasNodeCreate()
    {
        return $this->hasOneof(54);
    }

    /**
     **
     * Create a new node in the network address book.<br/>
     * This is a privileged operation.
     * <p>
     * This transaction SHALL create a new consensus node record and add
     * that record to the network address book.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody nodeCreate = 54;</code>
     * @param \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody $var
     * @return $this
     */
    public function setNodeCreate($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Node\Addressbook\NodeCreateTransactionBody::class);
        $this->writeOneof(54, $var);

        return $this;
    }

    /**
     **
     * Update a node in the network address book.<br/>
     * This is a privileged operation.
     * <p>
     * This transaction SHALL update an existing consensus node record in
     * the network address book.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody nodeUpdate = 55;</code>
     * @return \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody|null
     */
    public function getNodeUpdate()
    {
        return $this->readOneof(55);
    }

    public function hasNodeUpdate()
    {
        return $this->hasOneof(55);
    }

    /**
     **
     * Update a node in the network address book.<br/>
     * This is a privileged operation.
     * <p>
     * This transaction SHALL update an existing consensus node record in
     * the network address book.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody nodeUpdate = 55;</code>
     * @param \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody $var
     * @return $this
     */
    public function setNodeUpdate($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Node\Addressbook\NodeUpdateTransactionBody::class);
        $this->writeOneof(55, $var);

        return $this;
    }

    /**
     **
     * Delete a node from the network address book.<br/>
     * This is a privileged operation.
     * <p>
     * This transaction SHALL mark an existing consensus node record as
     * deleted and remove that node from the network address book.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody nodeDelete = 56;</code>
     * @return \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody|null
     */
    public function getNodeDelete()
    {
        return $this->readOneof(56);
    }

    public function hasNodeDelete()
    {
        return $this->hasOneof(56);
    }

    /**
     **
     * Delete a node from the network address book.<br/>
     * This is a privileged operation.
     * <p>
     * This transaction SHALL mark an existing consensus node record as
     * deleted and remove that node from the network address book.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody nodeDelete = 56;</code>
     * @param \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody $var
     * @return $this
     */
    public function setNodeDelete($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Node\Addressbook\NodeDeleteTransactionBody::class);
        $this->writeOneof(56, $var);

        return $this;
    }

    /**
     **
     * Reject and return a token to treasury.<br/>
     * This transaction will transfer one or more tokens or token
     * balances held by the requesting account to the treasury
     * for each token type.
     * <p>
     * Each transfer MUST be one of the following:
     * <ul>
     *   <li>A single non-fungible/unique token.</li>
     *   <li>The full balance held for a fungible/common
     *       token type.</li>
     * </ul>
     * When complete, the requesting account SHALL NOT hold the
     * rejected tokens.<br/>
     * Custom fees and royalties defined for the tokens rejected
     * SHALL NOT be charged for this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenRejectTransactionBody tokenReject = 57;</code>
     * @return \Proto\TokenRejectTransactionBody|null
     */
    public function getTokenReject()
    {
        return $this->readOneof(57);
    }

    public function hasTokenReject()
    {
        return $this->hasOneof(57);
    }

    /**
     **
     * Reject and return a token to treasury.<br/>
     * This transaction will transfer one or more tokens or token
     * balances held by the requesting account to the treasury
     * for each token type.
     * <p>
     * Each transfer MUST be one of the following:
     * <ul>
     *   <li>A single non-fungible/unique token.</li>
     *   <li>The full balance held for a fungible/common
     *       token type.</li>
     * </ul>
     * When complete, the requesting account SHALL NOT hold the
     * rejected tokens.<br/>
     * Custom fees and royalties defined for the tokens rejected
     * SHALL NOT be charged for this transaction.
     *
     * Generated from protobuf field <code>.proto.TokenRejectTransactionBody tokenReject = 57;</code>
     * @param \Proto\TokenRejectTransactionBody $var
     * @return $this
     */
    public function setTokenReject($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenRejectTransactionBody::class);
        $this->writeOneof(57, $var);

        return $this;
    }

    /**
     **
     * "Airdrop" tokens.<br/>
     * This transaction sends tokens from one or more "sender" accounts
     * to one or more "recipient" accounts.
     * <p>
     * If a recipient account cannot immediately receive the token(s) sent,
     * a "pending" airdrop SHALL be created and MUST be claimed.
     *
     * Generated from protobuf field <code>.proto.TokenAirdropTransactionBody tokenAirdrop = 58;</code>
     * @return \Proto\TokenAirdropTransactionBody|null
     */
    public function getTokenAirdrop()
    {
        return $this->readOneof(58);
    }

    public function hasTokenAirdrop()
    {
        return $this->hasOneof(58);
    }

    /**
     **
     * "Airdrop" tokens.<br/>
     * This transaction sends tokens from one or more "sender" accounts
     * to one or more "recipient" accounts.
     * <p>
     * If a recipient account cannot immediately receive the token(s) sent,
     * a "pending" airdrop SHALL be created and MUST be claimed.
     *
     * Generated from protobuf field <code>.proto.TokenAirdropTransactionBody tokenAirdrop = 58;</code>
     * @param \Proto\TokenAirdropTransactionBody $var
     * @return $this
     */
    public function setTokenAirdrop($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenAirdropTransactionBody::class);
        $this->writeOneof(58, $var);

        return $this;
    }

    /**
     **
     * Cancel one or more "pending" airdrops that are not yet claimed.
     *
     * Generated from protobuf field <code>.proto.TokenCancelAirdropTransactionBody tokenCancelAirdrop = 59;</code>
     * @return \Proto\TokenCancelAirdropTransactionBody|null
     */
    public function getTokenCancelAirdrop()
    {
        return $this->readOneof(59);
    }

    public function hasTokenCancelAirdrop()
    {
        return $this->hasOneof(59);
    }

    /**
     **
     * Cancel one or more "pending" airdrops that are not yet claimed.
     *
     * Generated from protobuf field <code>.proto.TokenCancelAirdropTransactionBody tokenCancelAirdrop = 59;</code>
     * @param \Proto\TokenCancelAirdropTransactionBody $var
     * @return $this
     */
    public function setTokenCancelAirdrop($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenCancelAirdropTransactionBody::class);
        $this->writeOneof(59, $var);

        return $this;
    }

    /**
     **
     * Claim one or more "pending" airdrops.
     *
     * Generated from protobuf field <code>.proto.TokenClaimAirdropTransactionBody tokenClaimAirdrop = 60;</code>
     * @return \Proto\TokenClaimAirdropTransactionBody|null
     */
    public function getTokenClaimAirdrop()
    {
        return $this->readOneof(60);
    }

    public function hasTokenClaimAirdrop()
    {
        return $this->hasOneof(60);
    }

    /**
     **
     * Claim one or more "pending" airdrops.
     *
     * Generated from protobuf field <code>.proto.TokenClaimAirdropTransactionBody tokenClaimAirdrop = 60;</code>
     * @param \Proto\TokenClaimAirdropTransactionBody $var
     * @return $this
     */
    public function setTokenClaimAirdrop($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenClaimAirdropTransactionBody::class);
        $this->writeOneof(60, $var);

        return $this;
    }

    /**
     **
     * A transaction body for signature of a state root hash gossiped to other nodes
     *
     * Generated from protobuf field <code>.com.hedera.hapi.platform.event.StateSignatureTransaction state_signature_transaction = 65;</code>
     * @return \Com\Hedera\Hapi\Platform\Event\StateSignatureTransaction|null
     */
    public function getStateSignatureTransaction()
    {
        return $this->readOneof(65);
    }

    public function hasStateSignatureTransaction()
    {
        return $this->hasOneof(65);
    }

    /**
     **
     * A transaction body for signature of a state root hash gossiped to other nodes
     *
     * Generated from protobuf field <code>.com.hedera.hapi.platform.event.StateSignatureTransaction state_signature_transaction = 65;</code>
     * @param \Com\Hedera\Hapi\Platform\Event\StateSignatureTransaction $var
     * @return $this
     */
    public function setStateSignatureTransaction($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Platform\Event\StateSignatureTransaction::class);
        $this->writeOneof(65, $var);

        return $this;
    }

    /**
     **
     * A transaction body for voting on hinTS aggregation keys.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody hints_preprocessing_vote = 66;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPreprocessingVoteTransactionBody|null
     */
    public function getHintsPreprocessingVote()
    {
        return $this->readOneof(66);
    }

    public function hasHintsPreprocessingVote()
    {
        return $this->hasOneof(66);
    }

    /**
     **
     * A transaction body for voting on hinTS aggregation keys.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody hints_preprocessing_vote = 66;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPreprocessingVoteTransactionBody $var
     * @return $this
     */
    public function setHintsPreprocessingVote($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPreprocessingVoteTransactionBody::class);
        $this->writeOneof(66, $var);

        return $this;
    }

    /**
     **
     * A transaction body for publishing a node's hintTS key.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody hints_key_publication = 67;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsKeyPublicationTransactionBody|null
     */
    public function getHintsKeyPublication()
    {
        return $this->readOneof(67);
    }

    public function hasHintsKeyPublication()
    {
        return $this->hasOneof(67);
    }

    /**
     **
     * A transaction body for publishing a node's hintTS key.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody hints_key_publication = 67;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsKeyPublicationTransactionBody $var
     * @return $this
     */
    public function setHintsKeyPublication($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsKeyPublicationTransactionBody::class);
        $this->writeOneof(67, $var);

        return $this;
    }

    /**
     **
     * A transaction body for broadcasting a node's hintTS partial signature on a message.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody hints_partial_signature = 68;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPartialSignatureTransactionBody|null
     */
    public function getHintsPartialSignature()
    {
        return $this->readOneof(68);
    }

    public function hasHintsPartialSignature()
    {
        return $this->hasOneof(68);
    }

    /**
     **
     * A transaction body for broadcasting a node's hintTS partial signature on a message.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody hints_partial_signature = 68;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPartialSignatureTransactionBody $var
     * @return $this
     */
    public function setHintsPartialSignature($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\Hints\HintsPartialSignatureTransactionBody::class);
        $this->writeOneof(68, $var);

        return $this;
    }

    /**
     **
     * A transaction body for contributed a signature with a node's proof key to a history proof.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody history_proof_signature = 69;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofSignatureTransactionBody|null
     */
    public function getHistoryProofSignature()
    {
        return $this->readOneof(69);
    }

    public function hasHistoryProofSignature()
    {
        return $this->hasOneof(69);
    }

    /**
     **
     * A transaction body for contributed a signature with a node's proof key to a history proof.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody history_proof_signature = 69;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofSignatureTransactionBody $var
     * @return $this
     */
    public function setHistoryProofSignature($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofSignatureTransactionBody::class);
        $this->writeOneof(69, $var);

        return $this;
    }

    /**
     **
     * A transaction body for publishing a node's metadata proof key.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody history_proof_key_publication = 70;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofKeyPublicationTransactionBody|null
     */
    public function getHistoryProofKeyPublication()
    {
        return $this->readOneof(70);
    }

    public function hasHistoryProofKeyPublication()
    {
        return $this->hasOneof(70);
    }

    /**
     **
     * A transaction body for publishing a node's metadata proof key.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody history_proof_key_publication = 70;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofKeyPublicationTransactionBody $var
     * @return $this
     */
    public function setHistoryProofKeyPublication($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofKeyPublicationTransactionBody::class);
        $this->writeOneof(70, $var);

        return $this;
    }

    /**
     **
     * A transaction body for voting on a metadata proof descending from the ledger id.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody history_proof_vote = 71;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofVoteTransactionBody|null
     */
    public function getHistoryProofVote()
    {
        return $this->readOneof(71);
    }

    public function hasHistoryProofVote()
    {
        return $this->hasOneof(71);
    }

    /**
     **
     * A transaction body for voting on a metadata proof descending from the ledger id.
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody history_proof_vote = 71;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofVoteTransactionBody $var
     * @return $this
     */
    public function setHistoryProofVote($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\History\HistoryProofVoteTransactionBody::class);
        $this->writeOneof(71, $var);

        return $this;
    }

    /**
     **
     * A transaction body for broadcasting a node's crs publication
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody crs_publication = 72;</code>
     * @return \Com\Hedera\Hapi\Services\Auxiliary\Hints\CrsPublicationTransactionBody|null
     */
    public function getCrsPublication()
    {
        return $this->readOneof(72);
    }

    public function hasCrsPublication()
    {
        return $this->hasOneof(72);
    }

    /**
     **
     * A transaction body for broadcasting a node's crs publication
     *
     * Generated from protobuf field <code>.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody crs_publication = 72;</code>
     * @param \Com\Hedera\Hapi\Services\Auxiliary\Hints\CrsPublicationTransactionBody $var
     * @return $this
     */
    public function setCrsPublication($var)
    {
        GPBUtil::checkMessage($var, \Com\Hedera\Hapi\Services\Auxiliary\Hints\CrsPublicationTransactionBody::class);
        $this->writeOneof(72, $var);

        return $this;
    }

    /**
     **
     * A transaction body for handling a set of transactions atomically.
     *
     * Generated from protobuf field <code>.proto.AtomicBatchTransactionBody atomic_batch = 74;</code>
     * @return \Proto\AtomicBatchTransactionBody|null
     */
    public function getAtomicBatch()
    {
        return $this->readOneof(74);
    }

    public function hasAtomicBatch()
    {
        return $this->hasOneof(74);
    }

    /**
     **
     * A transaction body for handling a set of transactions atomically.
     *
     * Generated from protobuf field <code>.proto.AtomicBatchTransactionBody atomic_batch = 74;</code>
     * @param \Proto\AtomicBatchTransactionBody $var
     * @return $this
     */
    public function setAtomicBatch($var)
    {
        GPBUtil::checkMessage($var, \Proto\AtomicBatchTransactionBody::class);
        $this->writeOneof(74, $var);

        return $this;
    }

    /**
     **
     * A list of maximum custom fees that the users are willing to pay.
     * <p>
     * This field is OPTIONAL.<br/>
     * If left empty, the users are accepting to pay any custom fee.<br/>
     * If used with a transaction type that does not support custom fee limits, the transaction will fail.
     *
     * Generated from protobuf field <code>repeated .proto.CustomFeeLimit max_custom_fees = 1001;</code>
     * @return RepeatedField<\Proto\CustomFeeLimit>
     */
    public function getMaxCustomFees()
    {
        return $this->max_custom_fees;
    }

    /**
     **
     * A list of maximum custom fees that the users are willing to pay.
     * <p>
     * This field is OPTIONAL.<br/>
     * If left empty, the users are accepting to pay any custom fee.<br/>
     * If used with a transaction type that does not support custom fee limits, the transaction will fail.
     *
     * Generated from protobuf field <code>repeated .proto.CustomFeeLimit max_custom_fees = 1001;</code>
     * @param \Proto\CustomFeeLimit[] $var
     * @return $this
     */
    public function setMaxCustomFees($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Proto\CustomFeeLimit::class);
        $this->max_custom_fees = $arr;

        return $this;
    }

    /**
     * @return string
     */
    public function getData()
    {
        return $this->whichOneof("data");
    }

}

