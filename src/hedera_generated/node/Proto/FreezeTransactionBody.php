<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: freeze.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * A transaction body for all five freeze transactions.
 * Combining five different transactions into a single message, this
 * transaction body MUST support options to schedule a freeze, abort a
 * scheduled freeze, prepare a software upgrade, prepare a telemetry
 * upgrade, or initiate a software upgrade.
 * For a scheduled freeze, at the scheduled time, according to
 * network consensus time
 *   - A freeze (`FREEZE_ONLY`) causes the network nodes to stop creating
 *     events or accepting transactions, and enter a persistent
 *     maintenance state.
 *   - A freeze upgrade (`FREEZE_UPGRADE`) causes the network nodes to stop
 *     creating events or accepting transactions, and upgrade the node software
 *     from a previously prepared upgrade package. The network nodes then
 *     restart and rejoin the network after upgrading.
 * For other freeze types, immediately upon processing the freeze transaction
 *   - A Freeze Abort (`FREEZE_ABORT`) cancels any pending scheduled freeze.
 *   - A prepare upgrade (`PREPARE_UPGRADE`) begins to extract the contents of
 *     the specified upgrade file to the local filesystem.
 *   - A telemetry upgrade (`TELEMETRY_UPGRADE`) causes the network nodes to
 *     extract a telemetry upgrade package to the local filesystem and signal
 *     other software on the machine to upgrade, without impacting the node or
 *     network processing.
 * ### Block Stream Effects
 * Unknown
 *
 * Generated from protobuf message <code>proto.FreezeTransactionBody</code>
 */
class FreezeTransactionBody extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * Rejected if set; replace with `start_time`.<br/>
     * The start hour (in UTC time), a value between 0 and 23
     *
     * Generated from protobuf field <code>int32 startHour = 1 [deprecated = true];</code>
     * @deprecated
     */
    protected $startHour = 0;
    /**
     **
     * Rejected if set; replace with `start_time`.<br/>
     * The start minute (in UTC time), a value between 0 and 59
     *
     * Generated from protobuf field <code>int32 startMin = 2 [deprecated = true];</code>
     * @deprecated
     */
    protected $startMin = 0;
    /**
     **
     * Rejected if set; end time is neither assigned nor guaranteed and depends
     * on many uncontrolled factors.<br/>
     * The end hour (in UTC time), a value between 0 and 23
     *
     * Generated from protobuf field <code>int32 endHour = 3 [deprecated = true];</code>
     * @deprecated
     */
    protected $endHour = 0;
    /**
     **
     * Rejected if set; end time is neither assigned nor guaranteed and depends
     * on many uncontrolled factors.<br/>
     * The end minute (in UTC time), a value between 0 and 59
     *
     * Generated from protobuf field <code>int32 endMin = 4 [deprecated = true];</code>
     * @deprecated
     */
    protected $endMin = 0;
    /**
     **
     * An upgrade file.
     * <p>
     * If set, the identifier of a file in network state.<br/>
     * The contents of this file MUST be a `zip` file and this data
     * SHALL be extracted to the node filesystem during a
     * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
     * The `file_hash` field MUST match the SHA384 hash of the content
     * of this file.<br/>
     * The extracted data SHALL be used to perform a network software update
     * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
     *
     * Generated from protobuf field <code>.proto.FileID update_file = 5;</code>
     */
    protected $update_file = null;
    /**
     **
     * A SHA384 hash of file content.<br/>
     * This is a hash of the file identified by `update_file`.
     * <p>
     * This MUST be set if `update_file` is set, and MUST match the
     * SHA384 hash of the contents of that file.
     *
     * Generated from protobuf field <code>bytes file_hash = 6;</code>
     */
    protected $file_hash = '';
    /**
     **
     * A start time for the freeze.
     * <p>
     * If this field is REQUIRED for the specified `freeze_type`, then
     * when the network consensus time reaches this instant<ol>
     *   <li>The network SHALL stop accepting transactions.</li>
     *   <li>The network SHALL gossip a freeze state.</li>
     *   <li>The nodes SHALL, in coordinated order, disconnect and
     *       shut down.</li>
     *   <li>The nodes SHALL halt or perform a software upgrade, depending
     *       on `freeze_type`.</li>
     *   <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
     *       restart and rejoin the network upon completion of the
     *       software upgrade.</li>
     * </ol>
     * <blockquote>
     * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
     * but the network SHALL NOT stop, halt, or interrupt transaction
     * processing. The required field is an historical anomaly and SHOULD
     * change in a future release.</blockquote>
     *
     * Generated from protobuf field <code>.proto.Timestamp start_time = 7;</code>
     */
    protected $start_time = null;
    /**
     **
     * The type of freeze.
     * <p>
     * This REQUIRED field effectively selects between five quite different
     * transactions in the same transaction body. Depending on this value
     * the service may schedule a freeze, prepare upgrades, perform upgrades,
     * or even abort a previously scheduled freeze.
     *
     * Generated from protobuf field <code>.proto.FreezeType freeze_type = 8;</code>
     */
    protected $freeze_type = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type int $startHour
     *          *
     *           Rejected if set; replace with `start_time`.<br/>
     *           The start hour (in UTC time), a value between 0 and 23
     *     @type int $startMin
     *          *
     *           Rejected if set; replace with `start_time`.<br/>
     *           The start minute (in UTC time), a value between 0 and 59
     *     @type int $endHour
     *          *
     *           Rejected if set; end time is neither assigned nor guaranteed and depends
     *           on many uncontrolled factors.<br/>
     *           The end hour (in UTC time), a value between 0 and 23
     *     @type int $endMin
     *          *
     *           Rejected if set; end time is neither assigned nor guaranteed and depends
     *           on many uncontrolled factors.<br/>
     *           The end minute (in UTC time), a value between 0 and 59
     *     @type \Proto\FileID $update_file
     *          *
     *           An upgrade file.
     *           <p>
     *           If set, the identifier of a file in network state.<br/>
     *           The contents of this file MUST be a `zip` file and this data
     *           SHALL be extracted to the node filesystem during a
     *           `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
     *           The `file_hash` field MUST match the SHA384 hash of the content
     *           of this file.<br/>
     *           The extracted data SHALL be used to perform a network software update
     *           if a `FREEZE_UPGRADE` freeze type is subsequently processed.
     *     @type string $file_hash
     *          *
     *           A SHA384 hash of file content.<br/>
     *           This is a hash of the file identified by `update_file`.
     *           <p>
     *           This MUST be set if `update_file` is set, and MUST match the
     *           SHA384 hash of the contents of that file.
     *     @type \Proto\Timestamp $start_time
     *          *
     *           A start time for the freeze.
     *           <p>
     *           If this field is REQUIRED for the specified `freeze_type`, then
     *           when the network consensus time reaches this instant<ol>
     *             <li>The network SHALL stop accepting transactions.</li>
     *             <li>The network SHALL gossip a freeze state.</li>
     *             <li>The nodes SHALL, in coordinated order, disconnect and
     *                 shut down.</li>
     *             <li>The nodes SHALL halt or perform a software upgrade, depending
     *                 on `freeze_type`.</li>
     *             <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
     *                 restart and rejoin the network upon completion of the
     *                 software upgrade.</li>
     *           </ol>
     *           <blockquote>
     *           If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
     *           but the network SHALL NOT stop, halt, or interrupt transaction
     *           processing. The required field is an historical anomaly and SHOULD
     *           change in a future release.</blockquote>
     *     @type int $freeze_type
     *          *
     *           The type of freeze.
     *           <p>
     *           This REQUIRED field effectively selects between five quite different
     *           transactions in the same transaction body. Depending on this value
     *           the service may schedule a freeze, prepare upgrades, perform upgrades,
     *           or even abort a previously scheduled freeze.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Freeze::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * Rejected if set; replace with `start_time`.<br/>
     * The start hour (in UTC time), a value between 0 and 23
     *
     * Generated from protobuf field <code>int32 startHour = 1 [deprecated = true];</code>
     * @return int
     * @deprecated
     */
    public function getStartHour()
    {
        if ($this->startHour !== 0) {
            @trigger_error('startHour is deprecated.', E_USER_DEPRECATED);
        }
        return $this->startHour;
    }

    /**
     **
     * Rejected if set; replace with `start_time`.<br/>
     * The start hour (in UTC time), a value between 0 and 23
     *
     * Generated from protobuf field <code>int32 startHour = 1 [deprecated = true];</code>
     * @param int $var
     * @return $this
     * @deprecated
     */
    public function setStartHour($var)
    {
        @trigger_error('startHour is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkInt32($var);
        $this->startHour = $var;

        return $this;
    }

    /**
     **
     * Rejected if set; replace with `start_time`.<br/>
     * The start minute (in UTC time), a value between 0 and 59
     *
     * Generated from protobuf field <code>int32 startMin = 2 [deprecated = true];</code>
     * @return int
     * @deprecated
     */
    public function getStartMin()
    {
        if ($this->startMin !== 0) {
            @trigger_error('startMin is deprecated.', E_USER_DEPRECATED);
        }
        return $this->startMin;
    }

    /**
     **
     * Rejected if set; replace with `start_time`.<br/>
     * The start minute (in UTC time), a value between 0 and 59
     *
     * Generated from protobuf field <code>int32 startMin = 2 [deprecated = true];</code>
     * @param int $var
     * @return $this
     * @deprecated
     */
    public function setStartMin($var)
    {
        @trigger_error('startMin is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkInt32($var);
        $this->startMin = $var;

        return $this;
    }

    /**
     **
     * Rejected if set; end time is neither assigned nor guaranteed and depends
     * on many uncontrolled factors.<br/>
     * The end hour (in UTC time), a value between 0 and 23
     *
     * Generated from protobuf field <code>int32 endHour = 3 [deprecated = true];</code>
     * @return int
     * @deprecated
     */
    public function getEndHour()
    {
        if ($this->endHour !== 0) {
            @trigger_error('endHour is deprecated.', E_USER_DEPRECATED);
        }
        return $this->endHour;
    }

    /**
     **
     * Rejected if set; end time is neither assigned nor guaranteed and depends
     * on many uncontrolled factors.<br/>
     * The end hour (in UTC time), a value between 0 and 23
     *
     * Generated from protobuf field <code>int32 endHour = 3 [deprecated = true];</code>
     * @param int $var
     * @return $this
     * @deprecated
     */
    public function setEndHour($var)
    {
        @trigger_error('endHour is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkInt32($var);
        $this->endHour = $var;

        return $this;
    }

    /**
     **
     * Rejected if set; end time is neither assigned nor guaranteed and depends
     * on many uncontrolled factors.<br/>
     * The end minute (in UTC time), a value between 0 and 59
     *
     * Generated from protobuf field <code>int32 endMin = 4 [deprecated = true];</code>
     * @return int
     * @deprecated
     */
    public function getEndMin()
    {
        if ($this->endMin !== 0) {
            @trigger_error('endMin is deprecated.', E_USER_DEPRECATED);
        }
        return $this->endMin;
    }

    /**
     **
     * Rejected if set; end time is neither assigned nor guaranteed and depends
     * on many uncontrolled factors.<br/>
     * The end minute (in UTC time), a value between 0 and 59
     *
     * Generated from protobuf field <code>int32 endMin = 4 [deprecated = true];</code>
     * @param int $var
     * @return $this
     * @deprecated
     */
    public function setEndMin($var)
    {
        @trigger_error('endMin is deprecated.', E_USER_DEPRECATED);
        GPBUtil::checkInt32($var);
        $this->endMin = $var;

        return $this;
    }

    /**
     **
     * An upgrade file.
     * <p>
     * If set, the identifier of a file in network state.<br/>
     * The contents of this file MUST be a `zip` file and this data
     * SHALL be extracted to the node filesystem during a
     * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
     * The `file_hash` field MUST match the SHA384 hash of the content
     * of this file.<br/>
     * The extracted data SHALL be used to perform a network software update
     * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
     *
     * Generated from protobuf field <code>.proto.FileID update_file = 5;</code>
     * @return \Proto\FileID|null
     */
    public function getUpdateFile()
    {
        return $this->update_file;
    }

    public function hasUpdateFile()
    {
        return isset($this->update_file);
    }

    public function clearUpdateFile()
    {
        unset($this->update_file);
    }

    /**
     **
     * An upgrade file.
     * <p>
     * If set, the identifier of a file in network state.<br/>
     * The contents of this file MUST be a `zip` file and this data
     * SHALL be extracted to the node filesystem during a
     * `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.<br/>
     * The `file_hash` field MUST match the SHA384 hash of the content
     * of this file.<br/>
     * The extracted data SHALL be used to perform a network software update
     * if a `FREEZE_UPGRADE` freeze type is subsequently processed.
     *
     * Generated from protobuf field <code>.proto.FileID update_file = 5;</code>
     * @param \Proto\FileID $var
     * @return $this
     */
    public function setUpdateFile($var)
    {
        GPBUtil::checkMessage($var, \Proto\FileID::class);
        $this->update_file = $var;

        return $this;
    }

    /**
     **
     * A SHA384 hash of file content.<br/>
     * This is a hash of the file identified by `update_file`.
     * <p>
     * This MUST be set if `update_file` is set, and MUST match the
     * SHA384 hash of the contents of that file.
     *
     * Generated from protobuf field <code>bytes file_hash = 6;</code>
     * @return string
     */
    public function getFileHash()
    {
        return $this->file_hash;
    }

    /**
     **
     * A SHA384 hash of file content.<br/>
     * This is a hash of the file identified by `update_file`.
     * <p>
     * This MUST be set if `update_file` is set, and MUST match the
     * SHA384 hash of the contents of that file.
     *
     * Generated from protobuf field <code>bytes file_hash = 6;</code>
     * @param string $var
     * @return $this
     */
    public function setFileHash($var)
    {
        GPBUtil::checkString($var, False);
        $this->file_hash = $var;

        return $this;
    }

    /**
     **
     * A start time for the freeze.
     * <p>
     * If this field is REQUIRED for the specified `freeze_type`, then
     * when the network consensus time reaches this instant<ol>
     *   <li>The network SHALL stop accepting transactions.</li>
     *   <li>The network SHALL gossip a freeze state.</li>
     *   <li>The nodes SHALL, in coordinated order, disconnect and
     *       shut down.</li>
     *   <li>The nodes SHALL halt or perform a software upgrade, depending
     *       on `freeze_type`.</li>
     *   <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
     *       restart and rejoin the network upon completion of the
     *       software upgrade.</li>
     * </ol>
     * <blockquote>
     * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
     * but the network SHALL NOT stop, halt, or interrupt transaction
     * processing. The required field is an historical anomaly and SHOULD
     * change in a future release.</blockquote>
     *
     * Generated from protobuf field <code>.proto.Timestamp start_time = 7;</code>
     * @return \Proto\Timestamp|null
     */
    public function getStartTime()
    {
        return $this->start_time;
    }

    public function hasStartTime()
    {
        return isset($this->start_time);
    }

    public function clearStartTime()
    {
        unset($this->start_time);
    }

    /**
     **
     * A start time for the freeze.
     * <p>
     * If this field is REQUIRED for the specified `freeze_type`, then
     * when the network consensus time reaches this instant<ol>
     *   <li>The network SHALL stop accepting transactions.</li>
     *   <li>The network SHALL gossip a freeze state.</li>
     *   <li>The nodes SHALL, in coordinated order, disconnect and
     *       shut down.</li>
     *   <li>The nodes SHALL halt or perform a software upgrade, depending
     *       on `freeze_type`.</li>
     *   <li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
     *       restart and rejoin the network upon completion of the
     *       software upgrade.</li>
     * </ol>
     * <blockquote>
     * If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
     * but the network SHALL NOT stop, halt, or interrupt transaction
     * processing. The required field is an historical anomaly and SHOULD
     * change in a future release.</blockquote>
     *
     * Generated from protobuf field <code>.proto.Timestamp start_time = 7;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setStartTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->start_time = $var;

        return $this;
    }

    /**
     **
     * The type of freeze.
     * <p>
     * This REQUIRED field effectively selects between five quite different
     * transactions in the same transaction body. Depending on this value
     * the service may schedule a freeze, prepare upgrades, perform upgrades,
     * or even abort a previously scheduled freeze.
     *
     * Generated from protobuf field <code>.proto.FreezeType freeze_type = 8;</code>
     * @return int
     */
    public function getFreezeType()
    {
        return $this->freeze_type;
    }

    /**
     **
     * The type of freeze.
     * <p>
     * This REQUIRED field effectively selects between five quite different
     * transactions in the same transaction body. Depending on this value
     * the service may schedule a freeze, prepare upgrades, perform upgrades,
     * or even abort a previously scheduled freeze.
     *
     * Generated from protobuf field <code>.proto.FreezeType freeze_type = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setFreezeType($var)
    {
        GPBUtil::checkEnum($var, \Proto\FreezeType::class);
        $this->freeze_type = $var;

        return $this;
    }

}

