<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: schedule_get_info.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * Information summarizing schedule state
 *
 * Generated from protobuf message <code>proto.ScheduleInfo</code>
 */
class ScheduleInfo extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A schedule identifier.
     * <p>
     * This SHALL identify the schedule retrieved.
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleID = 1;</code>
     */
    protected $scheduleID = null;
    /**
     **
     * An expiration timestamp.<br/>
     * This represents the time at which the schedule will expire. For a
     * long-term schedule (if enabled) this is when the schedule will be
     * executed, assuming it meets signature requirements at that time.
     * For a short-term schedule, this is the deadline to complete the
     * signature requirements for the scheduled transaction to execute.
     * Regardless of schedule type, the schedule will be removed from
     * state when it expires.
     * <p>
     * A schedule SHALL be removed from state when it expires.<br/>
     * A short-term schedule MUST meet signature requirements strictly
     * before expiration or it SHALL NOT be executed.<br/>
     * A long-term schedule SHALL be executed if, and only if, all signature
     * requirements for the scheduled transaction are met at expiration.<br/>
     * A long-term schedule SHALL NOT be executed if any signature requirement
     * for the scheduled transaction are not met at expiration.<br/>
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 4;</code>
     */
    protected $expirationTime = null;
    /**
     **
     * A scheduled transaction.
     * <p>
     * This SHALL be a transaction type enabled in the network property
     * `scheduling.whitelist`, and SHALL NOT be any other
     * transaction type.<br/>
     * This transaction SHALL be executed if the schedule meets all signature
     * and execution time requirements for this transaction.<br/>
     * The signature requirements for this transaction SHALL be evaluated
     * at schedule creation, SHALL be reevaluated with each `signSchedule`
     * transaction, and, for long-term schedules, SHALL be reevaluated when
     * the schedule expires.<br/>
     *
     * Generated from protobuf field <code>.proto.SchedulableTransactionBody scheduledTransactionBody = 5;</code>
     */
    protected $scheduledTransactionBody = null;
    /**
     **
     * A short description for this schedule.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 6;</code>
     */
    protected $memo = '';
    /**
     **
     * The key used to delete the schedule from state
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 7;</code>
     */
    protected $adminKey = null;
    /**
     **
     * A list of "valid" signatures for this schedule.<br/>
     * This list contains only "primitive" (i.e. cryptographic or contract)
     * signatures. The full signature requirements for the scheduled
     * transaction are evaluated as if this list of keys had signed the
     * scheduled transaction directly.
     * <p>
     * This list SHALL contain every "primitive" key that has signed the
     * original `createSchedule`, or any subsequent
     * `signSchedule` transaction.<br/>
     * This list MAY elide any signature not likely to be required by the
     * scheduled transaction. Such requirement SHOULD be evaluated when the
     * signature is presented (i.e. during evaluation of a `createSchedule` or
     * `signSchedule` transaction).
     *
     * Generated from protobuf field <code>.proto.KeyList signers = 8;</code>
     */
    protected $signers = null;
    /**
     **
     * An account identifier.
     * <p>
     * This SHALL identify the account that created this schedule.
     *
     * Generated from protobuf field <code>.proto.AccountID creatorAccountID = 9;</code>
     */
    protected $creatorAccountID = null;
    /**
     **
     * An account identifier.
     * <p>
     * The identified account SHALL pay the full transaction fee for the
     * scheduled transaction _when it executes_.
     *
     * Generated from protobuf field <code>.proto.AccountID payerAccountID = 10;</code>
     */
    protected $payerAccountID = null;
    /**
     **
     * A transaction identifier.
     * <p>
     * This SHALL be recorded as the transaction identifier for the
     * _scheduled_ transaction, if (and when) it is executed.
     *
     * Generated from protobuf field <code>.proto.TransactionID scheduledTransactionID = 11;</code>
     */
    protected $scheduledTransactionID = null;
    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 12;</code>
     */
    protected $ledger_id = '';
    /**
     **
     * A flag indicating this schedule will execute when it expires.
     * <p>
     * If this field is set
     * <ul>
     *   <li>This schedule SHALL be considered a "long-term" schedule.</li>
     *   <li>This schedule SHALL be evaluated when the network consensus time
     *       reaches the `expirationTime`, and if the signature requirements
     *       for the scheduled transaction are met at that time, the
     *       scheduled transaction SHALL be executed.</li>
     *   <li>This schedule SHALL NOT be executed before the network consensus
     *       time reaches the `expirationTime`.</li>
     * </ul>
     * If this field is not set
     * <ul>
     *   <li>This schedule SHALL be considered a "short-term" schedule.</li>
     *   <li>This schedule SHALL be evaluated when created, and reevaluated
     *       with each `signSchedule` transaction, and if the signature
     *       requirements for the scheduled transaction are met at that time,
     *       the scheduled transaction SHALL be executed immediately.</li>
     *   <li>This schedule SHALL be executed as soon as the signature
     *       requirements are met, and MUST be executed before the network
     *       consensus time reaches the `expirationTime`, if at all.</li>
     * </ul>
     *
     * Generated from protobuf field <code>bool wait_for_expiry = 13;</code>
     */
    protected $wait_for_expiry = false;
    protected $data;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\ScheduleID $scheduleID
     *          *
     *           A schedule identifier.
     *           <p>
     *           This SHALL identify the schedule retrieved.
     *     @type \Proto\Timestamp $deletion_time
     *          *
     *           A deletion timestamp.
     *           <p>
     *           If the schedule was deleted, this SHALL be set to the consensus
     *           timestamp of the `deleteSchedule` transaction.<br/>
     *           If the schedule is _not_ deleted, this field SHALL NOT be set.
     *     @type \Proto\Timestamp $execution_time
     *          *
     *           An execution timestamp.
     *           <p>
     *           If the schedule was completed, and the _scheduled_ transaction
     *           executed, this SHALL be set to the consensus timestamp of the
     *           transaction that initiated that execution.<br/>
     *           If the schedule is _not_ complete, this field SHALL NOT be set.
     *     @type \Proto\Timestamp $expirationTime
     *          *
     *           An expiration timestamp.<br/>
     *           This represents the time at which the schedule will expire. For a
     *           long-term schedule (if enabled) this is when the schedule will be
     *           executed, assuming it meets signature requirements at that time.
     *           For a short-term schedule, this is the deadline to complete the
     *           signature requirements for the scheduled transaction to execute.
     *           Regardless of schedule type, the schedule will be removed from
     *           state when it expires.
     *           <p>
     *           A schedule SHALL be removed from state when it expires.<br/>
     *           A short-term schedule MUST meet signature requirements strictly
     *           before expiration or it SHALL NOT be executed.<br/>
     *           A long-term schedule SHALL be executed if, and only if, all signature
     *           requirements for the scheduled transaction are met at expiration.<br/>
     *           A long-term schedule SHALL NOT be executed if any signature requirement
     *           for the scheduled transaction are not met at expiration.<br/>
     *     @type \Proto\SchedulableTransactionBody $scheduledTransactionBody
     *          *
     *           A scheduled transaction.
     *           <p>
     *           This SHALL be a transaction type enabled in the network property
     *           `scheduling.whitelist`, and SHALL NOT be any other
     *           transaction type.<br/>
     *           This transaction SHALL be executed if the schedule meets all signature
     *           and execution time requirements for this transaction.<br/>
     *           The signature requirements for this transaction SHALL be evaluated
     *           at schedule creation, SHALL be reevaluated with each `signSchedule`
     *           transaction, and, for long-term schedules, SHALL be reevaluated when
     *           the schedule expires.<br/>
     *     @type string $memo
     *          *
     *           A short description for this schedule.
     *           <p>
     *           This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     *           (default 100) bytes when encoded as UTF-8.
     *     @type \Proto\Key $adminKey
     *          *
     *           The key used to delete the schedule from state
     *     @type \Proto\KeyList $signers
     *          *
     *           A list of "valid" signatures for this schedule.<br/>
     *           This list contains only "primitive" (i.e. cryptographic or contract)
     *           signatures. The full signature requirements for the scheduled
     *           transaction are evaluated as if this list of keys had signed the
     *           scheduled transaction directly.
     *           <p>
     *           This list SHALL contain every "primitive" key that has signed the
     *           original `createSchedule`, or any subsequent
     *           `signSchedule` transaction.<br/>
     *           This list MAY elide any signature not likely to be required by the
     *           scheduled transaction. Such requirement SHOULD be evaluated when the
     *           signature is presented (i.e. during evaluation of a `createSchedule` or
     *           `signSchedule` transaction).
     *     @type \Proto\AccountID $creatorAccountID
     *          *
     *           An account identifier.
     *           <p>
     *           This SHALL identify the account that created this schedule.
     *     @type \Proto\AccountID $payerAccountID
     *          *
     *           An account identifier.
     *           <p>
     *           The identified account SHALL pay the full transaction fee for the
     *           scheduled transaction _when it executes_.
     *     @type \Proto\TransactionID $scheduledTransactionID
     *          *
     *           A transaction identifier.
     *           <p>
     *           This SHALL be recorded as the transaction identifier for the
     *           _scheduled_ transaction, if (and when) it is executed.
     *     @type string $ledger_id
     *          *
     *           The ledger ID of the network that generated this response.
     *           <p>
     *           This value SHALL identify the distributed ledger that responded to
     *           this query.
     *     @type bool $wait_for_expiry
     *          *
     *           A flag indicating this schedule will execute when it expires.
     *           <p>
     *           If this field is set
     *           <ul>
     *             <li>This schedule SHALL be considered a "long-term" schedule.</li>
     *             <li>This schedule SHALL be evaluated when the network consensus time
     *                 reaches the `expirationTime`, and if the signature requirements
     *                 for the scheduled transaction are met at that time, the
     *                 scheduled transaction SHALL be executed.</li>
     *             <li>This schedule SHALL NOT be executed before the network consensus
     *                 time reaches the `expirationTime`.</li>
     *           </ul>
     *           If this field is not set
     *           <ul>
     *             <li>This schedule SHALL be considered a "short-term" schedule.</li>
     *             <li>This schedule SHALL be evaluated when created, and reevaluated
     *                 with each `signSchedule` transaction, and if the signature
     *                 requirements for the scheduled transaction are met at that time,
     *                 the scheduled transaction SHALL be executed immediately.</li>
     *             <li>This schedule SHALL be executed as soon as the signature
     *                 requirements are met, and MUST be executed before the network
     *                 consensus time reaches the `expirationTime`, if at all.</li>
     *           </ul>
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ScheduleGetInfo::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A schedule identifier.
     * <p>
     * This SHALL identify the schedule retrieved.
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleID = 1;</code>
     * @return \Proto\ScheduleID|null
     */
    public function getScheduleID()
    {
        return $this->scheduleID;
    }

    public function hasScheduleID()
    {
        return isset($this->scheduleID);
    }

    public function clearScheduleID()
    {
        unset($this->scheduleID);
    }

    /**
     **
     * A schedule identifier.
     * <p>
     * This SHALL identify the schedule retrieved.
     *
     * Generated from protobuf field <code>.proto.ScheduleID scheduleID = 1;</code>
     * @param \Proto\ScheduleID $var
     * @return $this
     */
    public function setScheduleID($var)
    {
        GPBUtil::checkMessage($var, \Proto\ScheduleID::class);
        $this->scheduleID = $var;

        return $this;
    }

    /**
     **
     * A deletion timestamp.
     * <p>
     * If the schedule was deleted, this SHALL be set to the consensus
     * timestamp of the `deleteSchedule` transaction.<br/>
     * If the schedule is _not_ deleted, this field SHALL NOT be set.
     *
     * Generated from protobuf field <code>.proto.Timestamp deletion_time = 2;</code>
     * @return \Proto\Timestamp|null
     */
    public function getDeletionTime()
    {
        return $this->readOneof(2);
    }

    public function hasDeletionTime()
    {
        return $this->hasOneof(2);
    }

    /**
     **
     * A deletion timestamp.
     * <p>
     * If the schedule was deleted, this SHALL be set to the consensus
     * timestamp of the `deleteSchedule` transaction.<br/>
     * If the schedule is _not_ deleted, this field SHALL NOT be set.
     *
     * Generated from protobuf field <code>.proto.Timestamp deletion_time = 2;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setDeletionTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->writeOneof(2, $var);

        return $this;
    }

    /**
     **
     * An execution timestamp.
     * <p>
     * If the schedule was completed, and the _scheduled_ transaction
     * executed, this SHALL be set to the consensus timestamp of the
     * transaction that initiated that execution.<br/>
     * If the schedule is _not_ complete, this field SHALL NOT be set.
     *
     * Generated from protobuf field <code>.proto.Timestamp execution_time = 3;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExecutionTime()
    {
        return $this->readOneof(3);
    }

    public function hasExecutionTime()
    {
        return $this->hasOneof(3);
    }

    /**
     **
     * An execution timestamp.
     * <p>
     * If the schedule was completed, and the _scheduled_ transaction
     * executed, this SHALL be set to the consensus timestamp of the
     * transaction that initiated that execution.<br/>
     * If the schedule is _not_ complete, this field SHALL NOT be set.
     *
     * Generated from protobuf field <code>.proto.Timestamp execution_time = 3;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExecutionTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     **
     * An expiration timestamp.<br/>
     * This represents the time at which the schedule will expire. For a
     * long-term schedule (if enabled) this is when the schedule will be
     * executed, assuming it meets signature requirements at that time.
     * For a short-term schedule, this is the deadline to complete the
     * signature requirements for the scheduled transaction to execute.
     * Regardless of schedule type, the schedule will be removed from
     * state when it expires.
     * <p>
     * A schedule SHALL be removed from state when it expires.<br/>
     * A short-term schedule MUST meet signature requirements strictly
     * before expiration or it SHALL NOT be executed.<br/>
     * A long-term schedule SHALL be executed if, and only if, all signature
     * requirements for the scheduled transaction are met at expiration.<br/>
     * A long-term schedule SHALL NOT be executed if any signature requirement
     * for the scheduled transaction are not met at expiration.<br/>
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 4;</code>
     * @return \Proto\Timestamp|null
     */
    public function getExpirationTime()
    {
        return $this->expirationTime;
    }

    public function hasExpirationTime()
    {
        return isset($this->expirationTime);
    }

    public function clearExpirationTime()
    {
        unset($this->expirationTime);
    }

    /**
     **
     * An expiration timestamp.<br/>
     * This represents the time at which the schedule will expire. For a
     * long-term schedule (if enabled) this is when the schedule will be
     * executed, assuming it meets signature requirements at that time.
     * For a short-term schedule, this is the deadline to complete the
     * signature requirements for the scheduled transaction to execute.
     * Regardless of schedule type, the schedule will be removed from
     * state when it expires.
     * <p>
     * A schedule SHALL be removed from state when it expires.<br/>
     * A short-term schedule MUST meet signature requirements strictly
     * before expiration or it SHALL NOT be executed.<br/>
     * A long-term schedule SHALL be executed if, and only if, all signature
     * requirements for the scheduled transaction are met at expiration.<br/>
     * A long-term schedule SHALL NOT be executed if any signature requirement
     * for the scheduled transaction are not met at expiration.<br/>
     *
     * Generated from protobuf field <code>.proto.Timestamp expirationTime = 4;</code>
     * @param \Proto\Timestamp $var
     * @return $this
     */
    public function setExpirationTime($var)
    {
        GPBUtil::checkMessage($var, \Proto\Timestamp::class);
        $this->expirationTime = $var;

        return $this;
    }

    /**
     **
     * A scheduled transaction.
     * <p>
     * This SHALL be a transaction type enabled in the network property
     * `scheduling.whitelist`, and SHALL NOT be any other
     * transaction type.<br/>
     * This transaction SHALL be executed if the schedule meets all signature
     * and execution time requirements for this transaction.<br/>
     * The signature requirements for this transaction SHALL be evaluated
     * at schedule creation, SHALL be reevaluated with each `signSchedule`
     * transaction, and, for long-term schedules, SHALL be reevaluated when
     * the schedule expires.<br/>
     *
     * Generated from protobuf field <code>.proto.SchedulableTransactionBody scheduledTransactionBody = 5;</code>
     * @return \Proto\SchedulableTransactionBody|null
     */
    public function getScheduledTransactionBody()
    {
        return $this->scheduledTransactionBody;
    }

    public function hasScheduledTransactionBody()
    {
        return isset($this->scheduledTransactionBody);
    }

    public function clearScheduledTransactionBody()
    {
        unset($this->scheduledTransactionBody);
    }

    /**
     **
     * A scheduled transaction.
     * <p>
     * This SHALL be a transaction type enabled in the network property
     * `scheduling.whitelist`, and SHALL NOT be any other
     * transaction type.<br/>
     * This transaction SHALL be executed if the schedule meets all signature
     * and execution time requirements for this transaction.<br/>
     * The signature requirements for this transaction SHALL be evaluated
     * at schedule creation, SHALL be reevaluated with each `signSchedule`
     * transaction, and, for long-term schedules, SHALL be reevaluated when
     * the schedule expires.<br/>
     *
     * Generated from protobuf field <code>.proto.SchedulableTransactionBody scheduledTransactionBody = 5;</code>
     * @param \Proto\SchedulableTransactionBody $var
     * @return $this
     */
    public function setScheduledTransactionBody($var)
    {
        GPBUtil::checkMessage($var, \Proto\SchedulableTransactionBody::class);
        $this->scheduledTransactionBody = $var;

        return $this;
    }

    /**
     **
     * A short description for this schedule.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 6;</code>
     * @return string
     */
    public function getMemo()
    {
        return $this->memo;
    }

    /**
     **
     * A short description for this schedule.
     * <p>
     * This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
     * (default 100) bytes when encoded as UTF-8.
     *
     * Generated from protobuf field <code>string memo = 6;</code>
     * @param string $var
     * @return $this
     */
    public function setMemo($var)
    {
        GPBUtil::checkString($var, True);
        $this->memo = $var;

        return $this;
    }

    /**
     **
     * The key used to delete the schedule from state
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 7;</code>
     * @return \Proto\Key|null
     */
    public function getAdminKey()
    {
        return $this->adminKey;
    }

    public function hasAdminKey()
    {
        return isset($this->adminKey);
    }

    public function clearAdminKey()
    {
        unset($this->adminKey);
    }

    /**
     **
     * The key used to delete the schedule from state
     *
     * Generated from protobuf field <code>.proto.Key adminKey = 7;</code>
     * @param \Proto\Key $var
     * @return $this
     */
    public function setAdminKey($var)
    {
        GPBUtil::checkMessage($var, \Proto\Key::class);
        $this->adminKey = $var;

        return $this;
    }

    /**
     **
     * A list of "valid" signatures for this schedule.<br/>
     * This list contains only "primitive" (i.e. cryptographic or contract)
     * signatures. The full signature requirements for the scheduled
     * transaction are evaluated as if this list of keys had signed the
     * scheduled transaction directly.
     * <p>
     * This list SHALL contain every "primitive" key that has signed the
     * original `createSchedule`, or any subsequent
     * `signSchedule` transaction.<br/>
     * This list MAY elide any signature not likely to be required by the
     * scheduled transaction. Such requirement SHOULD be evaluated when the
     * signature is presented (i.e. during evaluation of a `createSchedule` or
     * `signSchedule` transaction).
     *
     * Generated from protobuf field <code>.proto.KeyList signers = 8;</code>
     * @return \Proto\KeyList|null
     */
    public function getSigners()
    {
        return $this->signers;
    }

    public function hasSigners()
    {
        return isset($this->signers);
    }

    public function clearSigners()
    {
        unset($this->signers);
    }

    /**
     **
     * A list of "valid" signatures for this schedule.<br/>
     * This list contains only "primitive" (i.e. cryptographic or contract)
     * signatures. The full signature requirements for the scheduled
     * transaction are evaluated as if this list of keys had signed the
     * scheduled transaction directly.
     * <p>
     * This list SHALL contain every "primitive" key that has signed the
     * original `createSchedule`, or any subsequent
     * `signSchedule` transaction.<br/>
     * This list MAY elide any signature not likely to be required by the
     * scheduled transaction. Such requirement SHOULD be evaluated when the
     * signature is presented (i.e. during evaluation of a `createSchedule` or
     * `signSchedule` transaction).
     *
     * Generated from protobuf field <code>.proto.KeyList signers = 8;</code>
     * @param \Proto\KeyList $var
     * @return $this
     */
    public function setSigners($var)
    {
        GPBUtil::checkMessage($var, \Proto\KeyList::class);
        $this->signers = $var;

        return $this;
    }

    /**
     **
     * An account identifier.
     * <p>
     * This SHALL identify the account that created this schedule.
     *
     * Generated from protobuf field <code>.proto.AccountID creatorAccountID = 9;</code>
     * @return \Proto\AccountID|null
     */
    public function getCreatorAccountID()
    {
        return $this->creatorAccountID;
    }

    public function hasCreatorAccountID()
    {
        return isset($this->creatorAccountID);
    }

    public function clearCreatorAccountID()
    {
        unset($this->creatorAccountID);
    }

    /**
     **
     * An account identifier.
     * <p>
     * This SHALL identify the account that created this schedule.
     *
     * Generated from protobuf field <code>.proto.AccountID creatorAccountID = 9;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setCreatorAccountID($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->creatorAccountID = $var;

        return $this;
    }

    /**
     **
     * An account identifier.
     * <p>
     * The identified account SHALL pay the full transaction fee for the
     * scheduled transaction _when it executes_.
     *
     * Generated from protobuf field <code>.proto.AccountID payerAccountID = 10;</code>
     * @return \Proto\AccountID|null
     */
    public function getPayerAccountID()
    {
        return $this->payerAccountID;
    }

    public function hasPayerAccountID()
    {
        return isset($this->payerAccountID);
    }

    public function clearPayerAccountID()
    {
        unset($this->payerAccountID);
    }

    /**
     **
     * An account identifier.
     * <p>
     * The identified account SHALL pay the full transaction fee for the
     * scheduled transaction _when it executes_.
     *
     * Generated from protobuf field <code>.proto.AccountID payerAccountID = 10;</code>
     * @param \Proto\AccountID $var
     * @return $this
     */
    public function setPayerAccountID($var)
    {
        GPBUtil::checkMessage($var, \Proto\AccountID::class);
        $this->payerAccountID = $var;

        return $this;
    }

    /**
     **
     * A transaction identifier.
     * <p>
     * This SHALL be recorded as the transaction identifier for the
     * _scheduled_ transaction, if (and when) it is executed.
     *
     * Generated from protobuf field <code>.proto.TransactionID scheduledTransactionID = 11;</code>
     * @return \Proto\TransactionID|null
     */
    public function getScheduledTransactionID()
    {
        return $this->scheduledTransactionID;
    }

    public function hasScheduledTransactionID()
    {
        return isset($this->scheduledTransactionID);
    }

    public function clearScheduledTransactionID()
    {
        unset($this->scheduledTransactionID);
    }

    /**
     **
     * A transaction identifier.
     * <p>
     * This SHALL be recorded as the transaction identifier for the
     * _scheduled_ transaction, if (and when) it is executed.
     *
     * Generated from protobuf field <code>.proto.TransactionID scheduledTransactionID = 11;</code>
     * @param \Proto\TransactionID $var
     * @return $this
     */
    public function setScheduledTransactionID($var)
    {
        GPBUtil::checkMessage($var, \Proto\TransactionID::class);
        $this->scheduledTransactionID = $var;

        return $this;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 12;</code>
     * @return string
     */
    public function getLedgerId()
    {
        return $this->ledger_id;
    }

    /**
     **
     * The ledger ID of the network that generated this response.
     * <p>
     * This value SHALL identify the distributed ledger that responded to
     * this query.
     *
     * Generated from protobuf field <code>bytes ledger_id = 12;</code>
     * @param string $var
     * @return $this
     */
    public function setLedgerId($var)
    {
        GPBUtil::checkString($var, False);
        $this->ledger_id = $var;

        return $this;
    }

    /**
     **
     * A flag indicating this schedule will execute when it expires.
     * <p>
     * If this field is set
     * <ul>
     *   <li>This schedule SHALL be considered a "long-term" schedule.</li>
     *   <li>This schedule SHALL be evaluated when the network consensus time
     *       reaches the `expirationTime`, and if the signature requirements
     *       for the scheduled transaction are met at that time, the
     *       scheduled transaction SHALL be executed.</li>
     *   <li>This schedule SHALL NOT be executed before the network consensus
     *       time reaches the `expirationTime`.</li>
     * </ul>
     * If this field is not set
     * <ul>
     *   <li>This schedule SHALL be considered a "short-term" schedule.</li>
     *   <li>This schedule SHALL be evaluated when created, and reevaluated
     *       with each `signSchedule` transaction, and if the signature
     *       requirements for the scheduled transaction are met at that time,
     *       the scheduled transaction SHALL be executed immediately.</li>
     *   <li>This schedule SHALL be executed as soon as the signature
     *       requirements are met, and MUST be executed before the network
     *       consensus time reaches the `expirationTime`, if at all.</li>
     * </ul>
     *
     * Generated from protobuf field <code>bool wait_for_expiry = 13;</code>
     * @return bool
     */
    public function getWaitForExpiry()
    {
        return $this->wait_for_expiry;
    }

    /**
     **
     * A flag indicating this schedule will execute when it expires.
     * <p>
     * If this field is set
     * <ul>
     *   <li>This schedule SHALL be considered a "long-term" schedule.</li>
     *   <li>This schedule SHALL be evaluated when the network consensus time
     *       reaches the `expirationTime`, and if the signature requirements
     *       for the scheduled transaction are met at that time, the
     *       scheduled transaction SHALL be executed.</li>
     *   <li>This schedule SHALL NOT be executed before the network consensus
     *       time reaches the `expirationTime`.</li>
     * </ul>
     * If this field is not set
     * <ul>
     *   <li>This schedule SHALL be considered a "short-term" schedule.</li>
     *   <li>This schedule SHALL be evaluated when created, and reevaluated
     *       with each `signSchedule` transaction, and if the signature
     *       requirements for the scheduled transaction are met at that time,
     *       the scheduled transaction SHALL be executed immediately.</li>
     *   <li>This schedule SHALL be executed as soon as the signature
     *       requirements are met, and MUST be executed before the network
     *       consensus time reaches the `expirationTime`, if at all.</li>
     * </ul>
     *
     * Generated from protobuf field <code>bool wait_for_expiry = 13;</code>
     * @param bool $var
     * @return $this
     */
    public function setWaitForExpiry($var)
    {
        GPBUtil::checkBool($var);
        $this->wait_for_expiry = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getData()
    {
        return $this->whichOneof("data");
    }

}

