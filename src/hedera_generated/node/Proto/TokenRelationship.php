<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: basic_types.proto

namespace Proto;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 **
 * An Hedera Token Service token relationship. A token relationship describes
 * the connection between an Account and a Token type, including the current
 * account balance in that token.
 * A `TokenRelationship` SHALL contain, for the designated token and enclosing
 * account, The account's current balance, whether the account has KYC granted,
 * whether the assets are frozen and whether the association was automatic.<br/>
 * A `TokenRelationship` MAY also contain the `symbol` and `decimals` values
 * copied from the token.<br/>
 * `TokenRelationship` entries SHALL be valid only within the context of a
 * `GetAccountDetails` query response, or other enclosing message, which
 * specifies the account side of the relationship.
 *
 * Generated from protobuf message <code>proto.TokenRelationship</code>
 */
class TokenRelationship extends \Google\Protobuf\Internal\Message
{
    /**
     **
     * A token identifier.
     * <p>
     * This MUST match an existing token that is not deleted.
     *
     * Generated from protobuf field <code>.proto.TokenID tokenId = 1;</code>
     */
    protected $tokenId = null;
    /**
     **
     * A token symbol.
     * <p>
     * This MUST match an existing token that is not deleted.<br/>
     * This MUST match the value for the token identified in `tokenId`.
     *
     * Generated from protobuf field <code>string symbol = 2;</code>
     */
    protected $symbol = '';
    /**
     **
     * An account balance for this token.
     * <p>
     * For fungible/common tokens this SHALL be the balance that the
     * account holds of that token. The value is provided as an integer amount
     * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
     * tokens).<br/>
     * For non-fungible/unique tokens this SHALL be the whole number of
     * unique tokens held by the account for this token type.
     *
     * Generated from protobuf field <code>uint64 balance = 3;</code>
     */
    protected $balance = 0;
    /**
     **
     * A KYC status for the account with respect to this token.
     * <p>
     * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
     * not supported for this token (e.g. the `kyc_key` of the token is not
     * set), this SHALL be `KycNotApplicable`.
     *
     * Generated from protobuf field <code>.proto.TokenKycStatus kycStatus = 4;</code>
     */
    protected $kycStatus = 0;
    /**
     **
     * A Freeze status for the account with respect to this token.
     * <p>
     * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
     * or `Unfrozen`.<br/>
     * If the token cannot freeze account assets (e.g. the `freeze_key` of the
     * token is not set), this SHALL be `FreezeNotApplicable`.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeStatus freezeStatus = 5;</code>
     */
    protected $freezeStatus = 0;
    /**
     **
     * A maximum "precision" for this token.
     * <p>
     * This value MUST match the `decimals` field of the token identified in
     * the `tokenId` field.<br/>
     * A single whole token SHALL be divided into at most
     * 10<sup>`decimals`</sup> sub-units.
     *
     * Generated from protobuf field <code>uint32 decimals = 6;</code>
     */
    protected $decimals = 0;
    /**
     **
     * An automatic association flag.
     * <p>
     * This SHALL be set if the relationship was created implicitly
     * (automatically).<br/>
     * This SHALL be unset if the relationship was created explicitly
     * (manually) via a `TokenAssociate` transaction.
     *
     * Generated from protobuf field <code>bool automatic_association = 7;</code>
     */
    protected $automatic_association = false;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Proto\TokenID $tokenId
     *          *
     *           A token identifier.
     *           <p>
     *           This MUST match an existing token that is not deleted.
     *     @type string $symbol
     *          *
     *           A token symbol.
     *           <p>
     *           This MUST match an existing token that is not deleted.<br/>
     *           This MUST match the value for the token identified in `tokenId`.
     *     @type int|string $balance
     *          *
     *           An account balance for this token.
     *           <p>
     *           For fungible/common tokens this SHALL be the balance that the
     *           account holds of that token. The value is provided as an integer amount
     *           of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
     *           tokens).<br/>
     *           For non-fungible/unique tokens this SHALL be the whole number of
     *           unique tokens held by the account for this token type.
     *     @type int $kycStatus
     *          *
     *           A KYC status for the account with respect to this token.
     *           <p>
     *           This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
     *           not supported for this token (e.g. the `kyc_key` of the token is not
     *           set), this SHALL be `KycNotApplicable`.
     *     @type int $freezeStatus
     *          *
     *           A Freeze status for the account with respect to this token.
     *           <p>
     *           This value SHALL be one of `FreezeNotApplicable`, `Frozen`
     *           or `Unfrozen`.<br/>
     *           If the token cannot freeze account assets (e.g. the `freeze_key` of the
     *           token is not set), this SHALL be `FreezeNotApplicable`.
     *     @type int $decimals
     *          *
     *           A maximum "precision" for this token.
     *           <p>
     *           This value MUST match the `decimals` field of the token identified in
     *           the `tokenId` field.<br/>
     *           A single whole token SHALL be divided into at most
     *           10<sup>`decimals`</sup> sub-units.
     *     @type bool $automatic_association
     *          *
     *           An automatic association flag.
     *           <p>
     *           This SHALL be set if the relationship was created implicitly
     *           (automatically).<br/>
     *           This SHALL be unset if the relationship was created explicitly
     *           (manually) via a `TokenAssociate` transaction.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\BasicTypes::initOnce();
        parent::__construct($data);
    }

    /**
     **
     * A token identifier.
     * <p>
     * This MUST match an existing token that is not deleted.
     *
     * Generated from protobuf field <code>.proto.TokenID tokenId = 1;</code>
     * @return \Proto\TokenID|null
     */
    public function getTokenId()
    {
        return $this->tokenId;
    }

    public function hasTokenId()
    {
        return isset($this->tokenId);
    }

    public function clearTokenId()
    {
        unset($this->tokenId);
    }

    /**
     **
     * A token identifier.
     * <p>
     * This MUST match an existing token that is not deleted.
     *
     * Generated from protobuf field <code>.proto.TokenID tokenId = 1;</code>
     * @param \Proto\TokenID $var
     * @return $this
     */
    public function setTokenId($var)
    {
        GPBUtil::checkMessage($var, \Proto\TokenID::class);
        $this->tokenId = $var;

        return $this;
    }

    /**
     **
     * A token symbol.
     * <p>
     * This MUST match an existing token that is not deleted.<br/>
     * This MUST match the value for the token identified in `tokenId`.
     *
     * Generated from protobuf field <code>string symbol = 2;</code>
     * @return string
     */
    public function getSymbol()
    {
        return $this->symbol;
    }

    /**
     **
     * A token symbol.
     * <p>
     * This MUST match an existing token that is not deleted.<br/>
     * This MUST match the value for the token identified in `tokenId`.
     *
     * Generated from protobuf field <code>string symbol = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setSymbol($var)
    {
        GPBUtil::checkString($var, True);
        $this->symbol = $var;

        return $this;
    }

    /**
     **
     * An account balance for this token.
     * <p>
     * For fungible/common tokens this SHALL be the balance that the
     * account holds of that token. The value is provided as an integer amount
     * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
     * tokens).<br/>
     * For non-fungible/unique tokens this SHALL be the whole number of
     * unique tokens held by the account for this token type.
     *
     * Generated from protobuf field <code>uint64 balance = 3;</code>
     * @return int|string
     */
    public function getBalance()
    {
        return $this->balance;
    }

    /**
     **
     * An account balance for this token.
     * <p>
     * For fungible/common tokens this SHALL be the balance that the
     * account holds of that token. The value is provided as an integer amount
     * of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
     * tokens).<br/>
     * For non-fungible/unique tokens this SHALL be the whole number of
     * unique tokens held by the account for this token type.
     *
     * Generated from protobuf field <code>uint64 balance = 3;</code>
     * @param int|string $var
     * @return $this
     */
    public function setBalance($var)
    {
        GPBUtil::checkUint64($var);
        $this->balance = $var;

        return $this;
    }

    /**
     **
     * A KYC status for the account with respect to this token.
     * <p>
     * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
     * not supported for this token (e.g. the `kyc_key` of the token is not
     * set), this SHALL be `KycNotApplicable`.
     *
     * Generated from protobuf field <code>.proto.TokenKycStatus kycStatus = 4;</code>
     * @return int
     */
    public function getKycStatus()
    {
        return $this->kycStatus;
    }

    /**
     **
     * A KYC status for the account with respect to this token.
     * <p>
     * This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
     * not supported for this token (e.g. the `kyc_key` of the token is not
     * set), this SHALL be `KycNotApplicable`.
     *
     * Generated from protobuf field <code>.proto.TokenKycStatus kycStatus = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setKycStatus($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenKycStatus::class);
        $this->kycStatus = $var;

        return $this;
    }

    /**
     **
     * A Freeze status for the account with respect to this token.
     * <p>
     * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
     * or `Unfrozen`.<br/>
     * If the token cannot freeze account assets (e.g. the `freeze_key` of the
     * token is not set), this SHALL be `FreezeNotApplicable`.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeStatus freezeStatus = 5;</code>
     * @return int
     */
    public function getFreezeStatus()
    {
        return $this->freezeStatus;
    }

    /**
     **
     * A Freeze status for the account with respect to this token.
     * <p>
     * This value SHALL be one of `FreezeNotApplicable`, `Frozen`
     * or `Unfrozen`.<br/>
     * If the token cannot freeze account assets (e.g. the `freeze_key` of the
     * token is not set), this SHALL be `FreezeNotApplicable`.
     *
     * Generated from protobuf field <code>.proto.TokenFreezeStatus freezeStatus = 5;</code>
     * @param int $var
     * @return $this
     */
    public function setFreezeStatus($var)
    {
        GPBUtil::checkEnum($var, \Proto\TokenFreezeStatus::class);
        $this->freezeStatus = $var;

        return $this;
    }

    /**
     **
     * A maximum "precision" for this token.
     * <p>
     * This value MUST match the `decimals` field of the token identified in
     * the `tokenId` field.<br/>
     * A single whole token SHALL be divided into at most
     * 10<sup>`decimals`</sup> sub-units.
     *
     * Generated from protobuf field <code>uint32 decimals = 6;</code>
     * @return int
     */
    public function getDecimals()
    {
        return $this->decimals;
    }

    /**
     **
     * A maximum "precision" for this token.
     * <p>
     * This value MUST match the `decimals` field of the token identified in
     * the `tokenId` field.<br/>
     * A single whole token SHALL be divided into at most
     * 10<sup>`decimals`</sup> sub-units.
     *
     * Generated from protobuf field <code>uint32 decimals = 6;</code>
     * @param int $var
     * @return $this
     */
    public function setDecimals($var)
    {
        GPBUtil::checkUint32($var);
        $this->decimals = $var;

        return $this;
    }

    /**
     **
     * An automatic association flag.
     * <p>
     * This SHALL be set if the relationship was created implicitly
     * (automatically).<br/>
     * This SHALL be unset if the relationship was created explicitly
     * (manually) via a `TokenAssociate` transaction.
     *
     * Generated from protobuf field <code>bool automatic_association = 7;</code>
     * @return bool
     */
    public function getAutomaticAssociation()
    {
        return $this->automatic_association;
    }

    /**
     **
     * An automatic association flag.
     * <p>
     * This SHALL be set if the relationship was created implicitly
     * (automatically).<br/>
     * This SHALL be unset if the relationship was created explicitly
     * (manually) via a `TokenAssociate` transaction.
     *
     * Generated from protobuf field <code>bool automatic_association = 7;</code>
     * @param bool $var
     * @return $this
     */
    public function setAutomaticAssociation($var)
    {
        GPBUtil::checkBool($var);
        $this->automatic_association = $var;

        return $this;
    }

}

